{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"옵시디언 플러그인 팔러 왔습니다. 혹시 옵시디언을 사용하시는 분들은 유용하게 사용하실 수 있는 플러그인들을 엄선해서 글을 작성했으니, 유용한 플러그인 얻어가시길 바랍니다. 옵시디언을 아직 안 써보신 분들은 이렇게 다양한 플러그인들이 있으니... 옵시디언에 관심 주시면 감사하겠습니다 ㅋㅅㅋ 간단하게 커뮤니티 플러그인 사용하는 법 설정 - 커뮤니티 플러그인으…","fields":{"slug":"/obsidian-plugin/"},"frontmatter":{"date":"2023년 09월 19일 03:09","title":"Obsidian Plugin 추천","tags":["obsidian"]},"rawMarkdownBody":"\n옵시디언 플러그인 팔러 왔습니다.  \n혹시 옵시디언을 사용하시는 분들은 유용하게 사용하실 수 있는 플러그인들을 엄선해서 글을 작성했으니, 유용한 플러그인 얻어가시길 바랍니다.  \n옵시디언을 아직 안 써보신 분들은 이렇게 다양한 플러그인들이 있으니... 옵시디언에 관심 주시면 감사하겠습니다 ㅋㅅㅋ\n\n## 간단하게 커뮤니티 플러그인 사용하는 법\n\n설정 - 커뮤니티 플러그인으로 들어가서 커뮤니티 플러그인 사용을 누른다.  \n\n\n![[obsidian-how-to-plugin.png]]\n\n그럼 다음과 같이 커뮤니티 플러그인을 탐색할 수 있는 버튼이 생긴다.  \n이 글에서 소개하는 커뮤니티 플러그인들은 모두 탐색에서 이름으로 검색할 수 있다.  \n\n\n![[obsidian-community-plugin.png]]\n\n## 사실상 필수 플러그인\n\n## Omnisearch\n\n노션과 옵시디언 같은 플러그인의 고질적인 문제점인 **내용 검색** 을 해결해주는 플러그인이다.  \n\n단축키를 등록해서 검색하면 내용과 제목을 포함해서 빠르게 검색 가능하다!! 삶의 질을 올려주는 정말 훌륭한 플러그인이다.\n\n![[omnisearch.png]]\n\n## Style Settings\n\n테마를 사용하다보면 테마를 커스텀하는 기능을 제공하는 테마들이 존재한다.  \n테마 커스텀을 위해서는 반드시 설치해야 하는 플러그인이다.  \n\n사용하는 테마를 선택해서 내부 상세 설정들을 변경해줄 수 있다. 이 부분은 테마마다 굉장히 상이한 부분이므로 넘어가도록 하겠다.  \n\n![[obsidian-style-settings.png]]\n\n## Templater\n\n매일 비슷한 포맷으로 글을 쓰거나, TIL 을 쓰는데 매번 템플릿 복사하는 게 너무 귀찮은 분들을 위한 플러그인.\n\n![[obsidian-templater-location.png]]\n\n`Automatic jump to cursor` 를 사용하면 템플릿 삽입 후 파일의 마지막 커서 위치로 이동할 수 있게 해준다. 필수로 체크해주면 좋다.  \n\n특히 단축키 cmd + N 을 templater create new note 에 연결해두면 정말 편하게 사용할 수 있다.  \n\n![[obsidian-templater-shortcut.png]]\n\n![[obsidian-templater-template-choose.png]]\n\ncreate new note from template 을 실행하면 템플릿을 선택할 수 있다.  \n선택하면 해당 템플릿으로 자동으로 파일을 만들어 준다.\n\n![[obsidian-templater-new-file.png]]\n\n개인적으로 TIL 의 frontmatter, template 의 frontmatter 를 자동으로 설정해주기 위해 사용한다.  \n\n## 추천하는 플러그인\n\n## Obsidian Git\n\n깃허브 블로그를 운영하고 있는 분이시라면 매번 바뀐 파일들을 커밋하기 너무 귀찮으셨을 것이다.  \nObsidian Git 은 시간 주기마다 주기적으로 커밋해주는 플러그인이다. \n\n개인적으로 커밋은 3시간 단위로 커밋하고, 푸시는 혹시 모르니 수동으로 할 수 있도록 변경해두었다.  \n\n![[obsidian-git-commit-message.png]]\n커밋 메시지를 지정해서 변경된 파일과 날짜, 파일 개수 등을 표시해줄 수도 있다.\n\n## Icon Folder\n\n밋밋한 파일들이 보기 싫으셨다면? Icon Folder 로 폴더 / 파일 아이콘을 추가할 수 있다.  \n상위 폴더에 icon inherit 을 설정해서 하위 폴더 / 파일에 icon 이 상속되도록 설정해줄 수도 있다.  \n\n![[obsidian-icon-folder.png]]\n\n## Update time on edit\n\nfrontmatter 의 문서 생성 시각, 문서 업데이트 시각을 매번 업데이트 해주는 것은 너무너무너무너무너무 귀찮은 작업이다.  \n이것도 자동화 할 수 있다. \n\n![[obsidian-date-format.png]]\n\ndate format 은 업데이트되는 시간의 형식을 정해줄 수 있다. 사진의 `date-fns documentation` 링크를 확인하면 어떻게 설정할 수 있는지 자세하게 확인할 수 있다.  \n\nupdated at 에는 frontmatter 에 저장되는 업데이트 시간 속성 이름을 입력해주면 된다. 나는 속성 이름이 updated 이기 때문에 위와 같이 작성했다.\ncreated at 에는 frontmatter 에 저장되는 생성 시간 속성 이름을 입력한다.  \n\n이렇게 설정하고 나서는 문서가 업데이트 될 때마다 분 단위로 updated 속성이 변경되며, 문서가 생성될 때 date 속성의 값이 초기화될 것이다.  \n\n## Calender\n\nTIL 을 작성했지만 노션처럼 캘린더 뷰가 없어서 아쉬우셨던 분들을 위한 플러그인.\n오른쪽 탭에 달력이 나오고, 날짜를 누르면 해당 TIL 로 이동할 수 있게 해주는 플러그인이다.  \n\n![[obsidian-calendar.png]]\n\n세부 설정은 위처럼 할 수 있다. 플러그인 **Natural Language Dates** 와 사용하면 좋다.  \n\n아래처럼 Date format 을 사용하면, TIL 파일의 이름을 가지고 캘린더가 인식하게 바꿀 수 있다.  \n\n![[obsidian-natural-language-dates.png]]\n\n이런 식으로 TIL 을 작성한 날짜들을 볼 수 있다. (군데군데 비어있는 건 넘어가주세요)\n\n![[obsidian-calendar-view.png]]\n\n## Outliner\n\nIntelliJ 단축키 opt + 화살표 로 코드를 이동하는 데 익숙하셨던 분들에게 추천하는 플러그인이다.  \n이 플러그인을 사용하면 리스트나 체크박스에 커서를 두고 shift + cmd + 위/아래 화살표 로 리스트와 체크박스를 위 아래로 이동할 수 있다!! 의외로 편한 기능이다.\n\nStick 설정은 한 번에 줄을 지울 때 체크박스나 리스트를 지울 것인지 선택하는 것이다. 개인적으로 한 번에 줄 지우는 것을 좋아해서 Never 로 설정해두었다.  \n\n![[obsidian-outliner-setting.png]]\n## Admonition\n\n옵시디언의 밋밋한 콜아웃, 인용이 아쉬우셨다면 Admonition 을 추천한다.  \n\n코드 블럭에 `ad-` prefix 를 붙이면 어떤 것들을 지원하는지 알려주는 자동완성이 나타난다. \n\n![[obsidian-admonition-prefix.png]]\n\n예시로 몇 가지를 사용해보았다. 이전보다 훨씬 깔끔하다!\n\n![[obsidian-callout.png]]\n\n추가적인 세팅은 플러그인 세팅에서 세부적으로 정할 수 있다.\n\n## 마무리\n\n옵시디언 플러그인 문의가 너무 많아... 글을 작성해보았습니다.  \n이 글이 옵시디언 플러그인을 찾아 헤메는 사람들에게 도움이 되기를 바랍니다 :)\n주기적으로 추가될 수도 있습니다 ㅋㅋ"},{"excerpt":"TODO 바론 코드 리뷰  [priority:: highest]  [due:: 2023-09-19]  [completion:: 2023-09-19] LOG 블로그가 고장났다... 이참에 그냥 다른 테마로 갈아타려고 한다. 너무 슬프다 근데 ㅠ 배운 것 느낀 것","fields":{"slug":"/2023-09-19/"},"frontmatter":{"date":"2023년 09월 19일 02:09","title":"2023년 09월 19일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\n```\n\n## TODO\n\n- [x] 바론 코드 리뷰  [priority:: highest]  [due:: 2023-09-19]  [completion:: 2023-09-19]\n\n## LOG\n\n- 블로그가 고장났다... 이참에 그냥 다른 테마로 갈아타려고 한다. 너무 슬프다 근데 ㅠ\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"RDT? Reliable Data Transfer 의 약자이다. 신뢰성 있는 데이터 전송을 위한 프로토콜의 일반적인 개념을 의미한다. TCP? 전송 제어 프로토콜 (Transmission Control Protocol) 의 약자로, 인터넷 프로토콜 스택의 전송 계층에 있는 프로토콜이다. RDT 의 구체적인 구현이다. 재전송 패킷이 손실되거나 예상한 시간 …","fields":{"slug":"/tcp/"},"frontmatter":{"date":"2023년 09월 17일 11:09","title":"TCP","tags":["tcp","network"]},"rawMarkdownBody":"\n## RDT?\n\nReliable Data Transfer 의 약자이다. 신뢰성 있는 데이터 전송을 위한 프로토콜의 일반적인 개념을 의미한다.  \n\n## TCP?\n\n전송 제어 프로토콜 (Transmission Control Protocol) 의 약자로, 인터넷 프로토콜 스택의 전송 계층에 있는 프로토콜이다. RDT 의 구체적인 구현이다. \n\n## 재전송\n\n패킷이 손실되거나 예상한 시간 내에 ACK 가 도착하지 않으면 패킷을 재전송한다.  \n\n1. ACK 가 예상 시간 내에 도착하지 않을 때 TCP 는 데이터가 유실되었다고 판단하고 재전송을 시작한다.\n2. 패킷 손실이 감지되면, TCP 는 혼잡이 원인이라고 생각하고 윈도우 크기를 줄인다. 윈도우 크기가 너무 작아져서 모든 패킷에 대한 ACK 를 빠르게 받게 되면 TCP 는 윈도우 크기를 다시 증가시키면서 전송 속도를 높인다.  \n3. ACK 가 너무 오래 도착하지 않으면 연결이 끊어진 것으로 간주하고 해당 세션에 대한 연결을 종료할 수 있다. \n\n- 시퀀스 번호: 각 패킷은 고유한 시퀀스 번호를 갖는다. 이를 통해 수신자는 패킷의 순서를 알 수 있으며, 누락된 패킷이 있는지 알 수 있다.\n- 타이머 설정: 송신자는 데이터 패킷을 보낼 때마다 재전송 타이머를 설정한다. 해당 타이머가 만료되기 전에 수신자로부터 해당 패킷의 ACK 를 받지 못하면, 패킷이 손실되었다고 판단하고 패킷을 재전송한다. \n- ACK 확인: 수신자는 패킷을 받을 때마다 해당 패킷의 ACK 를 송신자에게 전송한다. 송신자는 해당 ACK 를 통해 패킷이 성공적으로 전달되었는지 확인한다.\n- 재전송: 송신자는 ACK 를 받지 못한 패킷을 재전송한다. 네트워크 상의 패킷 손실, 지연 등 다양한 이유로 인해 필요할 수 있다.\n- Exponential Backoff: 만약 패킷이 계속해서 손실되면, 송신자는 재전송 간격을 지수적으로 증가시켜 네트워크 혼잡을 줄이려 시도한다. \n\n### 타임아웃 메커니즘\n\n연결 설정을 시도하는 동안 네트워크 지연이나 다른 문제로 인해 응답이 없는 경우를 처리하기 위해 존재한다.  \n\n1. SYN Retransmission\n\n클라이언트가 처음 SYN 패킷을 보낸 후, 서버로부터 SYN-ACK 응답을 기다리게 된다. 만약 응답이 일정 시간 내에 도착하지 않으면 클라이언트는 SYN 패킷을 다시 전송할 수 있다. 재전송되는 SYN 패킷의 타임아웃은 지수적으로 증가하며, 특정 횟수까지만 시도된다. (Linux 에서는 기본적으로 5회의 SYN 재전송을 시도하고, 이로써 총 연결 대기 시간은 약 180초 정도이다.)\n\n재전송 간격은 두 배로 증가하는 Exponential Backoff 를 사용한다.  \n\n2. Connection Timeout\n\nSYN 패킷의 재전송 횟수가 일정 횟수를 초과하고 클라이언트는 연결 시도를 중단하고 연결 실패로 간주한다. 이 때의 타임아웃을 연결 타임아웃이라 한다. 운영체제나 TCP 스택 설정에 따라 다를 수 있다. 일반적으로는 수 초 ~ 수 분 사이의 시간을 갖는다. \n\n## 플래그\n\n### PSH\n\n수신자의 TCP 스택은 버퍼링하지 않고 해당 패킷의 데이터를 즉시 애플리케이션 레벨로 전달해야 한다는 것을 나타낸다.  \n일반적으로 버퍼링된 데이터를 받는 쪽의 애플리케이션에 즉시 전달하고자 할 때 사용된다.  \n\n### ACK\n\nTCP 패킷이 확인 응답을 포함하고 있음을 나타낸다.  \nTCP 가 신뢰성 있는 데이터 전송 프로토콜이기 때문에, 데이터를 성공적으로 받았다는 것을 수신 측이 송신 측에 알려주는 확인응답 메커니즘이 필요하다.  \n\nACK 플래그와 함께 전송되는 숫자는 다음에 기대하는 시퀀스 번호를 뜻한다.  \n모든 TCP 패킷에는 ACK 플래그가 설정되어야 한다.  \n\n### RST\n\n현재 연결을 즉시 종료하도록 지시한다.  \n연결이 예상치 않게 종료되어야 할 때 사용한다. 예시로, 서버가 클라이언트로부터 받은 데이터를 해당 포트에서 수신 대기하고 있지 않은 서비스로 전달하려고 시도하는 경우 RST 패킷을 반환할 수 있다.  \n\n서버나 클라이언트에서 더 이상 데이터 통신을 원하지 않을 때도 RST 패킷을 보낼 수 있다.  \n\n"},{"excerpt":"Backlog 연결을 처리할 수 있는 스레드를 사용할 수 있을 때까지 연결을 허용하고,  수에 도달하면 추가 연결 요청은  크기를 갖는 큐에 대기하게 된다. 해당 큐를 Backlog, 백로그라고 한다. 백로그가 가득 차 있을 때, 새로운 연결 요청은 일반적으로 거절되거나 무시된다. 이미 성립된 연결에 대해서는 백로그와는 별개로 연결의 데이터 전송 상태에 …","fields":{"slug":"/tomcat/"},"frontmatter":{"date":"2023년 09월 17일 10:09","title":"tomcat","tags":["tomcat"]},"rawMarkdownBody":"## Backlog\n\n연결을 처리할 수 있는 스레드를 사용할 수 있을 때까지 연결을 허용하고, `maxConnection` 수에 도달하면 추가 연결 요청은 `acceptCount` 크기를 갖는 큐에 대기하게 된다. 해당 큐를 Backlog, 백로그라고 한다.  \n\n백로그가 가득 차 있을 때, 새로운 연결 요청은 일반적으로 거절되거나 무시된다.  \n이미 성립된 연결에 대해서는 백로그와는 별개로 연결의 데이터 전송 상태에 따라 (데이터 전송이 완료되었는가, 아닌가 등) 재전송 메커니즘이 동작한다.  \n\n### maxConnection?\n\n> Each incoming, non-asynchronous request requires a thread for the duration of that request. If more simultaneous requests are received than can be handled by the currently available request processing threads, additional threads will be created up to the configured maximum (the value of the `maxThreads` attribute). If still more simultaneous requests are received, Tomcat will accept new connections until the current number of connections reaches `maxConnections`. Connections are queued inside the server socket created by the **Connector** until a thread becomes available to process the connection. Once `maxConnections` has been reached the operating system will queue further connections. The size of the operating system provided connection queue may be controlled by the `acceptCount` attribute. If the operating system queue fills, further connection requests may be refused or may time out.\n\n톰캣은 현재 연결 수가 maxConnection 에 도달할 때까지 새 요청을 수락하며, `maxConnection` 에 도달하면 OS 가 추가로 연결할 수 있는 요청을 큐에 대기시킨다.  \n\n즉, 톰캣이 연결할 수 있는 최대 연결 수를 의미한다.  \n\n### 백로그에 존재하는 요청들의 재전송\n\n#### 백로그에 있는 요청들은 어떤 상태일까?\n\n아직 완전히 연결 성립 과정을 마치지 않은 (TCP 3-way handshake) 가 완료되기를 기다리는 연결 요청들이다.  \n백로그에서 대기 중인 요청들은 TCP handshake 가 완료되면 연결이 성립된 것으로 간주하고, 데이터를 주고받을 준비가 된다. \n\n#### 백로그에 있는 요청의 3-way handshake 과정\n\n백로그에 요청이 쌓이게 되면, 해당 요청이 처리되지 못하고 대기하게 된다. 그러나 TCP 의 재전송은 이미 성립된 연결에서 데이터 전송 중 패킷의 유실을 감지하게 될 때 주로 발생한다.  \n\n초기 연결 설정 중 (TCP Handshake) 에 문제가 발생하면 재시도할 수 있으나, 연결이 한 번 성립된 이후에는 재전송이 이루어진다.  \n\n톰캣의 백로그에 있는 요청의 handshake 과정은 다음과 같다.\n\n1. **백로그 상태의 연결 요청**: 클라이언트가 SYN 패킷을 보냈을 때, 요청이 백로그에 대기한다. 3-way handshake 첫 단계는 시작되었으나, 완료되지 않은 상태이다.\n2. **톰캣의 연결 수락**: 백로그에 대기 중인 요청 중에 톰캣이 처리할 수 있는 요청이 있으면, 서버는 SYN-ACK 패킷을 보내서 응답한다.\n3. **연결 완료**: 클라이언트가 ACK 로 응답하여 연결을 확정한다. 3-way handshake 가 완료되고, 톰캣과 클라이언트는 데이터를 주고 받을 준비가 된 것이다.\n\n#### 백로그에 존재하는 요청들의 타임아웃\n\n3-way handshake 에는 특정한 시간 제한이 없지만, TCP 자체의 재전송 메커니즘이나 운영체제 네트워크 스택에 의해 타임아웃이 발생할 수는 있다. \n\n자세한 재전송 메커니즘은 [[tcp]] 를 확인하자.\n\n## 참고\n\n- [https://tomcat.apache.org/tomcat-8.5-doc/config/http.html](https://tomcat.apache.org/tomcat-8.5-doc/config/http.html)"},{"excerpt":"LOG 미션 2단계를 제출했다. 스프링과 비슷한 구조로 만들게 되어서 너무 뿌듯하다. 역시 내가 고민한 건 스프링에서 다 고민하고 만든 구조구나. 10/13에 이사하게 돼서 오늘이 마지막 과외였다. 이사하기 전 주에 과외를 다시 모집할 예정이다. 과연 할 수 있을 것인지? 배운 것 handler-adapter 에 대해 공부했다. 미션 테스트 코드 짜느라 …","fields":{"slug":"/2023-09-17/"},"frontmatter":{"date":"2023년 09월 17일 10:09","title":"2023년 09월 17일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 미션 2단계를 제출했다. 스프링과 비슷한 구조로 만들게 되어서 너무 뿌듯하다. 역시 내가 고민한 건 스프링에서 다 고민하고 만든 구조구나.\n- 10/13에 이사하게 돼서 오늘이 마지막 과외였다. 이사하기 전 주에 과외를 다시 모집할 예정이다. 과연 할 수 있을 것인지?\n\n## 배운 것\n\n- [[handler-adapter]] 에 대해 공부했다.\n- 미션 테스트 코드 짜느라 [[mockito]] 내용을 좀 더 추가할 수 있었다.\n\n## 느낀 것\n\n- 베포후헤말 스터디에서 배웠던 내용들이 막 나오니까 너무 재밌다. 그때는 잘 이해도 안 되고 왜 이렇게 된 건지 그냥 의문만 있었는데 이제는 잘 이해돼서 진짜 신기하다. 역시 아는만큼 보이는구나 싶다.\n- 과외를 다시 하게 되면 돈을 벌게 되니까 좋고 (이전보다 많이 벌 수도), 앞으로 과외를 못 구하게 되면 공부할 시간이 늘어나니 좋다. 어찌 됐든 좋은 일이다!\n"},{"excerpt":"개요  은  메서드가 있는데 왜  은  메서드가 인터페이스에 없을까? 그 이유에 대해 간단하게 알아보자.  스프링의 빈 생명 주기에서 초기화 작업을 지원하는 콜백 인터페이스 중 하나이다. 해당 인터페이스를 구현한 빈은 모든 프로퍼티가 설정된 '후에'  메서드가 자동으로 호출된다. 이를 통해 추가적인 초기화 작업, 검증 작업을 수행할 수 있다.  메서드 스…","fields":{"slug":"/handler-mapping/"},"frontmatter":{"date":"2023년 09월 17일 07:09","title":"HandlerMapping","tags":null},"rawMarkdownBody":"\n## 개요\n\n`DispatcherServlet` 은 `initialize` 메서드가 있는데 왜 `HandlerMapping` 은 `initialize` 메서드가 인터페이스에 없을까? 그 이유에 대해 간단하게 알아보자.  \n\n## `InitializingBean`\n\n```java\npublic interface InitializingBean {  \n  \n    /**  \n     * Invoked by the containing {@code BeanFactory} after it has set all bean properties  \n     * and satisfied {@link BeanFactoryAware}, {@code ApplicationContextAware} etc.  \n     * <p>This method allows the bean instance to perform validation of its overall  \n     * configuration and final initialization when all bean properties have been set.     * @throws Exception in the event of misconfiguration (such as failure to set an  \n     * essential property) or if initialization fails for any other reason     */    void afterPropertiesSet() throws Exception;  \n  \n}\n```\n\n스프링의 빈 생명 주기에서 초기화 작업을 지원하는 콜백 인터페이스 중 하나이다.  \n해당 인터페이스를 구현한 빈은 모든 프로퍼티가 설정된 '후에' `afterPropertiesSet` 메서드가 자동으로 호출된다. 이를 통해 추가적인 초기화 작업, 검증 작업을 수행할 수 있다.  \n\n### `afterPropertiesSet` 메서드\n\n스프링 컨테이너에 의해 빈의 모든 프로퍼티가 설정된 직후에 호출된다.  \n\n보통 빈의 초기화를 위한 로직을 포함하며, 빈의 상태를 검증하거나 필요한 경우 초기 데이터를 로드하는 등의 작업을 수행할 수 있다. \n\n`InitializingBean` 을 사용하는 경우, `afterPropertiesSet` 메서드가 가장 먼저 호출되고, `init-method` 나 `@PostConstruct` 로 지정된 메서드가 호출된다.  \n\n## 스프링은 왜 굳이 객체 생성 과정과 초기화 과정을 나누었을까?\n\n초기화 과정에서는 다른 빈들과의 의존성을 설정해야 한다. 그런데 객체가 생성되었을 때, 내부의 의존성들이 아직 준비되지 않았을 가능성이 있다. 그러므로 초기화 단계에서 의존성을 주입받거나 연결하게 된다.  \n\n또한 초기화 과정을 별도로 둠으로서 특정 시점에만 초기화 로직을 실행하거나, 다양한 초기화 전략을 사용하는 것이 가능해진다.  \n\n만약 초기화 과정에서 오류가 발생하면, 이를 적절하게 처리하기 위한 로직을 추가해야 한다. 이런 경우 별도의 초기화 단계를 통해서 이런 오류를 구체적으로 파악 / 대응할 수 있다.  \n"},{"excerpt":"개요 레벨4의 mvc 미션에서  과  이 동시에 호환되게 만들어야 한다. 두 가지  이 하는 일은 동일하다. 그러나 내부 구현이 다르기 때문에 단순히 구현을 하려면 다음과 같이 만들 수 밖에 없다. 사실상 controller 를 찾고, 실행하고, view 를 찾아서 넘기는 것까지 동일한 행동인데, 내부 구현이 다르다는 이유만으로 코드가 이만큼이나 길어졌다…","fields":{"slug":"/adapter-pattern/"},"frontmatter":{"date":"2023년 09월 17일 06:09","title":"어댑터 패턴","tags":["design-pattern","디자인패턴"]},"rawMarkdownBody":"\n## 개요\n\n레벨4의 mvc 미션에서 `AnnotationHandlerMapping` 과 `ManualHandlerMapping` 이 동시에 호환되게 만들어야 한다.  \n두 가지 `HandlerMapping` 이 하는 일은 동일하다. 그러나 내부 구현이 다르기 때문에 단순히 구현을 하려면 다음과 같이 만들 수 밖에 없다.  \n\n```java\nprivate void process(final HttpServletRequest request, final HttpServletResponse response)  \n    throws ServletException {  \n    try {  \n        processAnnotationHandlerMapping(request, response);  \n    } catch (NoSuchElementException e) {  \n        processManualHandlerMapping(request, response);  \n    } catch (Throwable e) {  \n        log.error(\"Exception : {}\", e.getMessage(), e);  \n        throw new ServletException(e.getMessage());  \n    }  \n}  \n  \nprivate void processAnnotationHandlerMapping(final HttpServletRequest request, final HttpServletResponse response)  \n    throws Exception {  \n    final var controller = (HandlerExecution) annotationHandlerMapping.getHandler(request);  \n    final var modelAndView = controller.handle(request, response);  \n    move(modelAndView, request, response);  \n}  \n  \nprivate void processManualHandlerMapping(final HttpServletRequest request, final HttpServletResponse response)  \n    throws ServletException {  \n    try {  \n        final String requestURI = request.getRequestURI();  \n        final var controller = manualHandlerMapping.getHandler(requestURI);  \n        final var viewName = controller.execute(request, response);  \n        move(viewName, request, response);  \n    } catch (Throwable e) {  \n        throw new ServletException(e.getMessage());  \n    }  \n}\n```\n\n사실상 controller 를 찾고, 실행하고, view 를 찾아서 넘기는 것까지 동일한 행동인데, 내부 구현이 다르다는 이유만으로 코드가 이만큼이나 길어졌다. \n\n이런 문제를 해결할 수 있는 방법은 없을까? 바로 어댑터 패턴을 이용하면 가능하다.  \n\n## 어떻게 해결할 수 있을까?\n\n위에 있는 코드들을 살펴보면, 각각 다음과 같은 부분들이 다르다. \n\n1. `getHandler` 의 매개변수\n\t1. requestURI, request 두 가지로 나뉘어 있다.\n2. `controller` 를 실행하는 메서드\n\t1. `execute` , `handle` 두 가지로 나뉘어 있다.\n\n그 외에는 모두 동일한 로직을 수행한다. \n\n그러니 해당 메서드들을 '동일하게' 호출해줄 수 있는 어댑터 클래스를 만들 수 있다. \n\n## 어댑터 패턴이란?\n\n특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.  \n\n클라이언트와 구현된 인터페이스를 분리할 수 있으며, 변경 내역이 어댑터로 캡슐화 되기 때문에 나중에 인터페이스가 변경되더라도 클라이언트를 변경할 필요가 없다.  \n\n## 어댑터 동작 과정\n\n1. 클라이언트에서 타깃 인터페이스로 메서드를 호출하고, 어댑터에 요청을 보낸다.\n2. 어댑터는 어댑'티' 인터페이스로 그 요청을 어댑티에 관한 하나 이상의 메서드 호출로 변환한다.\n3. 클라이언트는 호출 결과는 받을 수 있으나, 중간에 어댑터가 있다는 사실을 알지 못한다.  \n\n## 변경된 코드\n\n그렇다면 코드는 어떻게 변경할 수 있을까?\n\n먼저 `HandlerAdapter` 인터페이스를 생성하자. 해당 `HandlerAdapter` 가 요청을 처리할 수 있는지 확인할 수 있는 `support` 추상 메서드와, 실제로 요청을 처리하기 위한 `handle` 추상 메서드를 생성한다.  \n\n```java\npackage webmvc.org.springframework.web.servlet.mvc.tobe;  \n  \nimport jakarta.servlet.http.HttpServletRequest;  \nimport jakarta.servlet.http.HttpServletResponse;  \nimport webmvc.org.springframework.web.servlet.ModelAndView;  \n  \npublic interface HandlerAdapter {  \n  \n    boolean supports(Object handler);  \n  \n    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;  \n}\n```\n\n## 스프링의 `HandlerAdapter` \n\n스프링에서도 마찬가지로 어댑터 패턴을 사용하고 있다. `HandlerAdapter` 에 대해 더 자세학 ㅔ알아보려면 [[handler-adapter]] 를 참고하자.\n\n## 참고\n\n- 헤드퍼스트 디자인 패턴"},{"excerpt":"HandlerAdapter MVC framework SPI, allowing parameterization of the core MVC workflow.\nInterface that must be implemented for each handler type to handle a request. This interface is used to allow the…","fields":{"slug":"/handler-adapter/"},"frontmatter":{"date":"2023년 09월 17일 06:09","title":"HandlerAdapter","tags":["spring","레벨4"]},"rawMarkdownBody":"\n## HandlerAdapter\n\n> MVC framework SPI, allowing parameterization of the core MVC workflow. \n> Interface that must be implemented for each handler type to handle a request. This interface is used to allow the DispatcherServlet to be indefinitely extensible. The DispatcherServlet accesses all installed handlers through this interface, meaning that it does not contain code specific to any handler type.\n> Note that a handler can be of type Object. This is to enable handlers from other frameworks to be integrated with this framework without custom coding, as well as to allow for annotation-driven handler objects that do not obey any specific Java interface.\n> This interface is not intended for application developers. It is available to handlers who want to develop their own web workflow.\n> Note: HandlerAdapter implementors may implement the org.springframework.core.Ordered interface to be able to specify a sorting order (and thus a priority) for getting applied by the DispatcherServlet. Non-Ordered instances get treated as the lowest priority.\n\n요청을 처리하기 위해 핸들러 타입별로 구현해야 하는 인터페이스이다.  \n핸들러는 Object 유형이 될 수 있다. 이를 통해 다른 프레임워크의 핸들러를 특정 코드 없이 프레임워크와 통합할 수 있고, 특정 Java 인터페이스를 따르지 않은 어노테이션 기반 핸들러 객체를 허용할 수 있다.  \n\n즉, `HandlerMapping` 을 통해 찾은 `Handler` 를 실행할 수 있는 객체이다.  \n\n### `supports()`\n\n> Given a handler instance, return whether this HandlerAdapter can support it. Typical HandlerAdapters will base the decision on the handler type. HandlerAdapters will usually only support one handler type each.\n\n`HandlerAdapter` 가 지원할 수 있는지 여부를 반환한다. 일반적으로 `HandlerAdapter` 들은 오직 하나의 핸들러 타입만 지원한다.  \n\n### `handle()`\n\n> Use the given handler to handle this request. The workflow that is required may vary widely.\n\n실제로 요청을 처리하는 메서드이다.  \n\n## `AbstractHandlerMethodAdapter` \n\nhandler 가 `HandlerMethod` 의 인스턴스인지 확인한다.  \n\n```java\n@Override  \npublic final boolean supports(Object handler) {  \n    return (handler instanceof HandlerMethod handlerMethod && supportsInternal(handlerMethod));  \n}\n```\n\n`supportsInternal()` 메서드는 언제나 true 를 리턴하므로, `HandlerMethod` 인스턴스이기만 하면 true 를 리턴하게 된다.  \n\n## `DispatcherServlet` 의 `getHandlerAdapter`\n\n```java\nprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {  \n    if (this.handlerAdapters != null) {  \n       for (HandlerAdapter adapter : this.handlerAdapters) {  \n          if (adapter.supports(handler)) {  \n             return adapter;  \n          }  \n       }    }    throw new ServletException(\"No adapter for handler [\" + handler +  \n          \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");  \n}\n```\n\nHandlerAdapter 가 지원할 수 있는 handler 를 찾으면 `adapter` 를 반환한다.  \n\n### `handle()`\n\n```java\n@Override  \n@Nullable  \npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)  \n       throws Exception {  \n  \n    return handleInternal(request, response, (HandlerMethod) handler);  \n}\n```\n\n내부적으로 `handleInternal()` 을 호출한다.\n\n## `RequestMappingHandlerAdapter`\n\n### `handleInternal()`\n\n```java\n@Override  \nprotected ModelAndView handleInternal(HttpServletRequest request,  \n       HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {  \n  \n    ModelAndView mav;  \n    checkRequest(request);  \n  \n    // Execute invokeHandlerMethod in synchronized block if required.  \n    if (this.synchronizeOnSession) {  \n       HttpSession session = request.getSession(false);  \n       if (session != null) {  \n          Object mutex = WebUtils.getSessionMutex(session);  \n          synchronized (mutex) {  \n             mav = invokeHandlerMethod(request, response, handlerMethod);  \n          }  \n       }       else {  \n          // No HttpSession available -> no mutex necessary  \n          mav = invokeHandlerMethod(request, response, handlerMethod);  \n       }  \n    }    else {  \n       // No synchronization on session demanded at all...  \n       mav = invokeHandlerMethod(request, response, handlerMethod);  \n    }  \n  \n    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {  \n       if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {  \n          applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);  \n       }  \n       else {  \n          prepareResponse(response);  \n       }  \n    }  \n    return mav;  \n}\n```\n\n1. `checkRequest()` 로 해당 요청이 지원되는 methods 인지, 세션이 필요한지 확인한다.  \n\n```java\n// WebContentGenerator.class\nprotected final void checkRequest(HttpServletRequest request) throws ServletException {  \n    // Check whether we should support the request method.  \n    String method = request.getMethod();  \n    if (this.supportedMethods != null && !this.supportedMethods.contains(method)) {  \n       throw new HttpRequestMethodNotSupportedException(method, this.supportedMethods);  \n    }  \n  \n    // Check whether a session is required.  \n    if (this.requireSession && request.getSession(false) == null) {  \n       throw new HttpSessionRequiredException(\"Pre-existing session required but none found\");  \n    }  \n}\n```\n\n2. 세션을 사용하는 경우 mutex 를 사용한다. 세션 사용 유무에 따라 성능 차이가 생길 수 있을 것이다.  \n3. `invokeHandlerMethod` 를 실행한다.\n\n### `invokeHandlerMethod`\n\n```java\n@Nullable  \nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,  \n       HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {  \n  \n    ServletWebRequest webRequest = new ServletWebRequest(request, response);  \n    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);  \n    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);  \n  \n    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);  \n    if (this.argumentResolvers != null) {  \n       invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);  \n    }  \n    if (this.returnValueHandlers != null) {  \n       invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);  \n    }  \n    invocableMethod.setDataBinderFactory(binderFactory);  \n    invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);  \n  \n    ModelAndViewContainer mavContainer = new ModelAndViewContainer();  \n    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));  \n    modelFactory.initModel(webRequest, mavContainer, invocableMethod);  \n    mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);  \n  \n    AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);  \n    asyncWebRequest.setTimeout(this.asyncRequestTimeout);  \n  \n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);  \n    asyncManager.setTaskExecutor(this.taskExecutor);  \n    asyncManager.setAsyncWebRequest(asyncWebRequest);  \n    asyncManager.registerCallableInterceptors(this.callableInterceptors);  \n    asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);  \n  \n    if (asyncManager.hasConcurrentResult()) {  \n       Object result = asyncManager.getConcurrentResult();  \n       mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];  \n       asyncManager.clearConcurrentResult();  \n       LogFormatUtils.traceDebug(logger, traceOn -> {  \n          String formatted = LogFormatUtils.formatValue(result, !traceOn);  \n          return \"Resume with async result [\" + formatted + \"]\";  \n       });  \n       invocableMethod = invocableMethod.wrapConcurrentResult(result);  \n    }  \n  \n    invocableMethod.invokeAndHandle(webRequest, mavContainer);  \n    if (asyncManager.isConcurrentHandlingStarted()) {  \n       return null;  \n    }  \n  \n    return getModelAndView(mavContainer, modelFactory, webRequest);  \n}\n```\n\n`RequestMapping` 핸들러 메서드를 호출하는 메서드이다.  \n\n1. `HttpServletRequest` 와 `HttpServletResponse` 를 기반으로 `ServletWebRequest` 를 생성한다.\n2. 핸들러 메서드의 입력 파라미터를 처리하기 위해 `DataBinder` 와 Model Factory 를 설정한다.\n3. `ServletInvocableHandlerMethod` 객체를 생성한다. 해당 객체는 실제로 주어진 핸들러 메서드를 호출하는 역할을 한다. `ArgumentResolver`, `ReturnValueHandler`, `DataBinderFactory` 등을 갖는다.\n4. 뷰와 모델 정보를 포함하고, 응답을 구성하는 `ModelAndViewContainer` 를 초기화한다. \n5. 요청이 비동기로 처리되는 경우, 비동기 웹 요청과 `WebAsyncManager` 설정을 한다. \n\t1. 비동기 요청의 타임 아웃, task executor, callable interceptors 나 deferred result interceptor 등이 설정된다.\n6. 현재 요청이 비동기 요청의 일부로 시작되었고, 결과가 사용가능한 경우에 핸들링한다.\n7. `invocableMethod.invokeAndHandle()` 을 통해 실제 핸들러 메서드가 호출된다.  \n8. 요청 처리 후의 뷰 정보를 `ModelAndView` 로 반환한다.\n\n## 참고\n- https://velog.io/@jihoson94/Spring-MVC-HandlerAdapter-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0"},{"excerpt":"S-HOOK 개발 서버에서 인덱스 조회 성능 개선을 위해 성능 테스트를 진행하다 마주한 에러이다. 스와이프를 하기 위해 노래를 클릭했을 때 현재 노래, 현재 노래보다 좋아요가 적은 노래들, 현재 노래보다 좋아요가 많은 노래들을 불러오는 API 의 성능 테스트를 진행했다. 그런데 개발 서버의 페이지를 연속으로 새로고침할 때마다  가 발생했다. 과연 무슨 에…","fields":{"slug":"/broken-pipe-error/"},"frontmatter":{"date":"2023년 09월 16일 13:09","title":"Broken Pipe Error","tags":["spring","shook","trouble-shooting"]},"rawMarkdownBody":"\nS-HOOK 개발 서버에서 인덱스 조회 성능 개선을 위해 성능 테스트를 진행하다 마주한 에러이다. 스와이프를 하기 위해 노래를 클릭했을 때 현재 노래, 현재 노래보다 좋아요가 적은 노래들, 현재 노래보다 좋아요가 많은 노래들을 불러오는 API 의 성능 테스트를 진행했다.  \n\n그런데 개발 서버의 페이지를 연속으로 새로고침할 때마다 `Broken Pipe Error` 가 발생했다.  \n\n과연 무슨 에러일까? 왜 발생한 걸까?\n\n## 발생한 에러\n\n```shell\norg.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe\n```\n\n발생한 에러의 전문이다. 간결하게 `Broken pipe` 라고 적혀 있다.  \n\n### java.io.IOException\n\n먼저 `IOException` 란 무엇인지 docs 를 살펴보자.  \n\n> Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.\n\n일종의 I/O 예외가 발생했으며, 실패하거나 중단된 I/O 작업으로 인해 발생하는 예외라고 한다.  \n테스트할 때 I/O 과정에서 문제가 생겼다는 것을 알 수 있다.\n\n### ClientAbortException\n\n> Extend IOException to identify it as being caused by an abort of a request by a remote client.\n\n`IOException` 을 확장한 예외로, 원격 클라이언트에 의한 요청 중단으로 인해 발생한 것이라고 쓰여 있다.  \n\n## Broken Pipe Error 란?\n\n두 소켓 Receiver, Sender 상의 통신을 가정할 때, 한 소켓 (대체로 Receiver) 가 갑작스러운 이상으로 종료된 상황에서 다른 하나의 소켓 (Sender) 가 이를 알지 못하고 데이터를 계속 전송하려고 할 때 발생한다.  \n\n즉, 서버인 Receiver 가 작업 결과를 전달할 곳이 없어 발생하는 에러이다.  \n\n다음과 같은 상황에서 발생할 수 있다.  \n\n> 1. 클라이언트에서 요청을 한다.\n> 2. 서버에서 작업을 완료한 후, 클라이언트로 결과를 전송하려 한다.\n> 3. 결과가 클라이언트로 넘겨지기 전에 네트워크가 끊기거나, 클라이언트가 정지 버튼을 누르거나, 브라우저를 종료하거나, 다른 화면으로 이동한다.\n> 4. 최초로 요청한 정보가 사라지므로 서버 측에서 작업 결과를 전달할 곳이 없어진다.\n\n페이지를 새로 고침하면 이전 connection 이 반환되지 않고, connection 을 닫았다가 새로운 연결을 다시 열기 때문에 이전 서버 요청에서 해당 오류가 발생하게 되는 것이다.  \n\n## Socket 문제일까?\n\n새 페이지가 로드되거나 현재 페이지가 새로 고침되면 이전 페이지의 모든 리소스가 닫히고, 브라우저에서 `socket.io/webSocket` 연결을 포함해서 해제된다.  \n\n즉, 서버는 새로 로드된 페이지에서 새로운 `socket.io` 연결을 받게 된다. 쿠키나 세션을 이용해서 이전 클라이언트의 연결인지 식별하고, 이전 클라이언트가 현재 새 페이지에서 재연결하는 것임을 인식한 뒤 조치를 취할 수 있다. (세션이 같으면 캐싱된 값을 내려준다든지...)  \n\n## 해결 방법\n\n구글에 여러 가지 방법들이 나와있지만, 사실 그렇게 크게 와닿지 않았다.  \n일반적인 네트워크 문제로 발생할 수 있는 예외이고, 서버의 오류가 아니기 때문에 클라이언트 단에서 막는 게 맞는 것 같다.  \n\n우리 상황에서는 클라이언트의 리프레쉬를 일정 시간 간격으로 제한하면 해결될 문제일 것 같다.  \n또한 서버에서 특정 IP, 세션에 대한 요청 빈도를 제한할 수 있을 것이다. \n\n## 참고\n\n- https://stackoverflow.com/questions/71587838/when-refreshing-the-web-page-if-keep-the-socket-unchanged"},{"excerpt":"LOG 대학원을 고민해보게 됐다. 만약 가게 된다면 네트워크나 OS 연구실에 가보지 않을까요 내내 미션만 했다... 그래도 힘들지만 재밌다. 되게 새로운 것들도 많이 배우고, 예전에는 이해 안 되던 것들이 이제는 너무 잘 돼서 재밌다 !!!! 배운 것 handler-mapping 을 공부했다. broken-pipe-error 에 대해 알아봤다. 별 거 아…","fields":{"slug":"/2023-09-16/"},"frontmatter":{"date":"2023년 09월 16일 13:09","title":"2023년 09월 16일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 대학원을 고민해보게 됐다. 만약 가게 된다면 네트워크나 OS 연구실에 가보지 않을까요\n- 내내 미션만 했다... 그래도 힘들지만 재밌다. 되게 새로운 것들도 많이 배우고, 예전에는 이해 안 되던 것들이 이제는 너무 잘 돼서 재밌다 !!!!\n\n## 배운 것\n\n- [[handler-mapping]] 을 공부했다.\n- [[broken-pipe-error]] 에 대해 알아봤다. 별 거 아니던데\n\n## 느낀 것\n\n- 이제 나도 나를 믿어볼 수 있지 않을까??????? 한 번만 더 믿어볼게 파이팅"},{"excerpt":"LOG 오늘 내내 인덱스 쿼리 성능 개선을 했다. 너무 어렵다... 튜닝하는 것도 쉬운 일이 아니다. 정리를 해야 하는데 정리를 못했다. 이런... 할 게 너무 많아서 정리가 계속 밀리고 있다. 미션 학습 테스트를 했다. 생각보다 오래 걸렸다. 역시나 이런... 얼른 미션 해야 이것저것 할 수 있는데. 배운 것 fifth-demoday-index 를 했다…","fields":{"slug":"/2023-09-15/"},"frontmatter":{"date":"2023년 09월 15일 01:09","title":"2023년 09월 15일","tags":null},"rawMarkdownBody":"## LOG\n\n- 오늘 내내 인덱스 쿼리 성능 개선을 했다. 너무 어렵다... 튜닝하는 것도 쉬운 일이 아니다. 정리를 해야 하는데 정리를 못했다. 이런... 할 게 너무 많아서 정리가 계속 밀리고 있다.\n- 미션 학습 테스트를 했다. 생각보다 오래 걸렸다. 역시나 이런... 얼른 미션 해야 이것저것 할 수 있는데.\n\n## 배운 것\n\n- [[fifth-demoday-index]] 를 했다.\n- [[query-performance-test]] 도 했다.\n- [[mysql-explain]] 에 대해서도 알아봤다.\n- 파이썬의 `round()` 는 오사오입이다... 누가 이렇게 만들었지\n \n## 느낀 것\n\n- 우테코는 나에게 정말 많은 걸 준 것 같다. 경험과 성장, 같이 의논할 수 있는 사람들, 근거 있는 생각 등.. 나는 이제 모르는 게 있어도 두렵지 않다. 어떻게 배워나가는지, 노력하면 잘할 수 있다는 걸 이제는 안다!\n"},{"excerpt":"performance_schema MySQL 서버 실행에 대한 세부적인 통계와 모니터링 정보를 제공하는 스토리지 엔진이다. 특정 쿼리의 성능 알아보기 주로  테이블을 참조한다. 이 테이블은 실행된 SQL 문의 통계를 제공하고, 다양한 정보를 통해 성능 분석을 할 수 있다. DIGEST 쿼리를 구분하는데 사용되는 값이다. DIGEST_TEXT 다이제스트에 …","fields":{"slug":"/query-performance-test/"},"frontmatter":{"date":"2023년 09월 14일 13:09","title":"performance_schema로 Query 성능 체크하기","tags":["mysql","database","레벨4","우테코","shook"]},"rawMarkdownBody":"\n## performance_schema\n\nMySQL 서버 실행에 대한 세부적인 통계와 모니터링 정보를 제공하는 스토리지 엔진이다.  \n\n### 특정 쿼리의 성능 알아보기\n\n주로 `events_statements_summary_by_digest` 테이블을 참조한다. 이 테이블은 실행된 SQL 문의 통계를 제공하고, 다양한 정보를 통해 성능 분석을 할 수 있다. \n\n- DIGEST\n\t- 쿼리를 구분하는데 사용되는 값이다.\n- DIGEST_TEXT\n\t- 다이제스트에 해당하는 실제 SQL 텍스트\n- COUNT_STAR\n\t- 쿼리가 몇 번 실행되었는지\n- SUM_TIMER_WAIT\n\t- 쿼리를 실행하는 데 걸린 전체 시간\n- MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT\n\t- 최소, 평균, 최대 실행 시간\n- SUM_ROWS_SENT, SUM_ROWS_EXAMINED\n\t- 쿼리 실행 시 반환 및 조사된 행 수\n"},{"excerpt":"EXPLAIN Extra 컬럼 Using index Covering Index Scan. 필요한 모든 데이터가 인덱스에서 직접 가져올 수 있으므로 데이터 파일을 읽을 필요가 없다. Using where 쿼리에서 WHERE 절이 사용되었고, MySQL 이 결과를 필터링 하기 위해 where 를 사용했다. Using filesort MySQL 이 결과를 정렬…","fields":{"slug":"/mysql-explain/"},"frontmatter":{"date":"2023년 09월 14일 12:09","title":"EXPLAIN","tags":null},"rawMarkdownBody":"## EXPLAIN\n\n### Extra 컬럼\n\n- Using index\n\t- Covering Index Scan. 필요한 모든 데이터가 인덱스에서 직접 가져올 수 있으므로 데이터 파일을 읽을 필요가 없다.  \n- Using where\n\t- 쿼리에서 WHERE 절이 사용되었고, MySQL 이 결과를 필터링 하기 위해 where 를 사용했다.  \n- Using filesort\n\t- MySQL 이 결과를 정렬하기 위해 디스크 기반의 정렬 기법을 사용했다. 인덱스를 사용하여 자동으로 정렬할 수 없는 경우에 발생하며, 성능에 부정적인 영향을 줄 수 있다.\n- Range checked for each record (index map: x)\n\t- JOIN 연산을 수행할 때, 가장 좋은 인덱스를 결정하기 위해 각각의 행에 대해 범위를 확인했다는 것을 나타낸다.  \n- Impossible WHERE noticed after reading const tables\n\t- WHERE 절의 조건에 따라 쿼리가 결과를 반환할 수 없음을 MySQL 이 인식했다.  \n- Using join buffer\n\t- 조인 버퍼를 사용하여 조인 연산을 수행했다.\n\t- 특정 조인 유형에서 사용되며, 성능에 영향을 줄 수 있다.\n- Select tables optimized away\n\t- 쿼리 최적화 과정에서 테이블 액세스가 필요하지 않다고 판단되어 제외되었다. \n- Distinct\n\t- 중복된 결과를 제거하기 위해 `DISTINCT` 키워드를 사용했다.\n- Using temporary\n\t- MySQL 이 쿼리의 결과를 만들기 위해 임시 테이블을 생성했다. 대개 이는 `GROUP BY`, `ORDER BY` 또는 둘 다 포함하는 쿼리에서 발생한다. `ORDER BY` 절과 `GROUP BY` 절이 서로 다른 컬럼을 참조할 때, 혹은 조인된 결과를 정렬해야 할 때 이런 상황이 발생한다.\n\t- 임시 테이블을 사용하면 디스크에 기록될 수 있기 때문에 성능 저하를 유발할 수 있다.\n\n#### Using join buffer\n\n조인 연산을 수행하기 위해 특별한 메모리 버퍼인 \"조인 버퍼\" 를 사용했다는 것이다.  \n주로 Block Nested-Loop join 에 해당하는 연산이 발생할 때 나타난다.  \n\n**Block Nested-Loop join**\n\n1. Outer 테이블의 각 레코드에 대해\n2. Inner 테이블 전체를 스캔하면서\n3. 조인 조건에 맞는 레코드를 찾는 방법\n\n**장점**\n\n조인 버퍼를 사용하면 Inner 테이블의 읽기 연산 횟수를 획기적으로 줄일 수 있다. 조인 버퍼에는 Outer 테이블에서 읽은 여러 레코드의 정보가 저장된다. 한 번의 스캔으로 여러 조인 연산을 동시에 수행할 수 있다.\n\n조인 버퍼의 크기는 `join_buffer_size` 시스템 변수로 설정할 수 있다.  \n이 값이 충분히 크면, 더 많은 Outer 테이블 레코드를 한 번에 조인 버퍼에 저장하고, 더 적은 수의 스캔으로 Inner 테이블과의 조인 연산을 완료할 수 있다.   \n\n**단점**\n\n조인 버퍼는 메모리를 사용하기 때문에, 동시에 실행되는 많은 쿼리가 조인 버퍼를 사용해야 하거나, `join_buffer_size` 가 너무 큰 경우에는 메모리 부족 문제가 발생할 수 있다.\n"},{"excerpt":"좋아요 순 노래 전체 조회 쿼리 Explain song 만 개, 킬링파트 3만 개로 테스트했다. type possible_keys key key_len ref rows filtered Extra ALL PRIMARY null null null 9910 100 Using temporary ALL null null null null 29478 100 Usin…","fields":{"slug":"/fifth-demoday-index/"},"frontmatter":{"date":"2023년 09월 14일 08:09","title":"Index로 성능 개선하기","tags":["shook","레벨4","우테코"]},"rawMarkdownBody":"## 좋아요 순 노래 전체 조회 쿼리\n\n```sql\nselect song.id, song.album_cover_url, song.created_at, song.length, song.singer, song.title, song.video_id, sum(coalesce(kp.like_count,0)) \nfrom song  \nleft join killing_part kp on song.id=kp.song_id  \ngroup by song.id  \n```\n\n### Explain\n\nsong 만 개, 킬링파트 3만 개로 테스트했다.\n\n| type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |  \n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  \n| ALL | PRIMARY | null | null | null | 9910 | 100 | Using temporary |  \n| ALL | null | null | null | null | 29478 | 100 | Using where; Using join buffer \\(hash join\\) |\n\ntype 이 ALL 로 나오기 때문에, 전체 테이블 스캔이 발생했다.  \n\n### 개선 사항\n\n- `kp.song_id` 에 인덱스 걸기\n\n| id | select\\_type | table | partitions | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |  \n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  \n| 1 | SIMPLE | song | null | index | PRIMARY | PRIMARY | 8 | null | 9910 | 100 | null |  \n| 1 | SIMPLE | kp | null | ref | idx\\_kp\\_song\\_id | idx\\_kp\\_song\\_id | 8 | shook.song.id | 3 | 100 | null |\n\n살펴보는 row 의 수가 '크게' 줄었다!\n\n- 페이지네이션 적용\n\n## 특정 킬링파트 전체 댓글 쿼리\n\n```sql\nselect comment.killing_part_id, comment.id, comment.content, comment.created_at, comment.member_id, m.id, m.created_at, m.email, m.nickname  \nfrom killing_part_comment comment  \nleft join member m on m.id=comment.member_id  \nwhere comment.killing_part_id=? \n```\n\n### Explain\n\nmember 가 1명이었음  \ncomment 4만개 기준으로 테스트\n\n\n|table | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| comment | ALL | null | null | null | null | 40051 | 10 | Using where |\n| m | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.comment.member\\_id | 1 | 100 | null |\n\n마찬가지로 ALL 로 나오는 모습이다.  \n\n### 기존 성능 체크\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- | \n| 2 | 41795000000 | 19135000000 | 20897500000 | 22660000000 | 15000000 |\n### 개선사항\n\n- `member_id`, `killing_part_id` 에 인덱스 걸기\n\n| table | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| comment | ref | idx\\_killing\\_part\\_comment\\_killing\\_part\\_id | idx\\_killing\\_part\\_comment\\_killing\\_part\\_id | 8 | const | 18564 | 100 | null |\n| m | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.comment.member\\_id | 1 | 100 | null |\n\n확인하는 row 수가 2분의 1로 감소했다.  \n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 6 | 50175000000 | 797000000 | 8362500000 | 22660000000 | 30000000 |\n\n성능도 최소 시간 기준 100분의 1로 크게 향상되었다.  \n\n## 스와이프하는 노래를 조회하는 쿼리 (비로그인)\n\n```sql\nselect * from song s where s.id=? // 기준 song 조회 \n\n// 기준 노래보다 좋아요가 많은 노래 10개 조회\nselect * from song s1_0 \nleft join killing_part k1_0 on s1_0.id=k1_0.song_id \ngroup by s1_0.id \nhaving ( \n// 좋아요 개수 값이 클 때 sum(coalesce(k1_0.like_count,0))> ( \n\t\tselect sum(coalesce(k2_0.like_count,0)) \n\t\tfrom killing_part k2_0 where k2_0.song_id=? \n\t) \n\tor \n// 좋아요 개수 같으면 id 가 큰 순으로 정렬 \n\t( \n\t\tsum(coalesce(k1_0.like_count,0))= ( \n\t\t\tselect sum(coalesce(k3_0.like_count,0)) \n\t\t\tfrom killing_part k3_0  \n\t\t\twhere k3_0.song_id=? \n\t\t) and s1_0.id>? \n\t) \n) \norder by sum(coalesce(k1_0.like_count,0)), s1_0.id // 좋아요 순 → id 작은 순 \noffset ? rows fetch first ? rows only \n\n// 아래쪽 조회하는 쿼리  \nselect * \nfrom song s1_0 \nleft join killing_part k1_0 on s1_0.id=k1_0.song_id \ngroup by s1_0.id \nhaving \nsum(coalesce(k1_0.like_count,0))< \n\t( \n\tselect sum(coalesce(k2_0.like_count,0)) \n\tfrom killing_part k2_0 \n\twhere k2_0.song_id=? \n\t) \nor \n( sum(coalesce(k1_0.like_count,0))= \n\t( \n\t\tselect sum(coalesce(k3_0.like_count,0)) \n\t\tfrom killing_part k3_0 \n\t\twhere k3_0.song_id=? \n\t) \n\tand s1_0.id<? \n) \norder by sum(coalesce(k1_0.like_count,0)) desc, s1_0.id desc \noffset ? rows fetch first ? rows only \n\n// 기준 노래의 킬링파트 조회하는 로직 \nselect * from killing_part k1_0 where k1_0.song_id=?\n```\n\n## Explain\n\n- 기준 노래보다 좋아요가 많은 데이터 조회 및 정렬\n\n| select\\_type | table | type | possible\\_keys | key | ref | rows | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| PRIMARY | s1\\_0 | ALL | PRIMARY | null | null | 9910 | Using temporary; Using filesort |\n| PRIMARY | k1\\_0 | ALL | null | null | null | 29478 | Using where; Using join buffer \\(hash join\\) |\n| SUBQUERY | k3\\_0 | ALL | null | null | null | 29478 | Using where |\n| SUBQUERY | k2\\_0 | ALL | null | null | null | 29478 | Using where |\n\n모두 ALL Search 를 수행하고 있으며, filesort 또한 수행되고 있는 것을 볼 수 있다. (성능에 안 좋다는 건 다 들어간 인스턴스 쿼리;;)\n\n- 기준 노래보다 좋아요가 적은 데이터 조회 및 정렬\n\n| select\\_type | table | type | possible\\_keys | key | ref | rows | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| PRIMARY | s1\\_0 | ALL | PRIMARY | null | null | 9910 | Using temporary; Using filesort |\n| PRIMARY | k1\\_0 | ALL | null | null | null | 29478 | Using where; Using join buffer \\(hash join\\) |\n| SUBQUERY | k3\\_0 | ALL | null | null | null | 29478 | Using where |\n| SUBQUERY | k2\\_0 | ALL | null | null | null | 29478 | Using where |\n\n마찬가지로 ALL search 수행 중이다.\n\n- song_id 로 킬링파트 조회\n\n| select\\_type | table | type | key | ref | rows | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| SIMPLE | k1\\_0 | ALL | null | null | 29478 | Using where |\n\nALL Search 진행 중이다.\n\n### 성능 측정\n\n- 좋아요 많은 거 쿼리 (캐시 안 타도록)\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 4 | 432433000000 | 102933000000 | 108108250000 | 114617000000 | 119000000 |\n\n- 좋아요 적은 거 쿼리 (캐시 안 타도록)\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 5 | 510016000000 | 91359000000 | 102003200000 | 111161000000 | 31000000 |\n\n- 킬링파트 조회 쿼리 (캐시 안 타도록)\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 4 | 99311000000 | 23335000000 | 24827750000 | 26468000000 | 14000000 |\n\n### 개선 방법\n\n- `killing_part` 의 `song_id` 인덱싱\n\n### 이후 성능 측정\n\n- 좋아요 많은 거 조회\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 20 | 1597450000000 | 65837000000 | 79872500000 | 114617000000 | 185000000 |\n\nMIN_TIMER_WAIT 성능 30% 개선\n\n- 좋아요 아래 조회\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 20 | 1406030000000 | 53473000000 | 70301500000 | 111161000000 | 97000000 |\n\nMIN_TIMER_WAIT 성능 250% 악화\n\n- 킬링파트 조회\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 10 | 101400000000 | 288000000 | 10140000000 | 26468000000 | 34000000 |\n\n1/5 "},{"excerpt":"Reflection Runtime에 동적으로 특정 Class 의 정보를 추출할 수 있는 프로그래밍 기법이다. 리플렉션으로 형은 알고 있지만 형변환을 할 수 없는 상태에서 객체의 메서드를 호출할 수 있다. 힙 영역에 로드된 Class 타입의 객체를 통해 원하는 클래스의 인스턴스를 생성할 수 있도록 정적 바인딩보다는 성능상 오버헤드가 있지만 동적 바인딩을 통…","fields":{"slug":"/reflection/"},"frontmatter":{"date":"2023년 09월 13일 03:09","title":"Reflection (리플렉션)","tags":["java","레벨4","우테코"]},"rawMarkdownBody":"\n## Reflection\n\nRuntime에 동적으로 특정 Class 의 정보를 추출할 수 있는 프로그래밍 기법이다.  \n리플렉션으로 형은 알고 있지만 형변환을 할 수 없는 상태에서 객체의 메서드를 호출할 수 있다.  \n\n힙 영역에 로드된 Class 타입의 객체를 통해 원하는 클래스의 인스턴스를 생성할 수 있도록 \n\n정적 바인딩보다는 성능상 오버헤드가 있지만 동적 바인딩을 통해 상속과 다형성 등 다양한 기능을 사용할 수 있는 장점이 있다.  \n\n### 동적 바인딩 특징\n\n- Runtime 에 결정\n- Late Binding 이라고도 부른다.\n- Overriding\n- Java 에서의 다형성, 상속을 가능하게 해준다.\n\n## Reflection 활용처\n\n- 동적으로 Class 를 사용해야 하는 경우\n\t- 코드 작성 시점에서는 어떠한 Class 를 사용해야할지 모르지만 Runtime 에 Class 를 가져와서 실행해야 하는 경우\n- Test Code 작성\n\t- private 변수를 변경하고 싶거나 private method 를 테스트할 경우\n- 자동 Mapping 기능 구현\n\t- IDE 사용 시 특정 단어를 입력하면 이와 관련된 Class 나 메서드들을 IDE 가 먼저 확인하고 사용자에게 제공한다.\n- Jackson, GSON 등의 JSON Serialization Library\n\t- Reflection 을 사용하여 객체 필드의 변수명 / 어노테이션명을 json key 와 mapping 해주고 있다.\n- 정적 분석 tool\n\n### 주의점\n\n- 성능 이슈\n- 보안 이슈\n- `setAccessible(true)` 를 사용하여 private 필드나 메서드에 접근할 경우 보안 취약점을 초래할 수 있다.\n\n## 사용법\n\n### 클래스 객체 얻기\n\n- `getSimpleName()`\n\t- 클래스의 단순한 이름 반환. 패키지나 외부 클래스 없이 클래스 이름만을 반환한다.\n\t- `java.util.Map.Entry` 의 경우 `Entry` 만을 반환한다.\n- `getName()`\n\t- 클래스의 완전히 정규화된 이름을 반환한다. 패키지 이름을 포함한다.\n\t- `java.util.Map.Entry` 의 경우 `java.util.Map.Entry` 를 반환한다.\n\t- 내부 클래스의 경우 `OuterClass$InnerClass` 를 반환한다.  \n```java\npublic class OuterClass {\n    public class InnerClass {\n    }\n}\n\nClass<?> innerClass = OuterClass.InnerClass.class;\nSystem.out.println(innerClass.getName()); // 출력: OuterClass$InnerClass\n\n```\n- `getCanonicalName()`\n\t- 클래스의 캐노니컬 이름 (코드에서 사용되는 형식의 이름) 을 반환한다.\n\t- 대부분의 클래스에 대해 `getName()` 과 동일한 이름을 반환하지만, 내부 클래스의 경우 `$` 대신 `.` 을 사용해서 이름을 반환한다.\n\t- `java.util.Map.Entry` 의 경우 `java.util.Map.Entry` 를 반환한다.\n\n### 필드 얻어오기\n\n- `getField(String name)` : 특정 이름의 필드를 가져오고 싶은 경우에 사용한다. `public` 필드에만 접근할 수 있다.  \n```java\nClass<?> clazz = SomeClass.class;\nField field = clazz.getField(\"fieldName\");\n```\n- `getFields()` : 해당 클래스와 상속받은 부모 클래스의 모든 `public` 필드를 가져올 수 있다.  \n```java\nClass<?> clazz = SomeClass.class;\nField[] fields = clazz.getFields();\n```\n- `getDeclaredField(String name)` : 해당 클래스의 모든 접근 제한자를 가진 필드를 이름으로 가져올 수 있다.  \n```java\nClass<?> clazz = SomeClass.class;\nField field = clazz.getDeclaredField(\"privateFieldName\");\n```\n- `getDeclaredFields()` : 해당 클래스의 `private` 필드를 포함한 모든 필드를 가져온다.  \n```java\nClass<?> clazz = SomeClass.class;\nField[] fields = clazz.getDeclaredFields();\n```\n- `Field` 객체로 객체 필드 값에 접근할 수 있다. `setAccessible(true)` 를 사용해서 `private` 필드에도 접근 가능하다.\n```java\nSomeClass instance = new SomeClass();\nField field = SomeClass.class.getDeclaredField(\"someField\");\nfield.setAccessible(true);\nObject value = field.get(instance);\n```\n\n### 생성자 가져오기\n\n- `getConstructors()` : 해당 클래스의 모든 `public` 생성자를 가져온다.\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?>[] constructors = clazz.getConstructors();\n```\n- `getConstructor(Class<?>... parameterTypes)` : 특정 파라미터 타입들을 가진 public 생성자를 가져온다.\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?> constructor = clazz.getConstructor(String.class, int.class);\n```\n- `getDeclaredConstructors()` : private 포함한 모든 생성자 가져오기\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?>[] constructors = clazz.getDeclaredConstructors();\n```\n- `getDeclaredConstructor(Class<?>... parameterTypes)` : 특정 파라미터 타입들을 가진 모든 접근 제한자에 대한 생성자를 가져올 수 있다. \n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?> constructor = clazz.getDeclaredConstructor(String.class);\n```\n- `getEnclosingConstructor()` : 특정클래스나 인터페이스가 다른 생성자 내부에서 정의된 경우 해당 생성자를 나타내는 `Constructor` 객체를 반환한다.\n```java\npublic class OuterClass {\n\n    public OuterClass() {\n        class InnerClass {\n        }\n    }\n\n    public static void main(String[] args) {\n        Class<?> innerClazz = null;\n\n        // 이렇게 하면 OuterClass의 모든 선언된 클래스들을 가져옵니다.\n        for (Class<?> declaredClass : OuterClass.class.getDeclaredClasses()) {\n            if (declaredClass.getSimpleName().equals(\"InnerClass\")) {\n                innerClazz = declaredClass;\n                break;\n            }\n        }\n\n        if (innerClazz != null) {\n            Constructor<?> enclosingConstructor = innerClazz.getEnclosingConstructor();\n            System.out.println(enclosingConstructor);\n        }\n    }\n}\n```\n- 객체 생성하기\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?> constructor = clazz.getDeclaredConstructor(String.class);\nconstructor.setAccessible(true);\nSomeClass instance = (SomeClass) constructor.newInstance(\"parameterValue\");\n```\n\n## 어노테이션 유무\n\n### 어노테이션이 있는가?\n\n- `isAnnotationPresent`  \n클래스에 어노테이션이 존재하는지 확인해주는 메서드이다.  \n\n```java\npublic class AnnotationChecker {\n    public static void main(String[] args) {\n        Class<MyClass> clazz = MyClass.class;\n\n        if (clazz.isAnnotationPresent(MyAnnotation.class)) {\n            System.out.println(\"MyAnnotation is present on MyClass.\");\n        } else {\n            System.out.println(\"MyAnnotation is not present on MyClass.\");\n        }\n    }\n}\n```\n\n만약 객체의 클래스에 어노테이션이 붙어있는지 확인하려면 `getClass().isAnnotationPresent()` 를 해주면 된다.  \n\n## 참고\n\n- GPT 와 대화하기"},{"excerpt":"SPOF nginx 언제 문제가 발생할 수 있을까? 하드웨어 장애가 발생하는 경우 WAS, WS 가 모두 다운된다. 어떻게 해결할 수 있을까? 서버 분리 => nginx와 WAS 를 별개의 서버로 분리한다. 해당 해결책으로 어떤 문제가 생길 수 있을까? 서버를 분리하더라도 SPOF 가 될 가능성이 존재한다 => nginx 서버도 이중화를 진행한다. WAS…","fields":{"slug":"/level4-architecture-shook/"},"frontmatter":{"date":"2023년 09월 12일 12:09","title":"인프라 개선하기","tags":["레벨4","우테코"]},"rawMarkdownBody":"\n## SPOF\n\n### nginx\n\n- 언제 문제가 발생할 수 있을까?\n\t- 하드웨어 장애가 발생하는 경우 WAS, WS 가 모두 다운된다.\n- 어떻게 해결할 수 있을까?\n\t- 서버 분리 => nginx와 WAS 를 별개의 서버로 분리한다.\n- 해당 해결책으로 어떤 문제가 생길 수 있을까?\n\t- 서버를 분리하더라도 SPOF 가 될 가능성이 존재한다 => nginx 서버도 이중화를 진행한다.\n\n### WAS\n\n- 언제 문제가 발생할 수 있을까?\n\t- 디스크 용량 초과\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- 서버를 추가하고, 로드 밸런싱을 도입한다. standby 서버에서는 health check 를 통해 다른 서버에 장애가 발생하면 standby 서버에서 요청을 받도록 설정한다.\n\t- \n- 해당 해결책으로 어떤 문제가 생길 수 있을까?\n\t- 동시성 이슈가 발생할 수 있다.\n\n### DBMS\n\n- \n\n### AWS AZ\n\n- prod 서버와 prod DB 서버 AWS 리전 동일하게 세팅하기\n\n### 고민한 부분\n\n1. 특별히 고려해야 할 중요 기능\n- 서비스 특성 상 데이터 조회가 자주 발생한다.\n- 한 페이지 내에서 여러 번 요청을 보내는 경우가 많아 초당 요청 수가 많아질 수 있다.\n\n2. 문제가 될 수 있는 부분\n- DB: 하드웨어 장애 시 DB 장애 시간이 서버 장애 시간이 된다.\n- WS-nginx: 요청이 WAS로 포워딩되지 않는다.\n- 서버: 초당 요청이 많아지면 병목 현상 발생, Connection timeout이 빈번하게 발생할 수 있다.\n- runner: 메모리 사용량이 증가하며 리소스가 부족하게 되면 runner 실행 자체가 WAS 에 영향을 줄 수 있다.\n\n3. 적용할 수 있는 방법\n\n- WS, WAS와 분리\n- runner 서버 WAS 와 분리\n- WS, WAS, runner 서버 이중화\n- DB Replication\n\t- Master, Slave 로 이중화\n\t- Backup DB\n- 로드밸런서로 서버 부하 분산\n- 장애 발생한 서버 발생 시 로드밸런서가 다른 WAS 로 요청 전송\n- Master DB 장애 발생 시, slave DB 가 Master 로 승격. \n\n4. 발생할 수 있을 것으로 예상되는 문제\n\n- 로드밸런서가 SPOF 가 될 수 있다.\n- DB 이중화 시 동기화 문제\n\n5. 4번 해결할 아이디어\n\n- 로드밸런서 다중화"},{"excerpt":"Reflection 컴파일한 클래스를 동적으로 프로그래밍 가능하도록 자바에서 지원하는 기능. 리플렉션으로 가능한 작업? Junit 처럼  어노테이션을 표시한 메서드를 찾아서 실행 할 수 있다. 런타임 객체의 클래스, 필드, 메서드 정보를 알 수 있다. IDE 가 자동으로 getter, setter 를 생성할 수 있다. 자바 객체와 데이터베이스 테이블을 매…","fields":{"slug":"/level4-mvc/"},"frontmatter":{"date":"2023년 09월 12일 02:09","title":"레벨4 MVC 구현하기","tags":["레벨4","우테코","spring"]},"rawMarkdownBody":"\n## Reflection\n\n컴파일한 클래스를 동적으로 프로그래밍 가능하도록 자바에서 지원하는 기능.\n\n### 리플렉션으로 가능한 작업?\n\n- Junit 처럼 `@Test` 어노테이션을 표시한 메서드를 찾아서 실행 할 수 있다.\n- 런타임 객체의 클래스, 필드, 메서드 정보를 알 수 있다. \n- IDE 가 자동으로 getter, setter 를 생성할 수 있다.\n- 자바 객체와 데이터베이스 테이블을 매핑할 때 사용한다.\n\n## 웹 애플리케이션의 발전 과정\n\n### Servlet (1996)\n\n- Web Application Server, WAS\n\t- Servlet Container - Tomcat\n- WAS 를 효율적으로 다루기 위한 Java EE\n\t- Java Enterprise Edition, 기업 시스템 용 자바\n\t- 대규모 웹 애플리케이션 개발을 위한 표준\n\t\t- Servlet 을 사용하면 Thread 를 사용해서 좀 더 효율적으로 동작할 수 있게 된다.\n- Tomcat\n\t- Servlet 표준을 구현한 Servlet Container\n\t- 멀티 스레드 지원 및 관리\n\t- Http 요청 자체 처리\n\n#### 문제점\n\n디자이너들이 서블릿 소스 코드라서 수정을 못한다.  \n디자이너들이 작업하는 동안에는 그 부분을 처리 못하게 된다.  \n\n### JSP (1999)\n\n- JSP 0.92 spec 에서 JSP model1, JSP model 2 를 제안\n\t- JavaBeans: Reusable components\n\t- Java: Scripting language\n\t- Java Servlet: Compiled JavaServer Pages object\n\n### MVC (2000) \n\n- JavaWorld 에 Govind Seshadri 가 model 2를 MVC 아키텍처 패턴으로 공식화 제안\n- Apache Struts 프로젝트를 출시하며 model 2 패턴 구현 주장\n- 이후 여러 프레임워크에서 MVC 패턴을 도입했다고 주장\n\n### Framework (2003)\n\n- 대규모 웹 애플리케이션의 복잡함\n\t- Spring 은 초기 J2EE 사양의 복잡성에 대한 대응책으로 2003년에 탄생했다.\n- Spring Framework\n\t- Spring 은 기본적으로 POJO 를 사용하여 애플리케이션을 구축할 수 있도록 지원하는 기술\n- POJO\n\t- 이상적으로 말하자면, POJO 는 Java 언어 사양에 의해 강제되는 것 이외의 다른 제한에 구속되지 않는 Java 객체이다.\n\n### Non-blocking\n\n- Reactive\n\t- Non-blocking I/O\n\t- Functional\n- Node.js (2009)\n- Spring WebFlux (2020)\n\n## Servlet\n\n- 서블릿은 웹 서버 내에서 실행되는 작은 Java 프로그램이다. \n- 자바 공식 표준 기술\n\t- javax.servlet -> jakarta.servlet\n\n프레임워크를 사용하지 않아도 웹 서비스를 만들 수 있다!\n\n### 서블릿을 알아야 할까? 스프링만으로 충분하지 않을까?\n\nDispatcherServlet 도 Servlet 의 구현체이다.\n\n스프링이 잘 감싸고 있지만, Servlet 의 이해가 있어야 문제가 생겼을 때 잘 해결할 수 있다.\n\n### 서블릿 살펴보기\n\n- 라이프 사이클 메서드\n\t- init(), service(), destroy()\n\n#### 라이프 사이클이란?\n\n객체 세상에서 객체의 생성부터 처리, 종료되는 전체 사이클을 뜻한다.\n\n- servlet life-cycle method \n\t- 서블릿을 초기화하고 요청을 처리하고 종료될 때 처리할 작업을 정의하는 메서드 \n- 누가 라이프 사이클 메서드를 실행하는 걸까? \n\t- 서블릿 컨테이너 tomcat, jetty 등등\n\n## 서블릿과 서블릿 컨테이너\n\n1. 사용자 요청이 컨테이너에게 전달된다.\n2. 컨테이너는 response, request 를 생성한다.\n3. 요청에서 찾은 servlet 에게 service 메서드로 요청과 응답을 전달한다. 서블릿의 스레드가 요청을 처리한다.\n4. 요청 처리를 하고, response 를 만들어서 전달한다.\n5. 컨테이너가 응답을 사용자에게 전달한다.\n\n### 서블릿 하나로 다수 요청을 처리한다\n\n- 주의 사항\n\t- 서블릿은 서블릿 컨테이너에서 한 개만 존재한다\n\t- 하나의 서블릿에 여러 스레드가 service() 메서드를 공유한다.\n\t- service() 메서드가 멤버 변수나 static 변수를 변경하면 안 된다.\n\n"},{"excerpt":"LOG 드디어 홍보를 시작했다. 트위터에 첫 홍보했는데 ㄷㄱㄷㄱㄷ... 과연 어떻게 될 것인가...!! 기대하지는 말라했지만 그래도 기대하고 싶은 마음이다 🥹 https://twitter.com/2023shook/status/1701162561012646209?s=20 RT 이벤트 중이니 많관부 입니다 교통카드가 돌아오지를 않는다.. 돌아와 제발 다음 달…","fields":{"slug":"/2023-09-11/"},"frontmatter":{"date":"2023년 09월 11일 14:09","title":"2023년 09월 11일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 드디어 홍보를 시작했다. 트위터에 첫 홍보했는데 ㄷㄱㄷㄱㄷ... 과연 어떻게 될 것인가...!! 기대하지는 말라했지만 그래도 기대하고 싶은 마음이다 🥹 https://twitter.com/2023shook/status/1701162561012646209?s=20 RT 이벤트 중이니 많관부 입니다\n- 교통카드가 돌아오지를 않는다.. 돌아와 제발\n- 다음 달 쯤에 이사갑니다.\n\n## 배운 것\n\n- [[shook-like-issue]] 좀 더 보강했다. 다른 사람들에게 물어보고 다니려면 정리해 놓은 글이 필요할 것 같아서... 내일 마저 보강해보자.\n\n## 느낀 것\n\n- 서비스는 역시 다르구나... 회원 탈퇴했을 때 댓글이랑 좋아요를 삭제해야 하는데 그런 기능을 만들어야 하는 것 자체도 까먹었다. 그래도 더 일이 커지기 전에 오늘 발견해서 다행이다."},{"excerpt":"Thread Pool 프로그램 실행에 필요한 Thread 들을 미리 생성해놓다. Tomcat 3.2 이전에서는 요청이 들어올 때마다 Servlet 을 실행할 Thread 를 생성하고, 요청이 끝나면 destroy 했다. 이는 다음과 같은 문제가 발생하게 한다. 모든 요청에 대해 스레드 생성 / 소멸을 수행하는 것이 OS, JVM 에 큰 부담이 된다. 동시…","fields":{"slug":"/tomcat-thread-pool/"},"frontmatter":{"date":"2023년 09월 10일 06:09","title":"Tomcat Thread Pool","tags":["레벨4","우테코","tomcat"]},"rawMarkdownBody":"\n## Thread Pool\n\n프로그램 실행에 필요한 Thread 들을 미리 생성해놓다.  \nTomcat 3.2 이전에서는 요청이 들어올 때마다 Servlet 을 실행할 Thread 를 생성하고, 요청이 끝나면 destroy 했다. 이는 다음과 같은 문제가 발생하게 한다.  \n\n1. 모든 요청에 대해 스레드 생성 / 소멸을 수행하는 것이 OS, JVM 에 큰 부담이 된다.\n2. 동시에 일정 수준 이상의 다수 요청이 들어오는 경우 리소스 소모에 대한 억제가 어렵다. 순간적으로 서버가 다운되거나, 동시 요청을 처리하지 못해 발생하는 문제가 생길 수 있다.  \n\n### Thread?\n\n실행 중인 프로그램을 프로세스라고 하고, 프로세스의 실행단위가 스레드이다.  \n프로그램이 돌아가면서 여러 가지 작업들을 동시에 할 수 있다.  \n\nJava 는 One-to-One Threading-Model 로 Thread 를 생성한다.  \n\nUser Thread (Process의 스레드) 생성 시, OS Trhead (OS 레벨의 스레드) 와 연결해야 한다.  \n즉, 새로운 Thread 를 생성할 때마다 OS Kernel 의 작업이 필요해서 생성 비용이 많이 든다.  \n\n### One-to-One Threading Model 이란?\n\nJava 애플리케이션에서 스레드를 생성하면 운영체제에서도 해당 스레드에 대응하는 네이티브 스레드가 생성되는 것이다. Java 스레드가 실제 운영체제 스레드의 모든 기능을 활용할 수 있다 (ㄷㄷ)\n\n이런 특성 때문에 I/O 바운드 작업에서는 비효율적일 수 있다.\n\n#### 장점\n\n- 성능: Java 스레드가 네이티브 스레드에 직접 매핑되어 성능이 좋다.\n- 병렬처리: 현대의 멀티 코어 프로세서 환경에서 Java 스레드는 실제 CPU 코어를 활용하여 병렬 처리가 가능하다.  \n\n#### 단점\n\n- 자원 사용: 각 스레드마다 운영체제 자원이 필요하므로 과도한 스레드 생성은 성능 저하를 초래할 수 있다.  \n- 관리 비용: 너무 많은 스레드를 생성하면 스레드 간의 컨텍스트 스위칭 비용이 증가하고, 스레드 관리에 필요한 추가적인 오버헤드가 발생한다. \n\n### Thread Pool 이 왜 필요할까?\n\nThread 는 생성 비용이 커서 너무 많이 만들면 위험하다.  \n이를 해결하기 위해 pool 이 고안되었다. 미리 Thread 를 만들어 두어 재사용할 수 있게 한다.  \n\n또한 사용할 Thread 개수를 제한하여 무제한으로 스레드가 생성되지 않아 방지할 수 있다.  \n\n스프링 부트는 내장 서블릿 컨테이너 Tomcat 을 지원한다.  \n따라서 `application.yml` 을 변경해주어서 Tomcat 설정을 변경할 수 있다. \n\n### application.yml\n\n```yml\n# application.yml (적어놓은 값은 default)\nserver:\n  tomcat:\n    threads:\n      max: 200 # 생성할 수 있는 thread의 총 개수\n      min-spare: 10 # 항상 활성화 되어있는(idle) thread의 개수\n    max-connections: 8192 # 수립가능한 connection의 총 개수\n    accept-count: 100 # 작업 큐의 사이즈\n    connection-timeout: 20000 # timeout 판단 기준 시간, 20초 (기본 값 없음)\n  port: 8080 # 서버를 띄울 포트번호\n```\n\n- max-connections\n톰캣이 동시에 처리할 수 있는 Connection 의 최대 개수이다.  \nWeb 요청이 들어올 때, Tomcat 의 Connector 가 Connection 을 생성하면서 요청된 작업을 Thread Pool 의 Thread 에 연결한다.  \n해당 값이 크면 많은 수의 동시 사용자 요청을 처리할 수 있으나, 너무 큰 값은 서버 자원을 과도하게 사용하게 할 수 있어 서버의 전반적인 성능과 안정성에 영향을 줄 수 있다.  \n\n- accept-count (백로그라고 하기도 한다.)\nmax-connections 이상의 요청이 들어왔을 때 사용하는 대기열 Queue 의 크기이다.  \naccept-count 이상의 요청이 들어오면 추가적으로 들어오는 요청은 거절될 수 있다.  \n해당 값이 너무 크면 과도한 요청이 대기 상태로 유지될 수 있어 사용자가 시스템이 느려진 것처럼 느낄 수 있다. 값이 너무 작으면 초과된 요청들이 거부될 수 있다.  \naccept-count 를 통해 서버가 일시적인 트래픽 증가에 유연하게 대응할 수 있게 된다.  \n\n#### 왜 accept-count 가 상대적으로 작은 값을 갖게 될까?\n\n일반적으로 대기열이 너무 커지면 좋지 않다.  \n대기열이 너무 커지면 연결 요청이 길게 대기하게 되고, 사용자가 응답 지연을 경험하게 된다.  \n이는 시스템의 불안정성을 나타내며, 사용자에게 좋지 않은 경험을 제공한다.\n\n#### 디폴트 옵션\n\ntomcat 9.0 의 디폴트 옵션은 max-connections 200개, min-spare 25개이다. 스프링부트에서는 200개, 10 개를 디폴트 값으로 잡았다.\n\n**왜 Spring Boot 에서는 디폴트 값을 10개로 줄였을까?**\n\nGPT 에게 물어본 결과\n\n1. Spring Boot 는 제한적인 환경 (작은 크기의 클라우드 인스턴스, 개발자의 로컬 환경 등) 에서도 원활하게 동작할 수 있도록 보수적인 디폴트 환경을 제공할 수 있다.  \n2. 작은 환경에서는 너무 많은 동시 연결이나 대기 연결을 허용하면 메모리 부족 문제나 다른 리소스 부족 문제가 발생할 수 있다. 이런 문제의 발생 가능성을 줄이기 위해 낮췄을 것이다.\n\n## Thread Pool 의 Flow\n\n1. 첫 작업이 들어오면 core size 만큼의 스레드를 생성한다. \n2. 유저 요청이 들어올 때마다 작업 큐에 담아둔다. \n3. core size 의 스레드 중, 유휴상태(idle) 인 스레드가 있다면 작업 큐에서 작업을 꺼내서 스레드에 작업을 할당하여 처리한다. \n\t1. 유휴 상태인 스레드가 없다면 작업 큐에서 대기한다.\n\t2. 작업 큐가 꽉 찬다면 스레드를 새로 생성한다.\n\t3. 스레드 최대 사이즈에 도달하고 작업 큐도 꽉 차게 되면 추가 요청에 대해 connection-refused 오류를 반환한다.\n4. 태스크가 완료되면 스레드가 다시 유휴 상태로 돌아간다. \n\t1. 작업 큐가 비어있고, core size 이상의 스레드가 생성되어 있다면 스레드를 destroy 한다.\n\n## Executor\n\n`Executor` 인터페이스는 Runnable 객체를 받는 `execute` 메서드를 갖는다. \n\n```java\nExecutor executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -> System.out.println(\"Hello World\"));\n```\n\n## ExecutorService\n\n작업의 진행 상황을 제어하고 서비스 종료를 관리하는 많은 메서드가 포함되어 있다.  \n리턴된 `Future` 객체를 사용해서 실행을 제어할 수도 있다.  \n\n```java\nExecutorService executorService = Executors.newFixedThreadPool(10);\nFuture<String> future = executorService.submit(() -> \"Hello World\");\n// some operations\nString result = future.get();\n```\n\n실제로는 일반적으로 `future.get()` 을 바로 호출하지 않고, 실제로 계산 값이 필요할 때까지 호출을 미루는 것이 좋다.  \n\n`Runnable` 또는 `Callable` 을 받을 수 있다. 함수형 인터페이스나 람다로 전달 가능하다.  \n\n## ThreadPoolExecutor\n\n`corePoolSize` , `maximumPoolSize`, `keepAliveTime` 을 설정 매개변수로 갖는다.  \n\n`corePoolSize` 는 객체화 되어 스레드 풀에 유지될 코어 스레드의 수이다. 새 작업이 들어올 때 모든 코어 스레드가 사용 중이고, 작업 큐가 다 차면 poolSize 까지 `maximumPoolSize` 까지 커지는 것을 허용한다.  \n\n`keepAliveTime` 은 `corePoolSize` 를 초과해서 객체화된 초과된 스레드들이 idle 상태로 존재할 수 있는 시간 간격을 의미한다.  \n기본적으로 `ThreadPoolExecutor` 는 non-core 코어 스레드만을 삭제 대상으로 고려한다.  \n코어 스레드에도 같은 삭제 정책을 적용하려면 `allowCoreThreadTimeOut(true)` 메서드를 사용할 수 있다.  \n\n### newFixedThreadPool\n\n`corePoolSize` 와 `maximumPoolSize` 매개변수 값이 같고, `keepAliveTime` 이 0인 ThreadPoolExecutor 를 생성한다.  \n즉, 스레드 풀의 스레드 수는 항상 동일하다.  \n\n```java\nThreadPoolExecutor executor = \n  (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\n\nassertEquals(2, executor.getPoolSize());\nassertEquals(1, executor.getQueue().size());\n```\n\n### Executors.newCachedThreadPool()\n\n미리 구성된 다른 `ThreadPoolExecutor` 를 생성할 수 있다.  \n스레드 수를 입력 받지 않으며, 기본적으로 `corePoolSize` 를 0으로 설정하고 `maximumPoolSize` 를 `Integer.MAX_VALUE` 로 설정한다. `keepAliveTime` 은 60초이다.  \n\n```java\nThreadPoolExecutor executor = \n  (ThreadPoolExecutor) Executors.newCachedThreadPool();\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\n\nassertEquals(3, executor.getPoolSize());\nassertEquals(0, executor.getQueue().size());\n```\n\n이는 스레드 풀이 작업 수를 수용하기 위해 무한대로 커질 수 있다. 그러나 스레드가 더 이상 필요하지 않은 경우 60초 이상 사용하지 않으면 폐기 된다.  \n일반적으로 애플리케이션에 수명이 짧은 작업이 많은 경우 사용한다.  \n\n내부적으로 `SynchronousQueue` 인스턴스가 사용된다.  \n삽입, 제거 작업이 항상 동시에 발생하므로 크기는 항상 0이다.  \n\n```java\nAtomicInteger counter = new AtomicInteger();\n\nExecutorService executor = Executors.newSingleThreadExecutor();\nexecutor.submit(() -> {\n    counter.set(1);\n});\nexecutor.submit(() -> {\n    counter.compareAndSet(1, 2);\n});\n```\n\n생성 후에는 immutable 하므로, `ThreadPoolExecutor` 로 캐스팅이 불가능하다.  \n\n## ScheduledThreadPoolExecutor\n\n`ThreadPoolExecutor` 를 상속받고, `ScheduledExecutorService` 를 implement 하며, 메서드가 추가된 인터페이스이다.    \n\n- `schedule` 메서드를 사용하면 지정된 딜레이 시간 후에 task 를 실행할 수 있다. \n- `scheduleAtFixedRate` 메서드는 첫 딜레이 시간 이후에 작업을 실행하고, 특정 기간동안 반복적으로 실행한다. `period` 매개변수는 작업들을 시작하는 사이 시간으로 측정되므로 실행률은 고정된다. \n- `scheduleWithFixedDelay` 메서드는 반복적으로 주어진 작업을 실행한다는  `scheduleAtFixedRate` 와 유사하지만, 딜레이 시간이 이전 작업이 끝나는 시간과 다음 작업이 시작된 사이 시간이라는 점에서 다르다. 주어진 작업의 길이만큼 실행률이 달라질 수 있다.  \n\n## ForkJoinPool\n\nJava 7에 도입된 fork, join 프레임워크의 핵심 부분이다. 이를 통해 재귀 알고리즘에서 여러 개의 작업을 생성하는 문제를 해결할 수 있다.   \n모든 작업이나 하위 작업을 실행하기 위해 자체 스레드가 필요하다. 즉, 간단한 `ThreadPoolExecutor` 를 사용하면 스레드가 빠르게 소진된다.  \n\nfork/join 프레임워크에서는 모든 작업이 여러 개의 하위 작업을 fork 하고 join 메서드를 사용하여 완료될 때까지 기다릴 수 있다.  \n\nfork/join 프레임워크의 장점은 각 작업이나 하위 작업에 대해 새 스레드를 만들지 않고, work-stealing 알고리즘을 수행한다는 것이다.  (이 부분은 자세하게 안 다루고 여기서 좀 더 자세히 볼 수 있다. https://www.baeldung.com/java-fork-join )\n\n```java\nstatic class TreeNode {\n\n    int value;\n\n    Set<TreeNode> children;\n\n    TreeNode(int value, TreeNode... children) {\n        this.value = value;\n        this.children = Sets.newHashSet(children);\n    }\n}\n\npublic static class CountingTask extends RecursiveTask<Integer> {\n\n    private final TreeNode node;\n\n    public CountingTask(TreeNode node) {\n        this.node = node;\n    }\n\n    @Override\n    protected Integer compute() {\n        return node.value + node.children.stream()\n          .map(childNode -> new CountingTask(childNode).fork())\n          .collect(Collectors.summingInt(ForkJoinTask::join));\n    }\n}\n```\n\n\n\n## 추가로 알아보면 좋은 키워드\n\n- 자바 소켓 프로그래밍\n- 스레드풀 전략\n- 적정 스레드 개수\n\n## 참고\n\n- https://velog.io/@sihyung92/how-does-springboot-handle-multiple-requests\n- https://velog.io/@mooh2jj/Tomcat-Thread-Pool-%EC%A0%95%EB%A6%AC\n- https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html -> 여기에서 tomcat 이라고 검색하면 tomcat 관련 설정이 나온다."},{"excerpt":"개요 학습 테스트를 하면서 개별 스레드를 일시 중지하면 if 절 조건이 true 가 되고 크기가 2가 된다는 게 무슨 말인지 이해가 안 돼서  에 있는 if 문에 중단점을 걸어봤다. 그런데 기존의 테스트를 70번 정도 실행했을 때는 성공하던 테스트가, 디버깅 포인트를 찍고 나니 갑자기 (거의) 100% 확률로 실패하기 시작했다. 즉, 유저가 2명이 추가되…","fields":{"slug":"/concurrency-test/"},"frontmatter":{"date":"2023년 09월 09일 08:09","title":"중단점이 있을 때 동시성 이슈가 더 잘 발생하는 이유는?","tags":null},"rawMarkdownBody":"\n## 개요\n\n```java\npackage thread.stage1;  \n  \nimport org.junit.jupiter.api.Test;  \n  \nimport static org.assertj.core.api.Assertions.assertThat;  \n  \n/**  \n * 스레드를 다룰 때 어떤 상황을 조심해야 할까?  \n * - 상태를 가진 한 객체를 여러 스레드에서 동시에 접근할 경우  \n * - static 변수를 가진 객체를 여러 스레드에서 동시에 접근할 경우  \n *  \n * 위 경우는 동기화(synchronization)를 적용시키거나 객체가 상태를 갖지 않도록 한다.  \n * 객체를 불변 객체로 만드는 방법도 있다.  \n * * 웹서버는 여러 사용자가 동시에 접속을 시도하기 때문에 동시성 이슈가 생길 수 있다.  \n * 어떤 사례가 있는지 아래 테스트 코드를 통해 알아보자.  \n */class ConcurrencyTest {  \n  \n    @Test  \n    void test() throws InterruptedException {  \n        final var userServlet = new UserServlet();  \n  \n        // 웹서버로 동시에 2명의 유저가 gugu라는 이름으로 가입을 시도했다.  \n        // UserServlet의 users에 이미 가입된 회원이 있으면 중복 가입할 수 없도록 코드를 작성했다.  \n        final var firstThread = new Thread(new HttpProcessor(new User(\"gugu\"), userServlet));  \n        final var secondThread = new Thread(new HttpProcessor(new User(\"gugu\"), userServlet));  \n  \n        // 스레드는 실행 순서가 정해져 있지 않다.  \n        // firstThread보다 늦게 시작한 secondThread가 먼저 실행될 수도 있다.  \n        firstThread.start();  \n        secondThread.start();  \n        secondThread.join(); // secondThread가 먼저 gugu로 가입했다.  \n        firstThread.join();  \n  \n        // 이미 gugu로 가입한 사용자가 있어서 UserServlet.join() 메서드의 if절 조건은 false가 되고 크기는 1이다.  \n        // 하지만 디버거로 개별 스레드를 일시 중지하면 if절 조건이 true가 되고 크기가 2가 된다. 왜 그럴까?  \n        assertThat(userServlet.getUsers()).hasSize(1);  \n    }  \n}\n```\n\n학습 테스트를 하면서 개별 스레드를 일시 중지하면 if 절 조건이 true 가 되고 크기가 2가 된다는 게 무슨 말인지 이해가 안 돼서 `UserServlet` 에 있는 if 문에 중단점을 걸어봤다.  \n\n```java\npackage thread.stage1;  \n  \nimport java.util.ArrayList;  \nimport java.util.List;  \n  \npublic class UserServlet {  \n  \n    private final List<User> users = new ArrayList<>();  \n  \n    public void service(final User user) {  \n        join(user);  \n    }  \n  \n    private void join(final User user) {  \n        if (!users.contains(user)) {    // 이 부분  \n            users.add(user);  \n        }  \n    }  \n    public int size() {  \n        return users.size();  \n    }  \n  \n    public List<User> getUsers() {  \n        return users;  \n    }  \n}\n```\n\n그런데 기존의 테스트를 70번 정도 실행했을 때는 성공하던 테스트가, 디버깅 포인트를 찍고 나니 갑자기 (거의) 100% 확률로 실패하기 시작했다.  \n\n즉, 유저가 2명이 추가되게 된 것이다. 왜 그럴까?\n\n## 이유\n\n중단점을 만나는 경우 실행중인 스레드는 일시 중지된다. 이는 스레드 스케줄링에 영향을 줄 수 있다.  \n\n1. 첫 번째 스레드가 중단점에 도달해서 일시 정지된다. \n2. 이 시점에서 두 번째 스레드는 여전히 실행 중일 수 있고, 일시 중지된 동안 자유롭게 실행된다. 즉, 유저가 추가되기 전 users 를 읽었기 때문에 비어있다고 판단했다. \n3. 이후 첫 번째 스레드를 다시 실행하면, 그 시점에는 이미 두 번째 스레드에 의해 user 가 리스트에 추가된 상태임에도 첫 번째 스레드가 조건을 만족하고 리스트에 똑같은 유저를 추가하게 된다.  \n\n이런 연유로 동시성 문제가 발생할 확률이 증가할 수 있다.  \n\n## 자바의 스레드 스케줄링\n\nJVM, 운영 체제에 의해 관리된다. JVM 은 대부분의 경우 호스트 OS 의 스레드 기능을 이용하여 자바 스레드를 구현한다. 즉, 실제 스레드 스케줄링은 대부분 OS 수준에서 이루어진다.  \n\n1. 우선순위  \n자바 스레드에는 우선순위가 있다. 높은 우선순위를 가진 \b스레드는 낮은 우선순위를 가진 스레드보다 스케줄링에서 우선적으로 고려될 가능성이 높다. 그러나 절대적으로 그런 것은 아니다.  \n\n2. 시간 할당\n일부 JVM 과 OS 에서는 시간 할당 방식을 사용하여 각 스레드에 동일한 CPU 시간을 할당하려고 한다. 이 방식은 각 스레드가 짧은 시간 동안 실행되고 다른 스레드로 전환되는 방식으로 작동한다. 이를 통해 여러 스레드가 거의 동시에 실행되는 것처럼 보이게 된다.  \n\n## 주의\n\n`@RepeatedTest` 를 할 때는 너무 큰 수로 실행하게 되면 컴퓨터의 실행 속도가 느려져서 오히려 Race Condition 을 만들기 어려울 수 있다. 따라서 적당히 큰 수로 설정하는 것이 중요하다.  \n"},{"excerpt":"생성자 mock  에서 다음과 같이 private 메서드로 세션을 생성한다. 이때 세션은 생성될 때 랜덤값을 생성하기 때문에 테스트하기 매우 곤란하다. 특히 UUID 가 겹칠 일은 지나가다 운석 맞을 확률이라고 한다 (ㅋㅋ) 이럴 때  를 사용한다. 이렇게 해주면 모든  이  로 1234 를 리턴하기 때문에 테스트할 수 있게 된다! try-with-res…","fields":{"slug":"/mockito/"},"frontmatter":{"date":"2023년 09월 09일 05:09","title":"Mockito","tags":["test","테스트","Java"]},"rawMarkdownBody":"\n## 생성자 mock\n\n`LoginController` 에서 다음과 같이 private 메서드로 세션을 생성한다.\n\n```java\nprivate Session createSession(final User user) {  \n    final Session session = new Session();  \n    SessionManager.getInstance().add(session);  \n    session.setAttribute(\"user\", user);  \n    return session;  \n}\n```\n\n이때 세션은 생성될 때 랜덤값을 생성하기 때문에 테스트하기 매우 곤란하다.  \n특히 UUID 가 겹칠 일은 지나가다 운석 맞을 확률이라고 한다 (ㅋㅋ)\n\n```java\npublic Session() {  \n    this.id = UUID.randomUUID().toString();  \n}\n```\n\n이럴 때 `mockConstruct` 를 사용한다.  \n이렇게 해주면 모든 `Session` 이 `getId` 로 1234 를 리턴하기 때문에 테스트할 수 있게 된다!\n\n```java\nfinal LoginController loginController = new LoginController();  \ntry (final MockedConstruction<Session> sessionMockedConstruction = mockConstruction(Session.class,  \n    (mock, context) -> {  \n        when(mock.getId()).thenReturn(\"1234\");  \n    })  \n) {  \n    final ResponseEntity responseEntity = loginController.service(httpRequest);  \n  \n    // then  \n    assertThat(responseEntity.getHeaders()  \n            .containsHeaderNameAndValue(HttpHeaderName.SET_COOKIE, \"JSESSIONID=1234\")).isTrue();   \n}\n```\n\ntry-with-resources 를 사용하여 테스트가 끝나면 닫아준다.  \n\n### 생성자가 호출된 횟수 알아내기\n\n```java\nclass MyClass {\n    void myMethod() {\n        // do something\n    }\n}\n\n@Test\npublic void testMyMethodInvocation() {\n    try (MockedConstruction<MyClass> mocked = mockConstruction(MyClass.class)) {\n        MyClass instance1 = new MyClass();\n        MyClass instance2 = new MyClass();\n\n        instance1.myMethod();\n        instance2.myMethod();\n        instance2.myMethod();\n\n        // 첫 번째 생성된 객체의 myMethod 호출 횟수 확인\n        verify(mocked.constructed().get(0), times(1)).myMethod();\n\n        // 두 번째 생성된 객체의 myMethod 호출 횟수 확인\n        verify(mocked.constructed().get(1), times(2)).myMethod();\n    }\n}\n```\n\n`.constructed().get(x)` 로 x번째로 생성된 객체의 메서드 호출 횟수를 확인할 수 있다.\n\n**⚠️ 주의 !! 리플렉션으로 동적으로 생성된 객체는 카운팅 되지 않으니 유의하자.**\n\n## mockStatic\n\nstatic 메서드를 모킹하고 싶을 때가 있다.  \n나는 싱글톤 패턴을 사용했는데, 싱글톤의 경우 mocking 을 해주기 곤란하다.  \n`SessionManager.getInstance` 에서 내가 mock 해둔 `SessionManager` 를 리턴해주도록 변경해야 했다.  \n\n이럴 때 mockStatic 을 사용한다.\n\n```java\nfinal SessionManager sessionManager = mock(SessionManager.class);  \ndoNothing().when(sessionManager).validateSession(any());  \n  \ntry (final MockedStatic<SessionManager> mockSessionManger = mockStatic(SessionManager.class)) {  \n    mockSessionManger.when(SessionManager::getInstance)  \n        .thenReturn(sessionManager);  \n  \n    // when  \n    final boolean result = loginInterceptor.preHandle(loginHttpRequest, basicResponse);  \n  \n    // then  \n    assertAll(  \n        () -> assertThat(result).isFalse(),  \n        () -> assertThat(basicResponse.getHeaders().getHeaderValue(HttpHeaderName.LOCATION))  \n            .contains(\"/index.html\")  \n    );  \n}\n```\n\n클래스의 static 메서드가 어떤 값을 리턴할 지 지정해줄 수 있다.  \ntry-with-resources 로 테스트가 끝나면 닫아준다.\n\n## `verify()`\n\n```java\nverify(requestDispatcher, only()).forward(any(), any());\n```\n\n**모킹된 객체**에서 메서드가 몇 번 불렸는지 확인할 수 있다. \n(spy 도 가능하다.)\n\n`only()` 를 사용하면 단 한 번 호출되었다는 것을 확인할 수 있다.  \n"},{"excerpt":"","fields":{"slug":"/2023-09-09/"},"frontmatter":{"date":"2023년 09월 09일 05:09","title":"2023년 09월 09일","tags":null},"rawMarkdownBody":"\n"},{"excerpt":"LOG 감정 회고를 했다. 기본적으로 이번에는 회의와 관련된 이야기가 많이 나왔는데, 사실 기존에도 우리 회의 시간이 긴 편이었어서 나올 법한 주제라고 생각했다. 개인적으로 나도 컨디션이 괜찮은 날은 상관 없는데, 그렇지 않은 날에는 연속된 회의가 있을 때 힘들 때가 많았다. 감정 회고를 하면서 회의 시간을 구체화하고, 회의 전에 회의를 위한 회의 (일명…","fields":{"slug":"/2023-09-08/"},"frontmatter":{"date":"2023년 09월 08일 11:09","title":"2023년 09월 08일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 감정 회고를 했다. 기본적으로 이번에는 회의와 관련된 이야기가 많이 나왔는데, 사실 기존에도 우리 회의 시간이 긴 편이었어서 나올 법한 주제라고 생각했다. 개인적으로 나도 컨디션이 괜찮은 날은 상관 없는데, 그렇지 않은 날에는 연속된 회의가 있을 때 힘들 때가 많았다. 감정 회고를 하면서 회의 시간을 구체화하고, 회의 전에 회의를 위한 회의 (일명 회위회) 를 하면서 회의 목표를 정하고 회의하자는 의견에 모두 동의해서 앞으로는 그렇게 진행할 예정이다. 확실히 회의 목적과 결과, 시간을 리마인드하니까 시간도 절약되고, 쓸데 없는 말을 덜 하게 돼서 좋았다. 역시 우리 팀 피드백이 빨리 빨리 반영돼서 너무 좋다 짱이야 👍\n\n## 배운 것\n\n- [[level4-architecture|레벨4 강의]] 를 듣고 정리했다.\n\n## 느낀 것\n\n- 상대방이 오해하지 않게 내가 하고 싶은 말을 하는 것은 쉽지 않다. 나는 특히 (줄이려고 노력 중이지만) 불쑥 이상한 말이 나올 때도 있고, 아직 학습이 덜 돼서 그런지 상대방이 잠재적으로 상처받을 수도 있는 말을 할 때도 많다. 그렇게 말하면서 다른 사람들의 기분을 신경쓰지 않으면 편하겠지만 아무래도 난 그런 사람이 아니다. 최대한 다른 사람들을 내 기준에서는 신경 쓴다고 신경을 쓰고는 있지만, 사실 많이 어렵다. 노력 중이다. 가끔 그런 말을 하게 될 때 자책을 많이 하는 편이다. 자존감과 사회성을 등가 교환하는 느낌이다 ㅋㅋ 말을 예쁘게 하는 건 어려운 거구나. 그만큼 앞으로 노력이 많이 필요할 것 같다는 걸 느끼게 된 날이었다.\n- 친한 사람이 떠나는 건 언제나 슬프고 아쉬운 것 같다. 체인저 안녕 🥺"},{"excerpt":"","fields":{"slug":"/replication/"},"frontmatter":{"date":"2023년 09월 08일 02:09","title":"복제 (Replication, 레플리케이션)","tags":["미완성","database"]},"rawMarkdownBody":"\n"},{"excerpt":"무엇을 고려해야 하나 규모 확장성: 트래픽의 규모에 맞춰 확장할 수 있는지에 대한 관점 성능: 서비스의 성능이 고객의 기대 수준에 부합하는지에 대한 관점 가용성: 서비스가 의도한 목적을 달성하기 위해 정상적으로 작동하는 시간 측면의 관점 신뢰성: 정해진 성능 수준을 만족하면서 정확하게 동작하는지에 대한 관점 비용 가용성 고가용성 HA, High Avail…","fields":{"slug":"/level4-architecture/"},"frontmatter":{"date":"2023년 09월 08일 01:09","title":"Level 4 아키텍처 개선","tags":["레벨4","우테코"]},"rawMarkdownBody":"\n## 무엇을 고려해야 하나\n\n- 규모 확장성: 트래픽의 규모에 맞춰 확장할 수 있는지에 대한 관점\n- 성능: 서비스의 성능이 고객의 기대 수준에 부합하는지에 대한 관점\n- 가용성: 서비스가 의도한 목적을 달성하기 위해 정상적으로 작동하는 시간 측면의 관점\n- 신뢰성: 정해진 성능 수준을 만족하면서 정확하게 동작하는지에 대한 관점\n- 비용\n\n## 가용성\n\n### 고가용성\n\n- HA, High Availability : 정상적으로 작동하는 시간의 비율을 높이는 것\n- 9's availability: 9가 몇 개 들어가는지에 따라 다운되는 시간이 정해진다. (신기 ㄷㄷ)\n\n### SPOF\n\n단일 장애 지점. 이 지점에 문제가 생기면 전체 시스템이 문제가 생긴다.  \n\n## 사용할 수 있는 도구\n\n### 이중화 (다중화)\n\n시스템 일부에 어떤 장애가 발생했을 경우에 대비해서, 장애발생 다음에도 시스템 전체의 기능을 계속 유지하도록 예비 장치를 평상시부터 백업으로서 배치해 운용하는 일\n\n### 로드밸런서\n\n- 부하의 균형을 유지해주는 역할\n- 클라이언트로부터 들어오는 요청을 N개의 목적지로 분산시켜준다.\n- 추후 학습해보면 좋을 키워드\n\t- L4/L7 스위치\n\t- HAProxy\n\t- AWS ELB\n\n## MySQL 을 사용할 때 왜 Connection Pool 을 사용할까?\n\n- 커넥션 생성 비용이 커서요\n\n## WAS\n\n- 언제 문제가 있을 수 있을까?\n\t- OOM\n\t- 디스크 용량 초과\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- LB, 스위치를 사용한 이중화\n- 어떤 문제가 생길 수 있을까? 또는 무엇을 개발할 때 고려해야 할까?\n\t- 동시성 이슈\n\t\t- 스레드에 대한 동시성 고려에서 WAS 간의 동시성 고려로 확장된다.\n\t\t- 이런 문제가 발생할 수 있다. https://stackoverflow.com/questions/35534906/java-hashmap-getobject-infinite-loop\n\t\t- 분산락 (vs synchronized)\n\t\t\t- 서버 사이의 동시성에서는 synchronized 를 사용하는 것보다 서버 사이의 락을 가지도록 해야 한다.\n\t- 세션 정보를 어떻게 관리할 것인가?\n\t- 데이터 저장소 커넥션 제한\n\t- 모니터링 로그 확인이 어려워진다.\n\t- 베포는 어떻게 할 것인가?\n\t\t- 롤링 배포를 한다면,\n\t\t\t- 배포 중간에 장애 상황임을 알면 어떻게 하나?\n\t\t\t- 서버 대수가 많아지면 어떻게 할 것인가?\n\t- 프론트 리소스도 스프링에서 서빙한다면 다른 리소스가 제공될 수 있는 상황은 어떻게 할 것인가?\n\n## DBMS\n\n- 언제 문제가 될 수 있을까?\n\t- 시스템 부하가 커질 때\n\t- 디스크 용량 초과\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- 이중화\n\t- replication\n\t- 백업\n- 어떤 문제가 생길 수 있을까? 또는 무엇을 개발할 때 고려해야 할까?\n\t- 이중화 \n\t\t- 데이터 싱크는 어떻게 맞출까?\n\t- replication\n\t\t- writer DB 가 다운되면 어떻게 reader DB 를 writer DB 로 사용할 수 있을까?\n\t\t- replication 은 어떻게 이뤄지나?\n\t\t\t- sync vs async\n\t\t\t\t- \n\t\t\t\t- 비동기로 수행하면 쓰기 전에 읽기가 발생하면 읽을 수 없는 상태가 된다.\n\t\t\t- replication lag\n\t\t- failover 할 때 WAS 의 커넥션 풀에 있느 커넥션은 어떻게 될까\n\t- backup\n\t\t- backup 은 DB 서버에 부하가 없을까?\n\t\t- 계속해서 데이터가 변경되면 언제 데이터를 백업해야 할까?\n\n이중화 하면서 replication 하는 방법을 많이 사용한다고 한다.  \n\n이중화 하면 읽기도 두 번 보내야 하는가? -> MySQL 의 경우는 한 번만 보내면 된다 (왜?)\n## Jenkins\n\n- 언제 문제가 될 수 있을까?\n\t- 자원이 부족한 순간들\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- master-agent 설정\n\t- master 이중화\n\t- 백업\n- 어떤 문제가 생길 수 있을까? 또는 무엇을 개발할 때 고려해야 할까?\n\t- master-agent 설정\n\t\t- master 가 다운되면 어떻게 하나?\n\t- master 이중화\n\t\t- 두 대의 jenkins 가 동일하게 관리될 수 있도록 어떻게 할 수 있을까?\n\n## AWS AZ\n\n- 언제 문제가 될 수 있을까?\n\t- 지진, 태풍 등으로 인한 데이터 센터 전체 이슈\n- 어떻게 해결할 수 있을까?\n\t- multi AZ\n- 어떤 문제가 생길 수 있을까? 또는 개발할 때 무엇을 고려해야 할까?\n\t- network latency\n\t- 비용\n\n## 스케일 업 vs 스케일 아웃\n\n### 스케일 인\n\n노드에 자원을 추가하여 시스템 처리량을 늘리는 방법. 컴퓨팅 자원을 좋게 하는 것\n\naka. 수직 스케일링\n\n### 스케일 아웃\n\n시스템에 노드를 추가하여 시스템의 처리량을 늘리는 방법. \n\naka. 수평 스케일링\n\n### 사용할 수 있는 도구\n\n구체적인 구현이나 사용법은 논외. 요구사항에 맞춰 동작하는 프로그램이라고 가정\n\n#### 서버 캐시\n\n- Map 과 유사하게 key-value 형태의 자료 구조를 가지고 있음\n- 메모리에 모든 데이터를 올려서 관리하며, 단일 key 조회에 대해 매우 빠른 성능을 보장한다.\n- WAS 에 올려서 사용할 수도 있고 별도의 캐시용 서버를 구축할 수도 있다.\n\n#### 검색엔진\n\n- 전문검색, 여러 조건의 검색을 포함하여 대부분의 검색에서 DBMS 보다 빠른 성능을 보장한다.\n- 집계, 통계 쿼리도 DBMS 보다 빠른 성능을 보장한다.\n\n#### 메시지 큐\n\n- 큐 형태의 자료 구조\n- 하나의 시스템에서 데이터 또는 메시지를 저장함녀 큐 형태의 자료 구조에 저장하며, 다른 시스템에서 그 값을 가져가서 처리할 수 있다.\n\n#### 프로세스 스케줄링\n\n- 원하는 시점에 프로그램을 실행하는 것\n\t- 인프라 아키텍처 다이어그램에는 특정한 역할을 하는 프로그램으로 표시한다.\n- 젠킨스 또는 크론탭, 스프링의 `@Scheduled` 어노테이션을 이용해서 실행하는 것으로 가정\n\n## 고민할 것\n\n- 과연 서비스가 성공할까? 성공하고 개선하면 안 되나?\n- 장애 발생으로 인한 손실과 투자한 비용을 고민해봤는가?\n- 모든 장애를 완벽하게 방어할 수 있나?\n\t- 예상할 수 있는 문제와 알 수 없는 문제 (방어하기 힘듦)\n\t- 장애가 발생했을 때 탓하지 않는 문화\n- 또 무엇을 할 수 있을까?\n\t- 재발 방지\n\t- 모니터링 고도화 및 빠른 복구\n\t- 모의 장애 훈련\n\n## 역정규화\n\n데이터의 개수가 많아지면 통계 쿼리를 작성하기 어렵다.  \n통계 테이블을 만들면 '읽기' 성능 측면에서 개선 가능하다.  \n대신 글을 작성할 때마다 count 를 증가시키는 추가 작업이 발생한다.  \n\n## 파티셔닝\n\n대용량의 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용할 수 있는 기능\n\n사용할 때는 하나의 테이블인 것처럼 사용하지만, 내부적으로는 N개의 테이블로 나눠서 관리  \n- 인덱스도 나눠서 관리한다.\n- 데이터가 적은 테이블의 변경이 더 쉽고, 조회가 빠르다.\n- 나눠진 테이블에는 중복으로 데이터를 넣지 않는다.\n\nMySQL 자체로 지원하는 기능이다.\n\n## 샤딩\n\n대용량의 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용하는 기능  \nN대의 DBMS에 분산해서 데이터를 관리한다.  \n\n## 무엇을 캐시할 것인가?\n\n- 데이터가 얼마나 자주 사용되는가?\n- 데이터가 얼마나 자주 갱신되는가?\n- 전체 데이터를 캐시할 것인가? 일부 데이터를 캐시할 것인가?\n\t- 지하철 노선 vs 쇼핑몰 상품\n- 캐시의 키는 무엇인가?\n- 데이터 구성을 위해 메타데이터를 캐시할까? 화면에 그려지는 데이터를 캐시할까?\n\n## 캐시를 사용할 때 문제될 수 있는 상황은?\n\n- 메모리가 무한한가?\n\t- cache eviction algorithm\n\t- TTL\n- 캐시의 데이터가 최신 데이터라는 것을 어떻게 보장할까?\n"},{"excerpt":"웹사이트 분석은 왜 필요한가? 사용자 지표를 추적하고 필요한 데이터를 수집하여 개선할 부분을 찾기 위해 사용한다. Google Analytics 무료이다. 사용자가 어디에서 유입되는지 알 수 있다. 어떤 검색어로 유입이 되었는지, 유료 광고를 클릭하는지 등 유입과 관련된 정보를 알려준다. 사용자가 서비스에 접속했을 때 세션을 추적하기 때문에, 어떤 페이지…","fields":{"slug":"/shook-site-analysis/"},"frontmatter":{"date":"2023년 09월 07일 13:09","title":"웹사이트 분석 툴 조사","tags":["shook"]},"rawMarkdownBody":"\n## 웹사이트 분석은 왜 필요한가?\n\n사용자 지표를 추적하고 필요한 데이터를 수집하여 개선할 부분을 찾기 위해 사용한다.  \n\n## Google Analytics\n\n무료이다.  \n\n사용자가 어디에서 유입되는지 알 수 있다. 어떤 검색어로 유입이 되었는지, 유료 광고를 클릭하는지 등 유입과 관련된 정보를 알려준다.  \n\n사용자가 서비스에 접속했을 때 세션을 추적하기 때문에, 어떤 페이지를 어떤 순서로 이동했는지, 어떤 위치에서 얼마나 오래 머물렀는지 알 수 있다.  \n\n그러나 개별 사용자가 해당 페이지에서 어떤 것을 하는지는 정확하게 알 수 없다.  \n\n### 장점\n\n1. 사용하기 쉽다. \n\n인증 코드를 넣기만 하면 바로 사용할 수 있다. \n\n### 단점\n\n1. 사용자 커스터마이징이 어렵다. \n2. 느리다. 데이터가 보고서로 필터링되는데까지 24시간의 지연 시간이 존재한다.\n3. 앱이나 SaaS 제품에는 적합하지 않다. 보통 웹사이트와 함께 작동하도록 설계되었다. (그러나 우리 서비스는 웹 서비스이기 때문에 단점은 아니다.)\n4. QA 프로세스만 제한적으로 제공하고 데이터의 품질관리 기능을 따로 제공하지 않는다. \n\n## Amplify\n\n프로덕트 관점에서 사용자 행동을 이해할 수 있게 제공해주는 이벤트 기반 분석 플랫폼이다. 사용자가 여러 페이지를 어떻게 이동하는지 추적하는 대신, '이벤트' 를 추적한다.  \n동영상을 재생하거나, 스크롤하는 등 행동을 추적하는 것이다.  \n\n월 1000만 이벤트까지 무료로 사용할 수 있다. \n\n### 장점\n\n1. schema 기능으로 수집한 이벤트, 이벤트 속성 및 속성 값을 잘 분류하고 설명하고 있다. 누구나 이벤트에 대한 분류 체계를 쉽게 이해할 수 있게 돕는다. 또한 의도치 않은 이벤트의 수집이나, 잘못된 형식의 데이터를 표시하거나 차단하여 수집된 데이터들에 대한 QA 프로세스를 자동화해준다.  \n2. 커스텀 뷰를 만들어 팀원들과 공유하는 것이 용이하다. 모든 팀원들이 같이 데이터를 편집할 수 있다. (이 부분은 우리 팀에서는 이점일지 의문)\n3. 쿼리 속도가 빠르다.\n\n### 단점\n\n1. 주로 모바일 분석을 위해 설계되어 웹 사용에 대한 세부 정보를 제공하지 않을 수 있다.\n2. 대부분의 기능이 pricing plan 에 포함되어 있다.\n\n## MixPanel\n\n> 제품의 사용자 경험을 개선하기 위해 데이터 기반 의사 결정에 의존하는 기업에 이상적이다. \n\n1달에 2.5만개의 데이터 포인트까지 무료로 사용 가능하다. Amplify 보다는 비교적 저렴하다. \n\n### 장점\n\n1. 데이터 시각화 기능이 좋다.\n2. A/B 테스트 기능을 지원한다.\n3. 대시보드를 자유자재로 만들 수 있다.\n4. 실시간으로 데이터를 수집한다. 유저 한 명, 한 명씩 어떤 행동을 했는지 구체적으로 확인할 수 있다. 유저들을 묶어 그룹 (코호트) 를 쉽게 만들 수 있다.\n5. 유저가 전후로 어떤 행동을 했는지 리포트 내에서 직관적인 확인이 가능하다. 또한 유저가 가장 많이 하는 행동을 기준으로 이벤트를 나열한 Top Path 방식으로 리포트를 원클릭으로 편하게 분석할 수 있다.\n\n### 단점\n\n1. Amplitude 에 비해 Mixpanel 의 인터페이스가 복잡하다는 사람들도 존재한다.\n\n### 서버에서 설정할 것\n\n- https://docs.mixpanel.com/docs/tracking/reference/java\n- https://medium.com/@marianfurdui/how-to-integrate-mixpanel-into-a-spring-boot-application-34e97c5ff039\n\n### 서버 사이드 vs 클라이언트 사이드\n\n> GPT 의 대답\n\n서버 사이드와 클라이언트 사이드 추적 간에는 각각의 장점과 단점이 있습니다. 어떤 측면에서 추적을 결정할지는 여러 요인을 고려해야 합니다:\n\n1. 데이터의 정확성:\n    \n    - 서버 사이드: 서버에서 이벤트를 전송하면 클라이언트의 문제점(브라우저 문제, 네트워크 문제 등)으로 인한 데이터 손실의 위험이 덜합니다.\n    - 클라이언트 사이드: 사용자의 실제 인터랙션(예: 페이지 뷰, 버튼 클릭)을 캡처하기에 가장 적합합니다. 하지만 AdBlockers나 네트워크 문제로 인해 이벤트가 전송되지 않을 수 있습니다.\n2. 보안:\n    \n    - 서버 사이드 : 민감한 데이터나 내부 시스템에 대한 정보를 안전하게 보호할 수 있습니다. 또한, 서버에서 검증된 데이터만 외부로 전송되기 때문에 데이터 조작의 위험이 줄어듭니다.\n    - 클라이언트 사이드: JavaScript 코드는 브라우저에서 볼 수 있기 때문에 보안상 민감한 정보는 노출되어서는 안 됩니다.\n3. 복잡성:\n    \n    - 서버 사이드: 서버 애플리케이션의 코드를 변경해야 하며, 적절한 이벤트를 포착하고 전송하는 로직을 구현해야 합니다.\n    - 클라이언트 사이드: 특정 UI 요소나 사용자 인터랙션에 대한 이벤트를 쉽게 연결할 수 있습니다.\n4. 대상 이벤트의 종류:\n    \n    - 서버 사이드 주문 완료, 결제 성공, 계정 생성 등의 서버에서만 알 수 있는 이벤트나 결과를 추적하기에 적합합니다.\n    - 클라이언트 사이드: 사용자의 페이지뷰, 마우스 클릭, 스크롤 행동 등의 클라이언트에서 발생하는 인터랙션을 추적하기에 적합합니다.\n\n결론적으로, 필요한 추적 데이터와 그 목적, 그리고 각 방식의 장단점을 종합적으로 고려하여 결정해야 합니다. 대부분의 경우, 클라이언트 사이드와 서버 사이드 추적을 동시에 사용하여 보다 완전한 사용자 분석을 수행하는 것이 바람직합니다.\n\n둘 다 하는 게 바람직하다고 한다...ㅋㅋㅋ\n\n## 참고\n\n- https://maily.so/colli/posts/fb4b16a6\n- https://brunch.co.kr/@brian-jeon/14"},{"excerpt":"개요 우리 팀의 현재  는 문제가 많다. 정합성 문제와 함께 중복 데이터가 사용자에게 전달될 가능성도 존재한다. 현재는 어떻게 해결할 수 있을지 고민하는 시간을 갖고 있다. 너무 느린 API 응답 Locust 로 API 응답 측정 DB 가 느린걸까, 애플리케이션 처리 속도가 느린 걸까 어떻게 측정할 수 있을까 그래서 어떤 게 느릴까 현재 우리의 좋아요 정…","fields":{"slug":"/shook-like-concurrency-issue/"},"frontmatter":{"date":"2023년 09월 07일 06:09","title":"S-HOOK 동시성 문제 해결","tags":["shook","레벨4","우테코","개발","spring","미완성"]},"rawMarkdownBody":"\n## 개요\n\n우리 팀의 현재 `killing_part_like` 는 문제가 많다.  \n정합성 문제와 함께 중복 데이터가 사용자에게 전달될 가능성도 존재한다.  \n\n현재는 어떻게 해결할 수 있을지 고민하는 시간을 갖고 있다.\n\n## 너무 느린 API 응답\n\n### Locust 로 API 응답 측정\n\n## DB 가 느린걸까, 애플리케이션 처리 속도가 느린 걸까\n\n### 어떻게 측정할 수 있을까\n\n### 그래서 어떤 게 느릴까\n\n## 현재 우리의 좋아요 정책\n\n- 메인에서 좋아요 순으로 정렬된 데이터를 가져온다. 현재는 서버에서 특정 기간(1시간, 30분 등)으로 캐싱하지 않고 매번 실시간으로 정렬해서 조회한다.\n- 유저가 각 노래의 킬링파트에 좋아요를 누르면 메인의 좋아요 순위가 변경될 수 있다.\n- 각 노래의 킬링파트에 유저들의 좋아요한 개수, 내가 좋아요를 눌렀는지 여부가 표시된다.\n- 어떤 노래를 들어가서 스와이프를 했을 때, 앞 뒤로 좋아요 순으로 정렬된 데이터를 각각 10개씩 받아온다.\n\n### 발생할 수 있는 문제점\n\n1. **여러 유저가 어떤 노래의 킬링파트에 대해 동시에 좋아요를 눌렀을 때, 정합성 문제가 발생할 수 있다.** => 매우 시급\n\n2. 정합성 이슈를 고려하지 않는다고 했을 때 -> 유저가 좋아요를 눌렀을 때, DB의 킬링파트 좋아요가 추가되기 때문에 기존에 사용자가 메인에서 보았던 좋아요 순 노래 리스트가 변경될 수 있다. 즉, 기존에 들었던 노래가 스와이프 했을 때 다시 등장할 수도 있다.  => 꽤나 시급\n\n3. 좋아요 수를 실시간으로 반영하기 때문에 응답을 캐싱하는 것이 불가능하다.\n\n## 해결 방법\n\n### 기술적 관점\n\n- 좋아요 정합성 이슈의 해결 방법은 [[shook-like-issue]] 에서 확인 가능합니다.\n\n#### DB Replication 을 적용한다\n\n하나는 읽기 DB, 하나는 쓰기 DB 를 둔다.  \n\n- 장점\n\t- 좋아요 읽기 작업 성능을 높일 수 있다.\n- 단점\n\t- 일관성 있는 데이터를 얻기 어려울 수 있다.\n\n### 정책적 관점\n\n좋아요 정합성 문제가 해결되었다고 가정하고 정책을 제안한다.  \n\n#### 메인 리스트를 전날 좋아요 순으로 정렬한다\n\n매 요청마다 정렬하지 않고, 전날까지 집계된 좋아요 순으로 정렬한다.  \nDB 는 그대로 실시간 업데이트 하되, 전날까지 집계된 좋아요 순 정렬을 캐싱해서 서버 인메모리에 저장한다. \n\nㅌ\n- 장점\n\t- 데이터 자체는 실시간으로 처리된다. DB와의 정합성 처리는 신경쓰지 않아도 된다. \n- 단점\n\t- 이전에 들었던 노래가 나오는 문제는 해결할 수 없다.\n\t- 좋아요 순 정렬된 리스트의 크기는 고정되어야 한다.\n\n#### 해당 사용자의 좋아요 순 리스트를 고정한다\n\n사용자가 좋아요 순 리스트를 클릭해서 노래 듣기를 선택하는 순간, 해당 시점의 좋아요 리스트를 사용자 id 로 인메모리에 캐싱한다.   \n그 뒤로 요청을 받을 때마다 인메모리에 캐싱된 값을 가져와서 응답한다.  \n\n메인 화면에서의 킬링파트 좋아요 많은 순 차트는 옆에 (마지막 새로고침 N분 전) 이라고 표시되도록 한다.  \n만약 새로고침을 누르거나, 다시 메인에서 요청을 보내는 경우 캐싱된 값을 업데이트 한다.\n\n- 장점\n\t- 응답 결과를 캐싱하기 때문에 성능이 매우 빠르게 향상될 것으로 예상한다.\n\t- 이전에 들었던 노래가 나오는 문제가 해결된다.\n- 단점\n\t- 사용자가 좋아요를 누른 경우, 좋아요를 누른 정보도 캐싱되어야 하는데 이 처리가 좀 빡셀 거 같다.\n\t- 좋아요 순 리스트 개수가 고정되어야 한다.\n\t- 서버가 stateful 하다.\n\t- 사용자가 많아질수록 캐싱해야 하는 양이 늘어난다.\n\n### 좋아요 처리 버퍼링\n\n차트의 순위를 결정하는 데이터는 실시간으로 수집하지만, 순위 재정렬은 일정 시간 간격으로 이루어진다.  \n\n1. 좋아요 데이터는 실시간으로 수집한다. 메모리 같은 일시적인 저장 공간에 저장된다.  \n\t1. 킬링파트의 좋아요 수는 업데이트 하지 않는다.\n\t2. 유저의 좋아요는 `killing_part_like` 테이블에 저장한다.\n2. 일정 시간마다 버퍼에 저장된 데이터를 한 번에 업데이트한다.\n\t1. 킬링파트의 좋아요 수를 한 번에 DB로 업데이트한다.\n3. DB 가 업데이트 되었기 때문에 \n\n킬링파트에 좋아요 수를 표시하되, TOP 3 옆에 마지막 업데이트 시간 표시하기  \n\n### 해결 방법 고려하기\n\n[[shook-like-issue]]"},{"excerpt":"","fields":{"slug":"/shook-deadlock-test/"},"frontmatter":{"date":"2023년 09월 07일 04:09","title":"S-HOOK 좋아요 Deadlock 확인","tags":null},"rawMarkdownBody":"\n"},{"excerpt":"개요 Locust 는 성능 테스트를 위한 도구다. 자세한 내용은 shook-load-test 확인하기. 다른 블로그에서 Locust 가 잘 사용되지 않는 이유가 러닝 커브라고 해서 한 번 써봤다. 나는 기존에 파이썬을 사용한 적이 있기 때문에 추가로 파이썬에 대해 배울 부분은 없었다. Locust 설치 테스트 스크립트 작성 우리 서비스의 좋아요 순으로 정…","fields":{"slug":"/locust/"},"frontmatter":{"date":"2023년 09월 07일 03:09","title":"Locust 사용기","tags":["테스트","spring","shook","개발"]},"rawMarkdownBody":"\n## 개요\n\nLocust 는 성능 테스트를 위한 도구다. 자세한 내용은 [[shook-load-test]] 확인하기.\n\n다른 블로그에서 Locust 가 잘 사용되지 않는 이유가 러닝 커브라고 해서 한 번 써봤다.  \n나는 기존에 파이썬을 사용한 적이 있기 때문에 추가로 파이썬에 대해 배울 부분은 없었다.   \n\n## Locust 설치\n\n```shell\npip install locust\n```\n\n## 테스트 스크립트 작성\n\n```python\nimport json  \nfrom locust import HttpUser, task, between  \n  \n  \nclass Sample(HttpUser):  \n    wait_time = between(1, 2.5)  \n  \n    def on_start(self):  \n        print(\"start\")  \n  \n    def on_stop(self):  \n        print(\"stop\")  \n  \n    @task  \n    def get(self):  \n        self.client.get(\"/api/songs/high-liked\")\n```\n\n우리 서비스의 좋아요 순으로 정렬해서 조회하는 API 를 반복 호출하도록 했다.  \n스크립트를 실행하면 `localhost:8089` 로 접속해서 유저 수, 유저 생성 latency, 테스트할 서버 URL 을 입력할 수 있다.   \n\n## 테스트 실행하기\n\n> RPS 란 서버가 지원하는 초당 요청 수를 말한다. (Request Per Second)\n\n아래와 같이 입력하면 `localhost:8089` 로 접속이 가능하다.\n\n```shell\nlocust -f 스크립트파일이름\n```\n\n### 전체 조회 API\n\n![[locust-test-chart.png]]\n\n테스트를 수행하면 다음과 같은 화면이 보인다.  \n\n이상하게 평균적으로 잘 가져오다가 한 번씩 저렇게 지표가 튀는 부분이 있었는데, 이 부분은 좀 더 알아봐야겠다. \n\n단순한 GET 요청이라 그런지 실패율은 0%.. 다행이다.\n\n### 단순 swipe API 테스트\n\n![[locust-swipe-api-test-chart.png]]\n\n스와이프 요청을 위한 API 를 테스트 해봤다.  \n다행히 생각했던 것 만큼 오래 걸리지 않았다. 왠지 모르겠는데 자꾸 95th percentile 이 감소하는 데 왜일까 ㅋㅋ\n\n### 랜덤한 API 주소로 요청 보내기\n\n테스트 코드는 다음과 같다.  \n\n```python\nimport json  \nfrom locust import HttpUser, task, between  \nimport random  \n  \n  \nclass Sample(HttpUser):  \n    wait_time = between(1, 2.5)  \n  \n    def on_start(self):  \n        print(\"start\")  \n  \n    def on_stop(self):  \n        print(\"stop\")  \n  \n    @task  \n    def get(self):  \n        song_number = random.randint(1, 20)  \n        self.client.get(\"/api/songs/\" + str(song_number))\n```\n\n\n![[locust-random-swipe-api-test.png]]\n\n이전과는 다르게 유저 수가 800 명이 되었을 때 굉장히 편차가 큰 응답 시간을 보여줬다.  \nRPS 가 400 이상일 때부터 응답 시간이 안정적이지 않다는 것을 의미한다.  \n\n이 부분은 확실하게 최적화가 필요하다.  \n\n### 데이터 10000개로 증가 후 테스트\n\n![[locust-many-datas-test.png]]\n\n동시 접속 유저 100명까지 설정, 초마다 1명씩 증가하도록 설정\n\n데이터가 166배 증가할 때 시간은 5배 증가한다.  \n이게 어떤 의미를 갖는 거고 무슨 수치인지는 잘 모르겠다.  \n\n## 후기\n\n정말 간단한 코드와 단순한 실행으로 짧은 시간 안에 테스트를 수행할 수 있었다. (코드 치는 데 1분 정도 걸린 듯 ㄷㄷ)\n\n요청 통계, 실패, 예외를 CSV 파일로 다운로드할 수 있고, Report 도 다운로드할 수 있다는 점은 큰 장점이다. Report 가 기록으로 남을 수 있으니까 관리하기 더 쉬울 것이다.  \n\n스크립트 기반이라 다른 데스크탑에서도 실행할 수 있다는 것도 좋다.  \n스크립트만 전달하면 팀원들도 쉽게 실행할 수 있으니, 많은 테스트를 수행하기 용이하다.\n\n다만 제공하는 데이터가 조금 제한적이라는 느낌을 받았다.  \n좀 더 자세한 데이터를 원한다면 다른 툴을 사용하는 것이 좋을 듯하다."},{"excerpt":",  등 다양한 툴이 존재한다. 이번 프로젝트에서 사용할 성능 테스트 툴에 대해서 알아보자. 성능 테스트란? 특정 상황에서 시스템이 어느 수준의 퍼포먼스를 내는지 측정하기 위한 테스트 방식이다. 가상의 유저를 시뮬레이션하여 실제와 비슷한 환경을 만들고, 서버에 일정 규모의 부하를 주는 방식으로 테스트한다. 일반적으로 애플리케이션의 성능을 측정하고, 최적화…","fields":{"slug":"/shook-load-test/"},"frontmatter":{"date":"2023년 09월 07일 02:09","title":"성능 테스트 툴 비교","tags":["shook","spring","개발","테스트"]},"rawMarkdownBody":"\n`nGrinder` , `JMeter` 등 다양한 툴이 존재한다.   \n이번 프로젝트에서 사용할 성능 테스트 툴에 대해서 알아보자.  \n\n## 성능 테스트란?\n\n특정 상황에서 시스템이 어느 수준의 퍼포먼스를 내는지 측정하기 위한 테스트 방식이다.  \n가상의 유저를 시뮬레이션하여 실제와 비슷한 환경을 만들고, 서버에 일정 규모의 부하를 주는 방식으로 테스트한다.  \n\n일반적으로 애플리케이션의 성능을 측정하고, 최적화하기 위해 사용한다.  \n부하 테스트, 스트레스 테스트를 포함하는 포괄적인 의미이다.  \n\n## 부하 테스트란?\n\n동시 요청이나 시스템의 성능을 측정하고자 할 때 사용하는 테스트이다.  \n부하 테스트는 시스템이나 애플리케이션의 최대 용량을 결정하거나, 결과를 예측하거나, 다른 성능 관련한 정보를 얻기 위해 특정 부하와 요청을 시스템에 가하는 테스트이다.  \n\n스프링 웹 애플리케이션의 경우, 동시 사용자나 초당 요청 수 등 다양한 요청 시나리오에 대한 애플리케이션의 응답 시간, 처리 능력, 에러 발생 빈도 등을 측정할 수 있다.\n\n## JMeter\n\nApache 에서 만든 java 기반 오픈 소스로, 오래된 테스트 툴 중 하나이기 때문에 안정적이다. 웹 서비스, 데이터베이스, FTP, 메일 서버 등 다양한 프로토콜에 대한 테스팅을 지원한다.\n\n서버, 서버 그룹, 네트워크 또는 개체에 대한 과부하를 시뮬레이션하여 강도를 테스트하거나 다양한 부하 유형에서 전체 성능을 분석하는 데 사용할 수 있다.  \n\n`BeanShell`, `Jython`, `Groovy` 등을 이용하여 스크립트를 작성할 수 있다.  \n\nGUI 를 제공하고, 테스트 플랜을 직접 구성할 수 있다. \n \n### 장점\n\n- GUI, 이메일, DB, SSL 등 지원하는 기능과 플러그인이 많다.\n- 다양한 프로토콜을 지원한다.\n- 큰 사용자 커뮤니티, 많은 플러그인으로 확장성이 뛰어나다.\n- 여러 기계에서 테스트를 동시에 실행하여 대규모 부하 테스트를 실행할 수 있다. 단, 각 에이전트를 수동으로 설정해야 한다.\n\n### 단점\n\n- 모든 기능이 다 필요한 지 의문\n- 모니터링이 불편하다.\n- 스레드 기반이라 성능 제약이 있다. \n\n## nGrinder\n\n네이버에서 만든 오픈 소스이다.  \n스크립트 생성과 테스트, 모니터링 등 성능 지표에 대한 보고서를 Web UI 로 사용할 수 있다. 여러 테스트를 동시에 실행하고, 결과를 중앙에서 모니터링할 수 있다.  \n\nnGrinder 를 사용하기 위해 `Controller` , `Agent` , `Target Server` 가 별도의 서버로 구성되어야 한다.  \n한 서버에 모두 몰려있는 경우, 서버의 자원을 나눠서 사용해야 하고, 그만큼 Context Switching 이 발생하여 순수 성능을 끌어올릴 수 없다.\n\n`groovy` 스크립트로 테스트 시나리오를 작성할 수 있다.  \n\n### 용어\n\n- `Controller` : Web UI 를 제공하고 테스트를 구성할 수 있도록 하며, 테스트를 모니터링하거나 보고서를 시각화 해주는 역할\n- `Agent` : 부하를 발생시키는 역할로, Process 와 Thread 를 사용하여 vUser (가상 사용자) 를 생성한다. `Controller` 가 생성한 테스트 스크립트에 의해 `Target Server` 에 부하를 발생시킨다. 복수의 머신에 설치하여 `Controller` 의 신호에 따라 일시에 부하를 발생시킨다. \n- `Target Server` : 테스트하고자 하는 서버. 테스트 중 발생한 오류나 CPU, Memory 의 점유율 등을 확인하고 싶다면 nGrinder Monitor 를 설치할 수 있다. \n\n`Controller`, `Agent`, `Target Server` 는 모두 각각 구축하는 것이 좋다. 세 가지 요소들을 하나의 서버로 구동한다면, 서버가 성능 테스트만을 위해 자원을 사용할 수 없게 되기 때문에 정확한 수치를 산출해내기 어렵다.\n\n### 장점\n\n- 설치만 하면 사용하기 쉽다.\n- 예약, 모니터링, ramp up, 스크립트 기능을 지원한다.\n- docker 에서 사용할 수 있다.\n- 특정 목적 (대규모 웹 애플리케이션 테스팅) 을 위해 최적화된 도구이다.\n- 웹 UI 에서 에이전트를 쉽게 관리하고 분산 테스팅을 구성할 수 있다.\n- 예약을 통해 주기적인 테스트가 가능하다.\n- WAS 기반으로 동작하여 젠킨스, 소나큐브 대시보드 같이 개발자 각각의 계정을 가질 수 있고, 계정 별 부하 테스트 히스토리를 관리할 수 있다.\n\n### 단점\n\n- agent 와 controller 를 각자 실행해야 된다. \n- controller 가 tomcat 을 필요로 한다.\n- 스레드 기반이라 성능, 동시성 제한이 있다.\n- 커뮤니티가 활발하게 활성화되지 않아 한국어로 작성된 문서가 거의 없다.\n\n## Locust\n\nPython 기반의 부하 테스팅 도구이다. 사용자 정의 테스트 시나리오를 Python 코드로 작성하여 실행할 수 있다.  \n\n1. 총 요청에 대한 RPS 와 실패율 관련 정보\n2. 응답 시간과 95% percentile\n3. 투입된 유저 수\n\n등을 보여준다.\n\n### 장점\n\n- 테스트 시작, 중지, 모니터링 및 결과 보고를 위한 웹 사용자 인터페이스를 제공한다.\n- 여러 머신에서 테스트를 동시에 실행하여 대규모 부하 테스트를 수행할 수 있다. \n- 별도의 큰 설치나 설정 없이 간단하게 실행 가능하다.\n- 스크립트 기반으로 성능 테스트가 진행된다. 명시적인 코드로 테스트 시나리오를 확인할 수 있고, 시나리오 형상 관리도 용이하다.\n- Event Driven 방식으로 사용하기 때문에 적은 리소스로도 많은 트래픽을 생성할 수 있다.\n- 통계를 다운로드 받을 수 있다.\n\n### 단점\n\n- JMeter 같은 Java 기반 도구와 달리, Python 기반이기 때문에 스프링 애플리케이션과의 통합이 덜 하다고 할 수 있다. \n- 다양한 프로토콜에 대한 내장 지원이 부족할 수 있다.\n- 파이썬 러닝 커브가 존재한다.\n\n## Pinpoint\n\nJava 로 작성된 대규모 분산 시스템 용 APM 도구이다.  \n`Transaction` 의 추적을 제공하는 APM 중 하나이다.  \n\n## 결론\n\nnGrinder 를 사용하기 위해서는 `Agent` , `Controller` 가 각각 서버로 구성되어야 하기 때문에 서버가 2대 이상 필요하게 된다. 로컬에서 `Agent` 를 실행하게 된다면 JMeter 와 차이점이 없어진다.  \n\nJMeter 는 2023년 7월에도 Release 가 올라왔기 때문에, 꾸준하게 오픈소스 업데이트가 이루어진다고 할 수 있다.  \n\n## 참고\n\n- https://techblog.woowahan.com/2572/\n- https://hudi.blog/dallog-preparing-for-performance-test/\n- https://ellune.tistory.com/68"},{"excerpt":"LOG 알고리즘 1문제 풀었다. S-HOOK 개인정보 처리방침 만들고 노래 7개 킬링파트 등록했다. 배운 것 jpa-dynamic-update 내용을 보충했다. 느낀 것 홍보 전략 너무 어렵다... 😭","fields":{"slug":"/2023-09-06/"},"frontmatter":{"date":"2023년 09월 07일 00:09","title":"2023년 09월 06일","tags":null},"rawMarkdownBody":"## LOG\n\n- 알고리즘 1문제 풀었다.  \n- S-HOOK 개인정보 처리방침 만들고 노래 7개 킬링파트 등록했다.\n\n## 배운 것\n\n- [[jpa-dynamic-update]] 내용을 보충했다.\n\n## 느낀 것\n\n- 홍보 전략 너무 어렵다... 😭"},{"excerpt":"S-HOOK의 좋아요 기능? , ,  테이블이 존재합니다. 데이터베이스 조회 성능을 개선하기 위해  테이블에 집계 컬럼인  를 추가하게 되었습니다. 통계 정보를 계속 업데이트 하기 위해 좋아요가 눌릴 때마다  를 업데이트해주어야 합니다. 즉, 다음과 같은 프로세스로 진행됩니다.  가 특정  에 좋아요 요청  테이블에  id,  id 값을 갖는 row 가 …","fields":{"slug":"/shook-like-issue/"},"frontmatter":{"date":"2023년 09월 06일 05:09","title":"S-HOOK 좋아요 정합성 이슈","tags":["shook","레벨4","우테코","임시"]},"rawMarkdownBody":"\n## S-HOOK의 좋아요 기능?\n\n`killing_part_like`, `killing_part`, `member` 테이블이 존재합니다.  \n\n데이터베이스 조회 성능을 개선하기 위해 `killing_part` 테이블에 집계 컬럼인 `like_count` 를 추가하게 되었습니다. 통계 정보를 계속 업데이트 하기 위해 좋아요가 눌릴 때마다 `like_count` 를 업데이트해주어야 합니다.  \n\n즉, 다음과 같은 프로세스로 진행됩니다.  \n\n1. `member` 가 특정 `killing_part` 에 좋아요 요청\n\t1. `killing_part_like` 테이블에 `killing_part` id, `member` id 값을 갖는 row 가 있는지 확인\n\t\t1. 있다 => `killing_part_like` 의 `is_deleted` 가 `true` 인 경우, `false` 로 변경. `false` 인 경우, 아무것도 수행하지 않음.\n\t\t2. 없다 => `killing_part_like` 테이블에 행 추가\n2. `member` 가 특정 `killing_part` 에 좋아요 취소 요청\n\t1. `killing_part_like` 테이블에 `killing_part` id, `member` id 값을 갖는 row 가 있는지 확인\n\t\t1. 있다 => `killing_part_like` 의 `is_deleted` 가 `false` 인 경우, `true` 로 변경. `true` 인 경우, 아무것도 수행하지 않음.\n\t\t2. 없다 => 아무것도 수행하지 않음.\n\n`KillingPart` 의 업데이트 과정은 JPA 의 더티 체킹을 통해 이루어집니다.  \n최대한 도메인을 이용해서 비즈니스 로직을 수행할 수 있다는 장점이 있지만, 이 부분에서 동시성 문제가 발생할 수 있습니다.  \n\n### 왜 동시성 문제가 발생할까?\n\n위와 같이 하나의 트랜잭션이 업데이트 쿼리를 실행하는 동안, 다른 트랜잭션이 레코드를 변경하게 된다면 다음과 같은 상황이 발생한다.\n\n![[jpa-dirty-checking-concurrency-issue.png]]\n\n사용자 A의 트랜잭션이 업데이트 되기 전에 사용자 B 의 트랜잭션에서 좋아요 수를 읽어오기 때문에 정합성 이슈가 발생할 수 있습니다.  \n\n## 동시성 이슈 해결 방법\n\n이 문제를 해결하기 위해 정말 다양한 방법을 생각해보았습니다.  \n\n### 비관적 락 사용하기\n\n킬링파트에 좋아요를 하는 메서드에 비관적 락을 거는 방법이 있습니다.  \n\n비관적 락이란 대부분의 트랜잭션이 서로 충돌이 날 것이라는 상황에서 데이터베이스에 락을 걸어 동시성을 제어하는 것입니다.  \n\n이렇게 되면 A 트랜잭션이 끝날 때까지 다른 트랜잭션들이 배타락, 공유락 모두 얻을 수 없습니다. 한 번에 하나의 트랜잭션만 락을 얻을 수 있기 때문에 데이터의 정합성 문제가 해결됩니다.  \n\n그러나 비관적 락을 사용하게 되면 대기 시간이 발생할 수 밖에 없습니다. \n\n현재 서비스에서 '킬링파트 좋아요' 는 굉장히 중요한 로직을 담당하고 있습니다. 노래가 좋아요 순으로 실시간으로 정렬되기 때문에, 좋아요의 실시간 성은 매우 중요합니다.  \n\n이런 상황에서 대기 시간이 발생하는 비관적 락은 상황에 맞지 않다고 볼 수 있습니다.  \n\n### 낙관적 락 `@Version` 사용하기\n\n낙관적 락이란 대부분의 트랜잭션이 충돌이 나지 않을 것이라는 가정 하에, 데이터베이스에 락을 걸지 않고 애플리케이션 단에서 엔티티 버전 관리를 통해 동시성을 제어하는 것입니다.  \n엔티티가 변경될 때마다 Version 이 하나씩 증가하게 됩니다. 엔티티를 수정할 때 조회한 시점의 버전과 수정 시점의 버전이 일치하지 않으면 예외가 발생합니다. 단순하게 예외를 무시하게 되면 좋아요를 누른 사용자 입장에서는 이해할 수 없는 동작이 되므로, 발생한 예외는 요청을 다시 보내 달라는 등 적절한 조치가 취해져야 합니다.  \n\n그러나 저희가 처한 상황은 낙관적 락에 적합하지 않습니다.  \n킬링파트의 좋아요가 서비스 내부에서 다양하게 사용되기 때문에, 좋아요 기능은 사용자들이 가장 많이 사용하게 될 것입니다. 이때, 동일한 킬링파트에 좋아요를 누르는 행동이 빈번하게 일어나지 않을 것이라는 가정은 하기 어렵습니다.  \n\n### `synchronized`\n\n하나의 프로세스 내의 스레드 단위에서만 동시성을 보장한다.  \n\n### 직접 update 쿼리 실행하기\n\n더티 체킹을 포기하고, DB가 직접 원자적 연산을 처리하는 것입니다.  \n도메인 값을 변경하지 않고, 서비스 레이어에서 직접 레포지토리의 메서드를 호출해주어야 하므로 모든 비즈니스 로직을 도메인에서 응집하기는 불가능해집니다.   \n\n그러나 객체지향을 철저하게 지키는 것보다 정합성이 더 중요하다면 사용하는 것이 좋습니다.  \n\n직접 update 쿼리를 JPQL 로 구현하여 실행하게 되면 DB 자체에서 걸어주는 배타락 덕분에 정합성 문제가 발생하지 않습니다!  \n\nJPQL 에서 update 를 실행하므로 `@Modifying` 을 사용하게 됩니다. 다음과 같은 속성들을 `true` 로 바꿔주는 것이 좋습니다.  \n- `clearAutomatically` : 기본값은 `false` 로 `true` 로 설정하면 쿼리 실행 후에 영속성 컨텍스트를 자동으로 clear 합니다.  \n- `flushAutomatically` : 기본값은 `false` 로 `true` 로 설정하면 쿼리 실행 전에 영속성 컨텍스트를 플러시합니다.   \n\n### 좋아요 수 쿼리를 비동기를 사용해서 성능 개선하기\n\n실시간으로 좋아요 증가 감소 로직을 수행하지 않고, \n\n### 이벤트 기반 아키텍처 도입하기\n\n좋아요를 누를 때 바로 `like_count` 를 업데이트하지 않고, 이벤트를 생성하고 이벤트 핸들러에서 `like_count` 를 업데이트하는 것입니다.  \n\n이벤트 처리는 일련의 순서대로 처리될 수 있기 때문에, 이렇게 하면 여러 사용자가 동시에 좋아요를 누르더라도 이벤트 순서대로 처리됩니다. 따라서 정합성을 유지할 수 있습니다.  \n\n단, 이벤트는 순서대로 처리되어야 합니다. 만약 순서대로 처리되지 않는다면 다음과 같은 상황이 발생할 수 있습니다.  \n\n1. 사용자 A와 사용자 B가 거의 동시에 같은 `killing_part`에 좋아요를 누름.\n2. 시스템은 두 이벤트를 거의 동시에 인지하고, 현재 `like_count` 값을 읽어옴 (예: 5).\n3. 두 이벤트 모두 `like_count`에 1을 더해 업데이트하려 함.\n4. 결과적으로 `like_count`는 6이 되지만, 원래 의도한대로라면 7이 되어야 함.\n\n따라서 이벤트 순서를 보장하기 위한 방법 (카프카, 이벤트 소싱 등) 을 사용하는 것이 좋습니다. \n\n#### 참고\n\n나중에 공부를 위해..  \n- https://newwisdom.tistory.com/75\n\n### Redis 사용\n\n`killing_part` 의 `like_count` 를 업데이트하기 전에 분산락을 얻는 것입니다.  \n락을 가진 인스턴스만 `like_count` 를 업데이트 할 수 있습니다. \n\n#### Redission\n#### Lettuce\n\n## 참고\n\n- https://golf-dev.tistory.com/73\n- https://dev-alxndr.tistory.com/45\n- https://velog.io/@ohzzi/%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A0%95%ED%95%A9%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EA%B8%B0"},{"excerpt":"란? 실제 값이 변경된 컬럼으로만 update 쿼리를 만드는 기능이다. JPA 가 아닌 하이버네이트 기능이라고 한다. 변경된 컬럼을 찾는다. 변경되는 컬럼에 따라 쿼리가 변경된다. JDBC 와 JPA JDBC 에서는  클래스를 사용할 수 있다.  는 SQL 구문을 캐시하고, ?로 작성된 파라미터 부분만 변경하며 재사용한다. JPA 도 내부적으로는 JDBC…","fields":{"slug":"/jpa-dynamic-update/"},"frontmatter":{"date":"2023년 09월 06일 04:09","title":"JPA DynamicUpdate","tags":["jpa","spring"]},"rawMarkdownBody":"\n## `@DynamicUpdate` 란?\n\n실제 값이 변경된 컬럼으로만 update 쿼리를 만드는 기능이다.  \nJPA 가 아닌 하이버네이트 기능이라고 한다.  \n\n1. 변경된 컬럼을 찾는다.\n2. 변경되는 컬럼에 따라 쿼리가 변경된다. \n\n### JDBC 와 JPA\n\nJDBC 에서는 `PreparedStatement` 클래스를 사용할 수 있다. `PreparedStatement` 는 SQL 구문을 캐시하고, ?로 작성된 파라미터 부분만 변경하며 재사용한다.   \n\nJPA 도 내부적으로는 JDBC와 `PreparedStatement` 를 사용하게 되는데, 변경된 컬럼에 대해서만 update 쿼리를 날리면 SQL 캐시 히트율이 떨어지게 될 것이다.  \n\n또한 JPA 입장에서도 추가적인 연산이 필요하다. 모든 컬럼을 수정할 때는 엔티티 객체 변경만 추적하면 됐지만, 특정 컬럼의 변화를 감지하기 위해서는 필드 수준의 추적이 필요하게 된다.   \n\n## 쓰면 좋은 경우\n\n1. 컬럼이 많은 경우  \n많은 수의 컬럼이 있는데, 몇 개의 컬럼만 자주 업데이트 하는 경우에 사용하면 좋다. 많다는 말은 모호하기 때문에 기준을 확실하게 정해야 할 듯.\n\n2. 테이블에 인덱스가 많은 경우  \n인덱스가 걸려있는 컬럼은 변경이 발생하는 인덱스를 재정렬하게 되는데, 인덱스가 많으면 많을수록 update 쿼리에 영향을 주게 된다.  \n값이 변경되지 않았다면 굳이 update 하지 않는 것이 update 쿼리 성능에 도움을 줄 수 있다.\n\n3. 데이터베이스가 컬럼 락을 지원하는 경우  \nMySQL 은 컬럼 락을 지원하지 않는다. 컬럼 락을 지원하는 DBMS (yugabyte 같은 데이터베이스) 에서 사용하기 적절하다고 한다.\n\n4. `@Version` 을 사용하지 않는 Optimistic Locking 의 경우에 사용하라고 되어 있다.  \n\n## 참고\n\n- https://multifrontgarden.tistory.com/299\n- https://recordsoflife.tistory.com/1241"},{"excerpt":"LOG 알고리즘 3문제 풀었다. 리뷰 달고 리뷰 반영하느라 40분 밖에 투자 못했는데 MST를 구하는 코드가 그렇게 어렵지 않아서 그 사이 3문제나 풀었따! 근데 사실 다 이전 문제 코드를 재활용하는 느낌이라 사실상 한 문제를 푼 거나 다름없다...ㅋㅋ 병원에 갔다왔다. 가는 길에 갑자기 비가 와서 맞고 왔는데 다시 나왔더니 비가 엄청 많이 내렸다... …","fields":{"slug":"/2023-09-05/"},"frontmatter":{"date":"2023년 09월 05일 13:09","title":"2023년 09월 05일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 3문제 풀었다. 리뷰 달고 리뷰 반영하느라 40분 밖에 투자 못했는데 MST를 구하는 코드가 그렇게 어렵지 않아서 그 사이 3문제나 풀었따! 근데 사실 다 이전 문제 코드를 재활용하는 느낌이라 사실상 한 문제를 푼 거나 다름없다...ㅋㅋ\n- 병원에 갔다왔다. 가는 길에 갑자기 비가 와서 맞고 왔는데 다시 나왔더니 비가 엄청 많이 내렸다... 근데 지하철에서 내렸더니 비가 안 온 것처럼 멀쩡하게 그쳐 있었다. 날씨도 이상하다 ㅋㅋ\n- 에밀 리뷰를 달아주고 우르가 리뷰해준 코멘트들을 반영했다. \n\n## 배운 것\n\n- [[minimum-spanning-tree]] 를 공부했다. 크루스칼 알고리즘은 신기한 알고리즘이다.\n\n## 느낀 것\n\n레벨 4는 절대적인 시간이 부족하다. 그래서 더더욱 어떤 것에 집중해야 하는지 명확하게 정해야 한다. 나는 올해 고도화된 프로젝트를 만들고, 알고리즘을 내가 원하는 수준까지 올리는 것이 목표이다.   \n물론 나는 욕심이 많아서 하고 싶은 건 정말 많다. 이번에 미션하면서 궁금했던 톰캣 내부 구조 뜯어보기, 네트워크 공부, OS 공부, 자바 내부 동작 공부, DB 공부 등 하고 싶은 건 진짜진짜 많고 뭐든 재밌게 공부할 자신 있다.   그렇지만 우테코라는 좋은 기회를 잡은 만큼 올해는 우테코에서'만' 할 수 있는 경험들에 집중하고 싶다. (알고리즘은 올해에 본격적으로 시작한 김에 꾸준하게 열심히 해보자는 목표긴 해서 논외)    \n\n톰캣 내부 구조는 우테코 끝나고 열심히 뜯어볼 수 있다. 네트워크도, OS도, 리마큐도, 자바 내부 동작도 지금 말고 12월에, 내년에 할 수 있는 일들이다. 그러나 S-HOOK 이라는 프로젝트, 그리고 온전한 우리 팀과 함께 할 수 있는 시간은 단 11월 말까지 뿐이다. 프로젝트 고도화도 팀원들과 같이 해야 다양한 의견도 나오고 재밌을 거다. 새로운 기능을 고민하면서 기획하는 거, 지금 말고 언제 또 해볼 수 있을까? 무엇보다 우리 서비스는 실 사용자가 생길 법한 서비스라고 생각하기 때문에 더 욕심이 난다. 우테코를 수료한 뒤에 프로젝트를 마저 운영해보고 싶은 팀원들이 남더라도, 각자의 사정으로 빠지는 팀원들이 있을 것이다. 온전한 우리 팀과 프로젝트 기능들을 더 고민하고, 필요한 기능들을 만들고, 성능을 개선하는 경험을 하고 싶다. 그게 내 레벨 4 목표다.    \n\n다른 사람들이 더 많은 것을 공부하고, 더 많은 것을 알아가고, 더 멋진 성장을 할 수도 있다. 나도 강한 사람이 아니라서 그럴 때마다 흔들릴지도 모른다. 하지만 기억하자. 모든 것을 다 하는 사람이 무조건 다 잘하는 것은 아니라는 걸. 모든 걸 지금 다 할 필요도 없다는 걸! 결국 난 어제의 나를 이겨낼 거다.\n\n나는 나를 잘 안다. 할 게 많으면 분명 지칠 거고, 내가 감당할 수 있는 것보다 훨씬 많은 공부량에 압도되어 오히려 무력해질 걸 잘 알고 있다.  \n그래서 억지로 참고 있다 ㅋㅋ 미래의 나에게도 할 일은 남겨 놔야지~ 올해 다 해버리면 재미없다\n"},{"excerpt":"Spanning Tree 그래프 내부의 모든 정점을 포함하는 트리 트리의 특수한 형태이기 때문에, 모든 정점들이 연결되어 있어야 하며 사이클을 포함해서는 안 된다. 즉, 그래프의 n 개의 정점을 n-1 개의 간선으로 연결해야 한다. MST Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리를 의미한다. 모든 정점들을 가장 적은 수의 …","fields":{"slug":"/minimum-spanning-tree/"},"frontmatter":{"date":"2023년 09월 05일 13:09","title":"최소 신장 트리 (MST)","tags":["algorithm"]},"rawMarkdownBody":"\n## Spanning Tree\n\n그래프 내부의 모든 정점을 포함하는 트리\n\n트리의 특수한 형태이기 때문에, 모든 정점들이 연결되어 있어야 하며 사이클을 포함해서는 안 된다.  \n즉, 그래프의 n 개의 정점을 n-1 개의 간선으로 연결해야 한다.\n\n## MST\n\nSpanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리를 의미한다.  \n모든 정점들을 가장 적은 수의 간선과 비용으로 연결한다.  \n\nSpanning Tree 의 조건을 충족하면서, 간선의 가중치 합이 최소여야 한다.   \n\n## 구현 방법\n\n### Kruskal Algorithm\n\n그리디하게 모든 정점을 최소 비용으로 연결하는 답을 찾는다.  \n이전 단계에서 만들어진 Spanning Tree 와는 상관 없이 무조건 최소 간선만을 선택한다.  \n\n#### 순서\n\n1. 그래프의 간선들을 가중치 오름차순으로 정렬한다.\n2. 정렬된 간선 리스트에서 간선을 선택한다.\n\t1. 가장 낮은 가중치를 먼저 선택한다.\n\t2. 사이클을 형성하는 간선을 제외하고, union 연산을 수행한다.\n\n#### 코드\n\n```python\ndef find(x):  \n    if parent[x] == x:  \n        return x  \n    parent[x] = find(parent[x])  \n    return parent[x]  \n  \n  \ndef union(x, y):  \n    x_parent = find(x)  \n    y_parent = find(y)  \n  \n    if x_parent == y_parent:  \n        return  \n    if rank[x_parent] < rank[y_parent]:  \n        parent[x_parent] = y_parent  \n    else:  \n        parent[y_parent] = x_parent  \n        if rank[x_parent] == rank[y_parent]:  \n            rank[x_parent] += 1  \n  \n  \ndef kruskal():  \n    global edges, weights, heap, n  \n    parent = [i for i in range(n + 1)]  \n    result = set()  \n    edges.sort()  \n  \n    for edge in edges:  \n        weight, a, b = edge  \n        if find(a) != find(b):  \n            union(a, b)  \n            result.add(a)  \n            result.add(b)  \n            weights += weight\n```\n\n## 참고\n- https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html\n- https://ssabi.tistory.com/60"},{"excerpt":"회의 개요 레벨 4가 되면서 프로젝트와 함께 병행해야 하는 것들이 엄청나게 많아졌습니다. 미션 + 개인 공부(취업) 등... 이전에 레벨 4에서 생각하는 우선순위를 팀원들끼리 공유했었습니다. 공통적으로 10시부터 6시까지는 미션과 프로젝트에 집중하겠다는 의견이 다수였습니다. 그러나 실제로는 미션에 집중하느라 프로젝트에 어느 정도 소홀했다고 생각합니다. 레…","fields":{"slug":"/shook-level4/"},"frontmatter":{"date":"2023년 09월 04일 12:09","title":"S-HOOK 레벨4 슬기롭게 헤쳐나가기","tags":["shook","레벨4","우테코"]},"rawMarkdownBody":"\n## 회의 개요\n\n레벨 4가 되면서 프로젝트와 함께 병행해야 하는 것들이 엄청나게 많아졌습니다.   \n미션 + 개인 공부(취업) 등...   \n\n이전에 레벨 4에서 생각하는 우선순위를 팀원들끼리 공유했었습니다.   \n공통적으로 10시부터 6시까지는 미션과 프로젝트에 집중하겠다는 의견이 다수였습니다.   \n\n그러나 실제로는 미션에 집중하느라 프로젝트에 어느 정도 소홀했다고 생각합니다.   \n레벨 4에 구현할 기능, 홍보 기획, 실 사용자 유치 계획 등 아직도 확실하게 정해진 것이 없고, 프로젝트 관련 회의는 한 번도 하지 못했습니다. (물론 내일 하긴 함)   \n\n따라서 **우테코에 있는 10시~6시에 미션과 프로젝트에 팀원 각각이 어느 정도의 비중을 둘 것인지에 대해 이야기할 것**을 제안합니다.   \n\n모든 팀원이 프로젝트에 무조건 집중해야 한다고 주장하는 이야기가 아닙니다.   \n팀원 각자의 상황은 모두 다르다는 것을 알고 있어요.   \n제출해야 하는 미션이 우선인 팀원, 개인 공부에 어느 정도의 비중(혹은 높게)을 두고 싶은 팀원, 프로젝트 기능 개발을 주로 진행하고 싶은 팀원도 있을 수 있죠.   \n\n그러니 각자의 우선순위에 맞게 프로젝트의 비중을 나누는 것에 대해 논의하는 건 어떨까요.   \n이런 제안을 하는 것은 굉장히 조심스럽지만, 개인적으로는 레벨4 프로젝트를 진행하기 위해서 필수적인 논의라고 생각합니다.   \n\n## 제안 전에 이야기 할 내용\n\n**프로젝트가 1순위가 아니어도 괜찮습니다. 다른 분들도 그렇게 생각하실거라 생각합니다 😊**\n\n레벨 4 를 쭉 이 방식대로 진행하겠다! 라는 마음가짐으로 **솔직하게** 대답해주세요 😁   \nHappy Case 는 잠시 제쳐두고, 현재 생각할 수 있는 Worst Case 만 생각하겠습니다.   \nWorst Case 일 때가 가장 확장성 있는 계획을 세울 수 있을 것 같거든요.  \n\n- 팀원들 각각이 미션 혹은 개인 공부 / 프로젝트에 어느 정도 비중을 두고 싶은지\n\t- 개인 공부는 미션을 위한 추가 공부도 포함합니다.\n\t- 미션과 프로젝트에 투자하는 시간은 우테코에 있는 시간을 기준으로 합니다. 즉, 우테코에 있는 8시간을 어떻게 나눠쓸 것인지 말해주시면 됩니다.\n\t- 레벨 4에 있을 미션 난이도는 첫 미션의 난이도로 가정합니다. (이후 미션이라고 해서 더 쉬울 것 같지는 않아 보입니다.)\n\t- 미션을 진행할 수 있는 기간도 첫 미션의 기간으로 가정합니다. (백엔드는 이번 미션 마감일이 너무 짧았으니 미션을 진행할 수 있는 시간이 4일이라고 가정합시다.)\n\n## 제안 혹은 의견\n\n결론적으로는 제안하는 것은 '미션 혹은 개인 공부' 와 '프로젝트' 비중에 따라 개발하는 기능을 나누는 것입니다.   \n\n미션이나 개인 공부에 좀 더 비중을 두고 싶은 팀원은 서비스의 유지 보수를 담당하고,   \n프로젝트에 비중을 두고 싶은 팀원은 실 사용자의 피드백에서 파생되는 새로운 기능을 개발하는 것으로 분리하는 것은 어떨까요?   \n\n제안이 받아들여진다면, 더 논의해보아야 하겠지만 개인적으로 구상해보았을 때 각각 다음과 같은 기능들을 담당하게 될 것 같습니다.   \n\n서비스의 유지/보수는 기존 론칭 페스티벌에서 제기된 버그 수정, 현재 서비스에서 크리티컬하게 문제가 되는 기능, 혹은 기존 기능에서 고도화해야 하는 부분을 맡을 수 있을 것 같습니다.    \n\n신규 기능 개발은 론칭 페스티벌에서 제안된 새로운 기능들, 실 사용자의 피드백에서 파생되는 신규 기능들을 기획 / 개발할 것 같습니다. 혹은 지금은 크리티컬하지 않은 추가 기능들을 개발/고도화할 수도 있을 것 같네요.   \n\n단 미션, 개인 공부 등에 비중을 두는 팀원들은 그만큼 프로젝트에 참여할 수 있는 시간적인 비율이 적기 때문에, 기획된 신규 기능의 가부를 결정하는 투표에서 일정 배수 (ex. 0.7, 0.8 등) 로 의견을 반영하는 것이 좋을 것 같습니다.   \n\n**!!!! 팀원의 의견을 배제하는 게 아니고, 기능 개발이 일부 팀원끼리만 이루어진다는 것도 아닙니다 !!!!**\n유지 보수 팀원들도 프로젝트 개발하는 S-HOOK 팀원입니다. 다만 프로젝트 비중을 어느 정도로 둘 지를 정하자는 것 뿐입니다.\n\n더 나은 의견 있다면 Discussion 댓글이나 회의 시간에 제안해주세요 ˙ᵕ˙\n\n## 예상 시간\n\n1시간 이내로 마무리 하시죠! (가능하다면...)\n\n## 이야기\n\n프로젝트: 회의 + 코드 치는 시간\n\n- 아코\n\t- 미션 6시간, 프로젝트 2시간 (회의만 가정)\n\t- 비중은 미션에 좀 더 높게\n- 우코\n\t- 프로젝트 2-6시 (4시간) 그 외는 미션 혹은 우테코 생활\n- 스플릿\n\t- 미션: 4시간, 프로젝트: 4시간\n- 코난\n\t- 미션: 2시간, 프로젝트: 6시간 (1시-2시부터 6시까지)\n\t- 일과 학습의 병행이 큰 주제. 학습이 주객전도되면 안 된다고 들었다. 학습할 때 포기할 부분, 가치판단이 존재한다.\n- 베로\n\t- 미션: 1시간, 프로젝트: 7시간\n- 도밥\n\t- 미션: 5시간, 프로젝트: 3시간\n\t- 이후에 프로젝트를 할 것도 같다.\n- 바론\n\t- 미션: 3시간, 프로젝트: 5시간\n\n## 제안\n\n- 아코\n\t- 팀 프로젝트는 7명이 모여서 하는 건 사실상 불가능하다고 생각한다. 기능 담당, 세분화는 유닛 단위로 진행되어야 할 것 같다. 다 같이 하는 것도 있지만, 유닛 단위로 처리하는 것이 좋아보인다. 프로세스가 비동기로 가야 될 거 같다.\n\n### 프로젝트 타임\n\n프로젝트 타임을 정해서 궁극적인 이유가 궁금하다.   \n모두의 참여율이 어느 정도 확보?  \n눈치 보일 일이 줄어든다.  \n\n- 이슈 단위로 일정 추정을 해서, 시간이 덜 걸리는 일을 분배하는 것은 어떤가  \n- 같은 스쿼드로 묶는다고 해도 프론트 / 백 의 속도가 달라질 수 있다.\n\t- 기능 구현할 때 백 + 프론트가 같이 하는 걸 스쿼드라고 한다.\n\n스프린트를 잡아서 일정 추정이 되면 그 때 투자할 수 있는 시간을 스프린트 회의 때 말해서 주 단위로 추정해보자. 고정이 아니라 스프린트마다 달라질 수 있다...  \n\n## 스프린트\n\n주 단위로 합시다 그럼  \n\n- 스프린트 일정\n\t- 9/6 스프린트 회의 ~ 9/13\n\n### 스프린트 회의\n\n2시 ~ 3시\n\n- 해야 할 일과 일정 확정\n- 이슈 단위 분배\n\t- 이번 주 일정 추정 공유\n"},{"excerpt":"손오공 https://www.youtube.com/watch?v=-GQg25oP0S4 0:30 -> 10초 0:57 -> 10초 2:25 -> 15초 후라이의 꿈 https://www.youtube.com/watch?v=3kGAlp_PNUg 1:52 -> 10초 0:53 -> 5초 3:14 -> 10초","fields":{"slug":"/shook-song-data/"},"frontmatter":{"date":"2023년 09월 04일 08:09","title":"S-HOOK 노래 데이터","tags":["shook"]},"rawMarkdownBody":"\n- 손오공\n\t- https://www.youtube.com/watch?v=-GQg25oP0S4\n\t- 0:30 -> 10초\n\t- 0:57 -> 10초\n\t- 2:25 -> 15초\n- 후라이의 꿈\n\t- https://www.youtube.com/watch?v=3kGAlp_PNUg\n\t- 1:52 -> 10초\n\t- 0:53 -> 5초\n\t- 3:14 -> 10초\n"},{"excerpt":"LOG 기분이 다운된다............. 뭔가 힘이 안 나는 날인 거 같다. 오늘 하려고 했던 일들도 내일로 미뤘다. 근데 왜 기분이 별로인지 모르겠다. 피곤한가 알고리즘 1문제 풀었다. 오늘은 스트릭 15일 차 S-HOOK 이 모집해야 하는 가입자 100명 ㅎ 우리가 처음에 냈던 거에는 300명이었는데 100명이라 오히려 다행이라고 생각했다. (사…","fields":{"slug":"/2023-09-04/"},"frontmatter":{"date":"2023년 09월 04일 07:09","title":"2023년 09월 04일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 기분이 다운된다............. 뭔가 힘이 안 나는 날인 거 같다. 오늘 하려고 했던 일들도 내일로 미뤘다. 근데 왜 기분이 별로인지 모르겠다. 피곤한가\n- 알고리즘 1문제 풀었다. 오늘은 스트릭 15일 차\n- S-HOOK 이 모집해야 하는 가입자 100명 ㅎ 우리가 처음에 냈던 거에는 300명이었는데 100명이라 오히려 다행이라고 생각했다. (사실 1000명이면 어떡하지했다...)\n\n## 배운 것\n\n- [[algorithm-tips]] 분리 집합에서 사이클을 찾는 방법을 알아냈다.\n\n## 느낀 것\n\n- 평소보다 밥을 잘 먹고 있다. 특히 오늘은 진짜 잘 먹은 듯..\n- 죠왓서 진행시켜\n"},{"excerpt":"비트마스킹이란 이진 숫자를 이용해서 데이터의 집합을 표현하거나, 그 데이터에 특정 연산을 수행하는 기술이다. 비트를 사용하여 데이터의 존재, 상태를 나타내기 때문에 매우 효율적인 메모리 사용이 가능하다. 비트마스킹 연산 특정 비트 확인 n 번째 비트가 1인지 0인지 확인하기 위해 AND 연산을 사용한다. 특정 비트 켜기 (설정)\nOR 연산을 사용하여 n …","fields":{"slug":"/bitmasking/"},"frontmatter":{"date":"2023년 09월 01일 12:09","title":"비트마스킹","tags":["algorithm"]},"rawMarkdownBody":"\n## 비트마스킹이란\n\n이진 숫자를 이용해서 데이터의 집합을 표현하거나, 그 데이터에 특정 연산을 수행하는 기술이다.   \n비트를 사용하여 데이터의 존재, 상태를 나타내기 때문에 매우 효율적인 메모리 사용이 가능하다. \n\n## 비트마스킹 연산\n\n1. 특정 비트 확인   \n\tn 번째 비트가 1인지 0인지 확인하기 위해 AND 연산을 사용한다.\n\n```python\n(mask & (1 << n)) # n 번째 비트가 1이면 결과는 1, 0이면 0\n```\n\n2. 특정 비트 켜기 (설정)\n\tOR 연산을 사용하여 n 번째 비트를 1로 만든다.\n\n```python\nmask |= (1 << n)\n```\n\n3. 특정 비트 끄기 (초기화)\n\tAND, NOT 연산을 사용하여 n 번째 비트를 0으로 만든다.\n\n```python\nmask &= ~(1 << n)\n```\n\n4. 특정 비트 토글\n\tXOR 연산을 사용하여 n 번째 비트를 반전시킨다.\n\n```python\nmask ^= (1 << n)\n```\n"},{"excerpt":"비용이 최소가 되는 해밀턴 사이클을 찾는 문제이다. N <= 11 일 때 O(N!) 의 브루트포스 풀이가 가능하다.\nN <= 12 일 때 백트래킹 풀이가 가능하다.\nN <= 16 일 때 DP 와 BitMasking 을 사용하여 O(N^2 * 2^n) 풀이가 가능하다. 1, 2, 3, 4, 5 어느 정점에서 출발하든 최적의 순회 경로는 동일하므로, 한 정점…","fields":{"slug":"/tsp/"},"frontmatter":{"date":"2023년 09월 01일 12:09","title":"TSP 외판원 순회 문제","tags":["algorithm"]},"rawMarkdownBody":"\n비용이 최소가 되는 해밀턴 사이클을 찾는 문제이다.\n\nN <= 11 일 때 O(N!) 의 브루트포스 풀이가 가능하다.\nN <= 12 일 때 백트래킹 풀이가 가능하다.\nN <= 16 일 때 DP 와 BitMasking 을 사용하여 O(N^2 * 2^n) 풀이가 가능하다.\n\n1, 2, 3, 4, 5 어느 정점에서 출발하든 최적의 순회 경로는 동일하므로, 한 정점에서 시작하는 것만 고려해도 된다. \n\n## Brute-Force 풀이\n\n모든 가능한 경로의 조합을 구하고, 그 중에서 최단 경로를 찾는다.   \n가능한 경로의 조합은 N! 이므로, 시간 복잡도는 O(N!) 이다.   \n\n## DP + Bitmasking\n\nHeld-Karp 알고리즘에 기반한 풀이라고 한다.   \n[[bitmasking]]\n\n### 아이디어\n\n1. 각 도시의 부분 집합에 대한 최적의 경로를 계산하고 저장하기 위해 2차원 DP 테이블을 사용한다.\n2. 비트마스킹을 사용해서 각 도시의 부분 집합을 표현하고, 이를 DP 테이블의 인덱스로 사용한다.\n\n### 구현하기\n\n1. DP 테이블은 `[n][2^n]` 이다. (n 은 도시의 수)\n2. `dp[i][j]` 는 도시 i 를 마지막으로 방문하고, 비트마스크 j 로 표현된 도시들의 부분 집합을 방문한 최소 거리\n3. 모든 도시 부분집합을 순회하며 dp 테이블을 채운다.\n\n```python\n\n```"},{"excerpt":"LOG 드디어 플레 달성했다!!! 흑흑 1년만에 플레 등반 진짜 힘들었다... 골드1 에 1년 있었는데 플레라니 감회가 새롭네요... 그렇지만 아직도 갈길이 먼 것 같네요 그치만 기뻐 🥹 S-HOOK 에서 사용하는 기능은 허가 없이 사용해도 저작권 문제 없다고 한저협에서 말씀해주셔서 드디어 홍보 시작할 수 있따!!!!!! 이 부분 때문에 며칠을 고민했는지…","fields":{"slug":"/2023-09-01/"},"frontmatter":{"date":"2023년 09월 01일 03:09","title":"2023년 09월 01일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 드디어 플레 달성했다!!! 흑흑 1년만에 플레 등반 진짜 힘들었다... 골드1 에 1년 있었는데 플레라니 감회가 새롭네요... 그렇지만 아직도 갈길이 먼 것 같네요 그치만 기뻐 🥹\n- S-HOOK 에서 사용하는 기능은 허가 없이 사용해도 저작권 문제 없다고 한저협에서 말씀해주셔서 드디어 홍보 시작할 수 있따!!!!!! 이 부분 때문에 며칠을 고민했는지.. 드디어 저작권 논란에서 해방이다. \n- 오리랑 40분 정도 커피챗했다. 이전 기수 이야기도 듣고, 5기 이야기도 했는데 되게 재밌었다. 같은 우테코 사람들이랑은 말이 너무 잘 통하는 듯\n\n## 배운 것\n\n- [[bitmasking]], [[tsp]] 에 대해 공부했다.\n- 에스프레소에는 물이 들어간다.\n\n## 느낀 것\n\n- 뭐든 노력하면 되는 거였나? 내가 지금까지 꾸준한 노력을 해본적이 없다는 가설에 힘이 실리고 있다."},{"excerpt":"2023-09-01 2023-09-04 2023-09-05 2023-09-06 2023-09-08 2023-09-09 2023-09-11 2023-09-15 2023-09-16","fields":{"slug":"/2023-09/"},"frontmatter":{"date":"2023년 09월 01일 03:09","title":"2023년 09월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-09-01]]\n- [[2023-09-04]]\n- [[2023-09-05]]\n- [[2023-09-06]]\n- [[2023-09-08]]\n- [[2023-09-09]]\n- [[2023-09-11]]\n- [[2023-09-15]]\n- [[2023-09-16]]\n"},{"excerpt":"9/1 강의 더 깊이 파고들기 각종 도구들을 겨우 지금하는 작업을 완료하는 데 필요한 정도로만 배우고 있다. 그럴 땐 도구나 기술 분야, 각종 기법 같은 것을 깊이 파고드는 법을 배우자. 지금은 Spring 을 깊게 파볼 수 있는 기회다. 대성당을 짓는다고 했을 때 돌무더기를 쌓는 일을 단순하게 보는 것이 아니라, 대성당을 쌓기 위한 일이라고 생각하자. …","fields":{"slug":"/level4-tomcat/"},"frontmatter":{"date":"2023년 09월 01일 01:09","title":"레벨4 Tomcat 미션","tags":["레벨4","spring"]},"rawMarkdownBody":"\n# 9/1\n\n## 강의\n\n- 더 깊이 파고들기\n\t- 각종 도구들을 겨우 지금하는 작업을 완료하는 데 필요한 정도로만 배우고 있다.\n\t- 그럴 땐 도구나 기술 분야, 각종 기법 같은 것을 깊이 파고드는 법을 배우자. 지금은 Spring 을 깊게 파볼 수 있는 기회다. \n\t- 대성당을 짓는다고 했을 때 돌무더기를 쌓는 일을 단순하게 보는 것이 아니라, 대성당을 쌓기 위한 일이라고 생각하자. 개념을 쌓는 것이 지루하지만 그 과정이 가치있다는 것을 알아야 한다.\n\t- 개념의 근원을 따라가는 연습을 하라. 공식 문서가 잘 안 되어 있다면 디버깅을 해보거나, 역컴파일, 리버스 엔지니어링을 해보자.\n\n# 9/6\n\n## Cookie & Session\n\n### HTTP 는 Stateless 가 맞는가?\n\n무상태라면 클라이언트 식별은 어떻게 하는 걸까?  \n-> 쿠키를 통해 클라이언트가 상태를 저장하도록 한다.  \n\n### Cookie\n\n- 사용자를 식별하고 세션을 유지하는 웹 기술\n- 웹 서버는 사용자를 식별하기 위한 유일한 값을 할당한다. Set-Cookie 에 이름=값; 형태로 반환한다. \n- 브라우저는 쿠키 정보를 저장할 책임이 있다.  \n\n세션은 서버에서 값을 저장하고 id 를 발급한다.  \n클라이언트와 서버는 Cookie 를 통해 Session Id 를 주고 받는다.  \n\n## Thread\n\n코드는 JVM 에서 돌아가는데, JVM 내부의 process, main thread 에서 실행된다.  \n지금까지는 Single Thread 로 실행해온 것.  \n\n여러 작업을 한 번에 실행하고 싶을 때\n\n### 자바 프로그램의 메모리 구조\n\nJVM Spec, Java SE 20 기준\n\nRun-Time Data Areas \n- Method Area (static)\n\t- 런타임 상수 풀\n\t- 필드 및 메서드 데이터\n\t- 메서드 및 생성자 코드\n- Heap\n\t- 인스턴스\n\t- 배열\n- JVM Thread\n\n### Concurrency\n\n동시에 여러 작업을 처리할 때 Thread 를 사용한다. => 웹 서버\n\n`connector.start` 를 하면 thread 가 생성된다.\n\n### Thread-safe class\n\n- 상태 변수를 스레드 간에 공유하지 않는다.\n- 상태 변수를 변경할 수 없도록 만든다. -> 인스턴스 변수에 final 붙이는 이유\n- 상태 변수에 접근할 때는 언제나 동기화를 사용한다.\n- 캡슐화나 데이터 은닉은 안전한 클래스 작성에 도움이 된다. \n\n"},{"excerpt":"LOG 알고리즘 2문제 풀었다. 마지막 문제 재귀 풀이는 진짜 파이썬이라 억까당한 거다... C++ 이었으면 메모리 초과 안 났을 문제인데 파이썬이라 틀렸다. 스트릭 11일차 미쳤다 ㄷㄷ 올해 안에 500문제 달성은 할 수 있을 듯?? 오늘 내내 팀원들과 저작권 문제에 대해 이야기했다. 역시 쉽지 않다.. 우리끼리 말해봤자 뭐가 나올 거 같진 않아서 법률…","fields":{"slug":"/2023-08-31/"},"frontmatter":{"date":"2023년 08월 31일 14:08","title":"2023년 08월 31일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 2문제 풀었다. 마지막 문제 재귀 풀이는 진짜 파이썬이라 억까당한 거다... C++ 이었으면 메모리 초과 안 났을 문제인데 파이썬이라 틀렸다. 스트릭 11일차 미쳤다 ㄷㄷ 올해 안에 500문제 달성은 할 수 있을 듯??\n- 오늘 내내 팀원들과 저작권 문제에 대해 이야기했다. 역시 쉽지 않다.. 우리끼리 말해봤자 뭐가 나올 거 같진 않아서 법률 자문을 받기로 했다. 큰 문제는 안 될 것 같지만 혹시 모르는 우리의 불안을 해소하기 위한 비용으로 생각하면 나쁘지 않다.\n\n## 배운 것\n\n- pypy가 파이썬에 비해 속도는 빠르지만 메모리를 더 많이 사용한다고 한다.\n\n## 느낀 것\n\n- 요즘따라 사소한 오해로 발생하는 일이 많은 것 같다. 그렇고보니 스터디 카페에 적혀있는 말이 생각난다. '오늘따라 사는 게 힘들다면 역시 내가 귀여운 탓인가라고 생각하자'... 맞말인 듯 ㅋㅋ\n- 테코톡 준비 언제하지...\n"},{"excerpt":"요구사항 ‘사용자 유치 계획’은 여러분들의 서비스를 어떻게 홍보하고, 사용자를 끌어모을 예정인지 고민해 보신 후에, 해당 계획과 실행 결과를 공유해 주시면 됩니다. 일회성 이벤트 마케팅(쿠폰 등)이 아닌, 유지 가능한 계획을 세워주세요. 단순히 가입한 유저의 숫자가 중요한 것이 아닙니다. 실제 사용자의 경험과 피드백으로 이어지는 게 중요해요! 이전에 작성…","fields":{"slug":"/shook-user-inducement-plan/"},"frontmatter":{"date":"2023년 08월 31일 07:08","title":"실사용자 유치 계획","tags":["shook","레벨4"]},"rawMarkdownBody":"\n## 요구사항\n\n> ‘사용자 유치 계획’은 여러분들의 서비스를 어떻게 홍보하고, 사용자를 끌어모을 예정인지 고민해 보신 후에, 해당 계획과 실행 결과를 공유해 주시면 됩니다.  \n\n- 일회성 이벤트 마케팅(쿠폰 등)이 아닌, 유지 가능한 계획을 세워주세요.  \n- 단순히 가입한 유저의 숫자가 중요한 것이 아닙니다. 실제 사용자의 경험과 피드백으로 이어지는 게 중요해요!  \n- 이전에 작성한 서비스 소개 글을 다시 한번 돌아보며 우리의 핵심 사용자는 누구이며, 그들을 어떻게 만날 수 있을지 고민해 보는 것도 좋겠네요 :)\n\n## 정량적 수치\n\n서비스 가입자 100명\n\n## 언제\n\n- 기한: 23.09.22\n\n## 어디서\n\n- 신곡이 나온 그룹의 팬카페\n- 음악 커뮤니티\n- 트위터\n\t- 어떻게 공유할까\n- 위버스\n\t- 링크 업로드 가능\n\n## 어떻게\n\n### 총공 방식 -> 등록할 사용자 위주의 홍보\n\n#### 변경된 점\n\n- 모든 노래는 뮤비를 기준으로 한다.\n\n#### 그 전에 정해야 하는 것\n\n1. 어떤 아이돌을 타겟할 것인가\n\t1. 최근에 컴백한 아이돌\n\t2. 팬층이 두터운 아이돌\n2. 어떤 노래들을 넣을 것인가\n\t1. 노래 개수\n\t2. 노래 종류\n\t3. 신곡 포함 여부\n3. 얼마나 홍보해야 할까\n\t- 한 사이클은 2일 정도로\n4. 언제부터 홍보해야 할까\n\t- 22일 전까지 아무리 적어도 홍보를 1-cycle은 해야 한다\n5. 어떻게 홍보해야 할까\n\t- 홍보 문구\n\t\t- https://s-hook.com 에서 누구누구의 노래 중에서 가장 좋았던 킬링파트를 수집하고 있더라구요 🥰 저는 누구누구 노래 1:30~1:40 등록해봤습니다 ㅎㅎ 여러분도 한 번 해보세요!! 9월 8일까지 등록할 수 있다고 하네용\n\t- 홍보 위치\n\t\t- 트위터\n\t\t- 위버스\n\t- 홍보 주기\n\t\t- 인당 5개씩?\n\n#### 홍보를 위해 꼭!!!!!!! 필요한 기능들\n\n1. 노래 탐색을 위한 스와이프 가이드?\n\t- 처음 사용하는 사용자는 노래 탐색을 위해 스와이프를 해야 하는지 알 수 없음\n2. 등록 중인 노래 리스트를 5개 미만 캐러셀 => 교체가 필요할 것 같다\n\n#### 홍보를 위해 추가로 구현하면 좋을 선택 기능들\n\n- 각 킬링파트 모집 중인 노래마다 킬링파트 등록 리스트 필요할 듯 (지금까지 등록된 킬링파트들 + 킬링파트에 투표한 수)\n- 아티스트 카테고리 기능\n\t1. 등록을 위한 카테고리인가?\n\t2. 탐색을 위한 카테고리인가?\n- 등록 중인 노래 검색\n\n#### 고민해봐야 할 것들\n\n- 정해진 킬링파트 외에 다른 킬링파트를 투표하고 싶은 사람들은 어떻게 해야 할까\n\t- 일단 소비를 목적으로 할까\n\t- 의외로 새로운 파트를 등록하고 싶어하는 사람들이 많은 듯\n- 현재 모집하는 사용자는 우리 서비스의 무엇을 제공하기 위해 설정된 것인가\n\t- 이미 그 노래는 들었을 것이다. 자신이 아는 부분을 사람들에게 알려주는 ... 그 쪽으로 메리트 갖게 하자\n\t- 팬들이 등록한 노래가 데이터로 쌓이게 되지 않을까요\n- 사용자가 노래를 추가할 수 있도록 검색을 열어둘까?\n- 어느 정도로 정책을 손 댈 것인가\n- 사용자 피드백은 어떻게 받을까\n\t- 새로운 기능 추가는 사용자의 피드백을 기반으로 개선하는 것이 좋을 것 같다\n\n### 탐색할 사용자를 위한 홍보\n\n- BUV GROUND: https://ground.buv.co.kr/\n\t- 홍보 게시판 게시\n- HIPHOPPLAYA: https://hiphopplaya.com/g2/bbs/board.php?bo_table=freetalk\n\t- 자유 게시판\n\n## 사용자 유치 계획\n\n노래 추천이 가능하고, 좋아하는 노래 정보를 공유할 수 있는 커뮤니티에 홍보\n\n### 1. 에브리타임, 네이버 지식인, 오픈 채팅방 등 커뮤니티 홍보\n\n노래 추천 글이나 게시판, 채팅방 같은 커뮤니티에 서비스로 접근할 수 있는 링크를 공유한다. 멜론이나 특정 음원 사이트가 아닌 S-HOOK 서비스에서 노래를 들을 수 있는 url 을 공유하여 홍보할 예정이다.  \n\n### 2. 노래 추천 오픈 채팅방 운영\n\n현재 활성화 되어 있는 오픈 채팅방에서는 보통 유튜브 링크나 카카오 뮤직, 멜론 링크를 사용하는 경우가 많다. 그래서 S-HOOK 의 링크를 공유하여 홍보하기 어려운 오픈 채팅방들도 존재한다.  \n\n일시적이지 않고 지속적으로 S-HOOK 서비스를 중심으로 노래를 공유할 수 있는 창구를 만들기 위해 오픈 채팅방을 운영하여 서비스를 홍보할 예정이다.\n\n### 3. 서비스 홍보를 위한 트위터 계정 봇 운영\n\n인스타그램은 광고를 하지 않으면 일반 사용자의 알고리즘에 노출되기 어렵다. 또한 인스타그램 특성상, S-HOOK을 소개하는 계정이 활성화되기 어려운 부분이 있다.\n\n트위터는 K-POP 팬들뿐만 아니라 음악을 좋아하는 팬들이 많이 존재한다. 계정의 팔로워가 적더라도 게시글 공유가 활발한 트위터의 특성 상, 한 번만 노출이 되어도 더 많은 사용자들에게 노출될 가능성이 높다.\n\n멜론 탑 100 노래들을 제공할 예정이기 때문에, 멜론 차트 순위에 존재하는 노래 킬링파트를 빨리 들을 수 있다는 특징을 강조해서 홍보할 예정이다.\n\n## 지속적인 홍보를 위한 계획\n\n- 팀에서 운영하는 오픈 채팅방, SNS 계정을 사용하여 지속적으로 서비스를 사용자들에게 알린다.\n- 멜론 탑 100 노래를 주기적으로 업데이트하여 최신 인기 노래들의 킬링파트들을 통해 사용자가 노래를 빠르게 접할 수 있도록 한다.\n"},{"excerpt":"문제가 되는 부분 음원 저작권 필요 Youtube 영상 저작권 쟁점 Embed 링크를 공유하는 것이 저작권을 침해하는가? 무슨 저작권을 침해하는가? 음원 저작권? 영상 저작권? 판례에 대한 해석 판례 우리 홈페이지에서 구현된 형태 프레이밍 링크 게재된 링크를 클릭했을 때, 홈페이지 일부가 내 홈페이지 속 프레임 내에서 작동하도록 하는 방식이다. 임베디드 …","fields":{"slug":"/shook-copyright/"},"frontmatter":{"date":"2023년 08월 31일 03:08","title":"S-HOOK 저작권 관련 조사","tags":["shook","레벨4"]},"rawMarkdownBody":"\n## 문제가 되는 부분\n\n- 음원 저작권 필요\n- Youtube 영상 저작권\n\n## 쟁점\n\n### Embed 링크를 공유하는 것이 저작권을 침해하는가?\n\n- 무슨 저작권을 침해하는가?\n\t- 음원 저작권?\n\t- 영상 저작권?\n\n### 판례에 대한 해석\n\n[판례](https://casenote.kr/%EB%8C%80%EB%B2%95%EC%9B%90/2017%EB%8B%A4222757)\n\n## 우리 홈페이지에서 구현된 형태\n\n### 프레이밍 링크\n\n게재된 링크를 클릭했을 때, 홈페이지 일부가 내 홈페이지 속 프레임 내에서 작동하도록 하는 방식이다.\n\n### 임베디드 링크\n\n유튜브나 다른 웹사이트의 영상, 음악 등의 창작물을 내 홈페이지에서 바로 재생할 수 있게 하거나 자동으로 재생될 수 있도록 게재하는 방식\n\n### 주로 말하는 견해\n\n- 법원은 링크를 눌렀을 때 저작권이 있는 페이지로 이동하지 않고 바로 저작물을 볼 수 있는 프레이밍 링크나 임베디드 링크의 경우, 저작권 침해에 해당할 수 있다고 보고 있습니다. 방송사나 크리에이터의 허락을 받지 않고, 쇼핑몰에서 바로 영상이 재생되도록 했다면 김비바 사장님은 저작권을 침해한 것으로 볼 수 있습니다. 만약 직접 임베디드 링크를 하지 않았더라도, 불법으로 동영상이 재생되게 만든 사이트의 링크를 게재했다면 저작권 침해 방조죄가 성립될 수 있습니다. [자료](https://blog.tossbusiness.com/articles/legal2-5)\n- 불법 복제물이거나 저작권 침해물인 것을 알면서도 이런 불법 콘텐츠에 연결되는 링크를 게시하는 것 역시 저작권 침해의 방조범이 될 수 있다. (대법원 2021.9.9. 선고 2017 도 19025 전원합의체판결) [판결](https://casenote.kr/%EB%8C%80%EB%B2%95%EC%9B%90/2017%EB%8F%8419025)\n\n## 판례의 핵심 부분\n\n- 대법원 2017. 9. 7. 선고 2017다222757 판결 손해배상(기) & 서울고등법원 2017. 3. 30. 선고 2016나2087313 판결 손해배상(기) 각공2017상,247 상고     \n\n**판시사항**\n\n갑이 인터넷 사이트를 개설한 후 해외 동영상 공유 사이트에 저작권자인 을 방송사 등의 허락을 받지 않고 게시된 방송 프로그램에 대한 임베디드 링크(embedded link)를 게재하여 이용자들이 무료로 시청할 수 있도록 한 사안에서, 갑의 링크행위는 을 방송사 등의 전송권을 직접 침해하는 행위로는 보기 어려우나, 해외 동영상 공유 사이트 게시자의 공중송신권(전송권) 침해행위에 대한 방조에는 해당한다고 한 사례\n\n**판결**\n\n- 대법원 2021.9.9. 선고 2017 도 19025 전원합의체판결\n\n> (다) 저작권 침해물 링크 사이트에서 침해 게시물에 연결되는 링크를 제공하는 경우 등과 같이, 링크 행위자가 정범이 공중송신권을 침해한다는 사실을 충분히 인식하면서 그러한 침해 게시물 등에 연결되는 링크를 인터넷 사이트에 영리적ㆍ계속적으로 게시하는 등으로 공중의 구성원이 개별적으로 선택한 시간과 장소에서 침해 게시물에 쉽게 접근할 수 있도록 하는 정도의 링크 행위를 한 경우에는 침해 게시물을 공중의 이용에 제공하는 정범의 범죄를 용이하게 하므로 공중송신권 침해의 방조범이 성립한다. 이러한 링크 행위는 정범의 범죄행위가 종료되기 전 단계에서 침해 게시물을 공중의 이용에 제공하는 정범의 범죄 실현과 밀접한 관련이 있고 그 구성요건적 결과 발생의 기회를 현실적으로 증대함으로써 정범의 실행행위를 용이하게 하고 공중송신권이라는 법익의 침해를 강화ㆍ증대하였다고 평가할 수 있다. 링크 행위자에게 방조의 고의와 정범의 고의도 인정할 수 있다.\n\n-> 즉, 침해 게시물을 링크를 통해 제공하면서 공중송신권을 침해한다는 사실을 충분히 인식하고 있으면서도 지속적으로 게시를 유지하는 경우 공중송신권 침해의 방조범이 성립한다.\n\n결론적으로 서비스 내에서 공유하는 것은 침해 게시물이어야 한다.\n\n## 단어\n\n### 공중송신권\n\n저작물을 공중이 수신하거나 접근하게 할 목적으로 무선 또는 유선통신의 방법에 의해 송신하거나 이용에 제공할 수 있는 권리\n\n- 방송권\n\t- 공중송신 중 공중이 동시에 수신하게 할 목적으로 음/영상 또는 음과 영상등을 송신하는 권리를 말한다. 저작자, 저작자 또는 저작재산권자로부터 저작물을 방송할 권리를 양도받은 자 또는 이용허락을 받은 자는 저작물을 방송할 권리를 가진다.\n- 전송권\n- 디지털음성송신권\n\n## 법률 자문 자료 준비\n\n안녕하세요 기업산하 개발교육기관에서 교육받는 개발자들끼리 유튜브 영상을 이용한 서비스를 개발하고 있습니다. 개발 중인 서비스는 영리 목적이 아니며, 수익을 창출할 계획도 존재하지 않습니다. \n\n서비스 링크는 https://s-hook.com 입니다.\n\n저희 서비스에서 유튜브에 업로드된 영상들을 재생하고 있는데, 영상에서 재생되는 음악에 대한 저작권 관련 문제가 있을지 문의드립니다.\n\n현재 개발하고 있는 서비스의 기능 중, 저작권이 우려되는 기능은 서비스 내에서 사용하는 유튜브 영상의 음원 저작권 문제입니다.\n\n[사진]\n- 사용자가 특정 버튼 (유튜브와 관련되지 않은 서비스 자체 버튼) 을 눌러 유튜브 영상의 특정 부분을 5~15초 가량 재생할 수 있습니다. \n- 유튜브의 플레이어 재생 버튼을 눌러 전체 영상을 재생할 수 있습니다.\n- 영상은 사용자가 버튼을 클릭하기 전에는 자동 재생 되지 않습니다.\n\n이때, **유튜브 영상에서 나오는 음악을 저희가 추가적으로 저작권을 확보해야하는 것인지 궁금합니다.**  \n1. 원저작권자 혹은 원저작권자의 허락을 받은 채널에서 업로드한 공식 음악 영상을 저희 서비스에서 재생했을 때, 저작권적으로 문제가 되는 부분이 있는지\n2. 서비스 내에서 공식 영상이 아닌, 음원을 가지고 2차 가공한 (ex. 팬 가사 영상) 영상을 서비스에서 사용하는 경우 저작권적으로 문제 되는 부분이 있는지\n\nPS\n질문과 관련된 서비스의 기능과 배경 지식을 간략하게 전달드리겠습니다.\n\n유튜브에서 제공하는 Embeded Player (임베디드 링크) 를 사용해서 서비스 내에서 영상을 재생하고 있습니다. 즉, 서비스에서 사용하는 영상은 유튜브 영상이라는 것을 사용자가 알 수 있습니다. \n- Embeded Player 는 유튜브가 제공하는 약관에 따라 사용하고 있습니다. Embeded Player 와 관련된 자세한 내용은 [링크] 에서 확인하실 수 있습니다.\n\n## 결론\n\n한국저작권협회에서 우리가 사용하는 영상들에 대한 허가는 따로 받지 않아도 법에 저촉되지 않을 것 같다고 말씀해주셨다. 저작권료를 따로 낼 필요도 없다고 한다! 드디어 홍보를 할 수 있다 ^^"},{"excerpt":"그래프 floyd-warshall-algorithm bellman-ford-algorithm 이진 트리 순회 문제 후위 순회의 끝은 root 이다. 중위 순회와 후위 순회 입력 받아 전위 순회 구하기 분리 집합 사이클 찾기 x와 y 를 union 하려고 하는데, 이미 x와 y 의 부모가 같은 경우 사이클이 존재한다고 할 수 있다.","fields":{"slug":"/algorithm-tips/"},"frontmatter":{"date":"2023년 08월 30일 08:08","title":"알고리즘 Tips","tags":["algorithm"]},"rawMarkdownBody":"\n## 그래프\n\n- [[floyd-warshall-algorithm]]\n- [[bellman-ford-algorithm]]\n\n### 이진 트리 순회 문제\n\n- 후위 순회의 끝은 root 이다.\n- 중위 순회와 후위 순회 입력 받아 전위 순회 구하기\n\n```python\nimport sys\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef find_tree(in_start, in_end, post_start, post_end):\n    if in_start > in_end or post_start > post_end:\n        return\n    root = post_order[post_end]\n    print(root, end=' ')\n    root_index = in_order_index[root]\n    left_size = in_order_index[root] - in_start\n    find_tree(in_start, root_index - 1, post_start, post_start + left_size - 1)\n    find_tree(root_index + 1, in_end, post_start + left_size, post_end - 1)\n\n\nn = int(input())\nin_order = list(map(int, input().split()))\npost_order = list(map(int, input().split()))\nin_order_index = [0] * (n + 1)\nfor i in range(n):\n    in_order_index[in_order[i]] = i\nfind_tree(0, n - 1, 0, n - 1)\n```\n\n## 분리 집합\n\n- 사이클 찾기\n\t- x와 y 를 union 하려고 하는데, 이미 x와 y 의 부모가 같은 경우 사이클이 존재한다고 할 수 있다.\n\n```python\ndef is_cycle(x, y):\n\treturn find(x) == find(y)\n\nfor i in range(m):  \n\ta, b = map(int, input().split()) \n\tif is_cycle(a, b): \n\t\t# 사이클이 존재한다.\n```"},{"excerpt":"LOG 레벨 인터뷰가 있었다. CORS 를 준비를 많이 못해가서 그 부분 답변이 미흡했다. 그 외에는 답변을 잘 한 것 같은데, 좀 더 기술 쪽으로 딥한 질문이 나왔다면 좋았을 것 같다. 배운 것 cors 를 정리했다. 느낀 것","fields":{"slug":"/2023-08-30/"},"frontmatter":{"date":"2023년 08월 30일 04:08","title":"2023년 08월 30일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 레벨 인터뷰가 있었다. CORS 를 준비를 많이 못해가서 그 부분 답변이 미흡했다. 그 외에는 답변을 잘 한 것 같은데, 좀 더 기술 쪽으로 딥한 질문이 나왔다면 좋았을 것 같다.\n\n## 배운 것\n\n- [[cors]] 를 정리했다.\n\n## 느낀 것"},{"excerpt":"LOG 오늘 하려고 목표했던 일은 잘 끝냈는데, 시간 계산을 잘못한 탓인지 6시에 가야하는 약속에 1시간이나 늦어버렸다... 너무너무 미안하기도 하고 하필 비오는 날이라 버스랑 지하철도 밀려서 마음이 너무 안 좋았다. 그에 더해서 (오늘 시간이 많았음에도 불구하고) 레벨인터뷰 준비도 하나도 못하고, 알고리즘도 못 풀고, 질문도 많이 생각 못했다는 생각에 …","fields":{"slug":"/2023-08-29/"},"frontmatter":{"date":"2023년 08월 29일 13:08","title":"2023년 08월 29일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 오늘 하려고 목표했던 일은 잘 끝냈는데, 시간 계산을 잘못한 탓인지 6시에 가야하는 약속에 1시간이나 늦어버렸다... 너무너무 미안하기도 하고 하필 비오는 날이라 버스랑 지하철도 밀려서 마음이 너무 안 좋았다. 그에 더해서 (오늘 시간이 많았음에도 불구하고) 레벨인터뷰 준비도 하나도 못하고, 알고리즘도 못 풀고, 질문도 많이 생각 못했다는 생각에 심란했다. 그게 표정이랑 행동에 드러났는지 걱정도 시키고 😭 미안한 일밖에 생각이 안 나네요 오늘은\n- 머리도 아프다 이제 ㅠㅠㅠㅠ\n\n## 배운 것\n\n- [[level3-level-log]] 관련해서 공부했다. 깊게는 못함..\n\n## 느낀 것\n\n- 주변 사람 걱정시키지 말고 오해할 만한 행동들은 얼른 얼른 정정하자.\n- 오늘 감정 기복은 나도 이해가 안 되네.. something is wrong\n"},{"excerpt":"스플릿 리소스 서비스의 어떤 부분을 개발하시면서 서버가 비즈니스 로직의 리소스를 담당하는 것이 좋을 것 같다는 생각을 하셨나요? 협업 프로젝트를 하다보면 어쩔 수 없이 협업을 할 수 밖에 없는 상황이 생길텐데, 어떻게 리소스를 줄일 수 있을까요? 모니터링 서비스 모니터링에서는 어떤 지표를 모니터링해야 할까요? or 모니터링할 지표를 선택한 기준이 있을까요…","fields":{"slug":"/level3-level-log-questions/"},"frontmatter":{"date":"2023년 08월 29일 10:08","title":"레벨3 레벨인터뷰 질문 정리","tags":["레벨3","우테코"]},"rawMarkdownBody":"\n## 스플릿\n\n### 리소스\n- 서비스의 어떤 부분을 개발하시면서 서버가 비즈니스 로직의 리소스를 담당하는 것이 좋을 것 같다는 생각을 하셨나요?\n\n### 협업\n- 프로젝트를 하다보면 어쩔 수 없이 협업을 할 수 밖에 없는 상황이 생길텐데, 어떻게 리소스를 줄일 수 있을까요?\n\n### 모니터링\n- 서비스 모니터링에서는 어떤 지표를 모니터링해야 할까요?\n\t- or 모니터링할 지표를 선택한 기준이 있을까요?\n### 로깅\n- 로그를 남기기 위해 `println()` 을 사용하지 않고, logback 라이브러리를 사용하신 이유가 있을까요?\n\t- (println 은 I/O operation 이기 때문에 synchronized 가 붙어 있어 상당한 성능 저하가 발생할 수 있다.)\n- 로깅되는 정보는 어떤 것들이 있나요?\n\t- 로깅하시는 각 레벨들이 어떤 의미를 가지고 있는지 알고 계신가요?\n\t- 커스텀 예외들은 개발자가 의도한 예외이기 때문에,  INFO 레벨이 좋을까요, 아니면 WARN 레벨이 좋을까요? \n- S-HOOK 의 로그 전략에 대해 알려주세요.\n- 현재 Request 에 대한 로깅도 진행하고 계신가요?\n\t- Request 에 대한 로깅이 필요할까요? 왜 필요할까요?\n\t- 실패한 Request 도 로깅하는 것이 좋을까요?\n\n### CI & CD\n\n- jenkins 로 넘어가야 할 것 같다고 느끼신 적이 있다면, 이유가 무엇이었을까요? 없다면 어떤 부분에서 github action 이 jenkins 보다 나은 점은 무엇이 있을까요?\n- CI & CD 에 대해 설명해주세요\n\t- CI / CD 를 하는 이유는 무엇이라고 생각하시나요?\n\t- CD 과정에서 어려우셨던 점은 없으셨나요? 어떻게 해결하셨나요?\n- github runner 를 사용했을 때의 단점은 무엇이라고 생각하시나요? \n\n## 로건\n\n### Transactional\n\n### Lock\n\n- 어떤 부분에서 데드락 및 동시성 문제가 있었나요?\n\t- 낙관적 락과 비관적 락에 대해 설명해주세요.\n\t- 기존의 낙관적 락을 적용했을 때는 어떤 문제가 발생할 수 있나요?\n\t- 비관적 락을 적용했을 때의 성능상 문제는 없을까요?\n\t- 낙관적 락과 비관적 락이 스프링에서 어떻게 구현되어 있나요?\n- 반정규화?\n\n### 세션\n\n- 펀잇 팀에서 세션을 사용하셨는데, 세션을 채택하신 이유가 궁금합니다.\n\n## 달리\n\n- CI / CD 란?\n- apache 도 있고, nginx 도 있는데 nginx 를 사용하신 이유가 있으실까요?\n- 어떤 지표를 모니터링하고 계신가요?\n\t- prometheus 와 grafana 가 어떤 서버에 올라가 있나요? \n\t\t- 분리했다면 왜 분리하셨나요? 어떤 부분에서 취약점이 있을까요?\n\t- 서버 부하는 어느 정도 측정되고 있나요?\n\t- prometheus 와 cloudwatch 를 비교했을 때 어떤 부분이 좋을까요?\n- 도커를 사용하셨는데, 도커를 사용하셨을 때의 이점은 무엇인가요?\n\t- 도커를 사용하면 어떤 점이 좋나요?\n- nginx 를 도커로 띄우신 이유는 무엇인가요?\n\n## 서기 - 루쿠\n\n- 서비스에 대해 간단하게 설명해주세요\n- 팀에서 어떤 역할을 하셨나요?\n- 치명적인 버그를 찾고 해결했던 경험이 있으셨나요?\n\t- batch 메서드를 사용하지 않고 deleteByIds 를 사용하여 해결했다.\n- 삭제할 때 영속성 전이는 사용하지 않았나요?\n- HTTPS 에 대해 적어주셨는데, 서비스에 어떻게 적용하셨나요?\n- 인증서는 어떻게 발급하셨나요?\n\t- certbot 을 사용했다. let's encrypt 라는 인증 기관에서 인증서를 발급 받았다.\n- handshake 과정에서 대칭키를 만들어 암호화를 한다고 했는데, 그 부분을 좀 더 자세히 설명해주세요\n- CORS 정책을 적용하신 배경이 무엇인가요?\n- 코드 상에서 어떻게 CORS 정책을 적용하셨나요?\n\t- WebMVCConf, nginx\n- nginx preflight 설정을 어떻게 하셨는지 좀 더 자세히 알려주세요.\n- OAuth 를 사용하셨는데, 왜 카카오의 OAuth 를 사용하셨나요?\n\t- 나이대와 성별을 투표 통계를 통해 알려주고 싶었다. 좀 더 정확한 정보를 받고 싶어 카카오톡을 선택했다.\n\t- 구글 같은 경우 연령대, 성별을 마음대로 입력해도 가입 가능하지만, 카카오의 정보는 좀 더 신뢰성이 있다고 생각했다.\n- OAuth 를 구현할 때 어려웠던 점은 무엇이었나요?\n- OAuth 통신 과정에 대해 설명해주세요.\n- Votogether 라는 프로젝트를 보았을 때, 투표를 해야 해서 동시성 문제가 발생할 수 있을 것 같아요. 어떤 부분을 고려했는지, 어떤 부분이 어려웠는지 듣고 싶습니다.\n\t- 기능 개발에 초점을 맞춰서 동시성 문제는 아직 해결하지 못했다. 프론트 쪽에서 낙관적 업데이트를 통해 처리하고 있다.\n- 현재는 다른 사용자들이 동시에 투표하는 것에 대해서는 대응이 되어 있지 않은 상태인가요?\n- JPA 를 사용하면서 엔티티 연관관계 매핑을 어떤 기준으로 하셨는지 궁금합니다.\n- 그 과정에서 객체지향적인 설계와 DB 패러다임과 충돌되는 경우는 없었나요?\n- 이 프로젝트를 진행하며 겪었던 가장 인상깊었던 에피소드가 있을까요?\n- 회의를 한 뒤에 일을 하는 방식의 변화가 있었나요?\n- 기술적인 부분의 트러블 슈팅을 말해주세요.\n\t- 기술 전파\n- 팀적으로 협업할 때 누구는 기술적으로 많이 아는 사람이 있고, 베이스가 부족한 사람이 있는데, 루쿠는 어디에 포함되어 있다고 생각하셨나요?\n- 기술적으로 뛰어난 크루들과 함께 협업했을 때 아쉬웠던 점이 무엇이었나요?\n- 팀 프로젝트에서 해결해야 하는 과제들이 있는데 고루 분배해서 성장하는 것도 중요합니다. 루쿠가 주도적으로 해결하거나 학습적으로 맡은 부분이 있는지, 그런 부분이 잘 분배되지 않았다면 팀적으로 어떤 노력을 했는지 궁금합니다.\n\n## 옵저버\n\n### 체인저\n\n#### 레벨 학습\n- 발생하는 문제를 여러 가지 형태로 해결했던 경험을 하나하나 말해주는 부분이 좋았다.\n- 질문에서 인정할 부분은 인정하고, 자신만의 의견을 피력하는 모습이 인상 깊었다.\n- 첫 번째, 두 번째와 같이 답변의 순서를 말해주고 답변하는 모습이 좋았다.\n\n#### 인터뷰 / 말하기\n- 시선 처리, 제스처 모두 적당했다. 잘 생각나지 않는 내용은 말의 속도를 늦춰가면서 끊기지 않게 말하는 게 굉장했다.\n\n### 모디\n#### 레벨학습\n- 서비스에서 해당 기술을 사용하게 된 배경과 기술을 통해 어떤 것을 수행했는지 답변 내부에서 명확하게 분리되어 있어서 전달력이 좋았다.\n- 마치 앞에 써져 있는 기술블로그를 읽는 듯한 답변이어서 대단하다고 생각했습니다. 그만큼 문제 상황과 근거가 확실하게 제시되어 있는 답변이라 좋았습니다. \n\n#### 인터뷰 / 말하기\n- 프로젝트에 있었던 경험과 예시를 기반으로 답변하는 방식이 좋았다.\n- 답변에 대한 예시가 조금 길어지는 부분이 있었다. 사람마다 차이가 있을 수 있지만, 개인적으로는 예시를 좀 더 간략하게 제시하면 더 좋을 것 같다."},{"excerpt":"","fields":{"slug":"/2023-08-28/"},"frontmatter":{"date":"2023년 08월 29일 10:08","title":"2023년 08월 28일","tags":null},"rawMarkdownBody":"\n"},{"excerpt":"WS, WAS WS 주로 정적 컨텐츠를 클라이언트에 제공한다. 클라이언트의 요청에 따라 파일을 찾아 그대로 반환한다. Apache, nginx 가 있다. WAS 동적인 컨텐츠를 처리하는 데 필요한 로직을 실행하고 결과를 웹 서버에 전달하여 클라이언트에게 제공하는 역할을 한다. Tomcat, JBoss 가 있다. 웹 서버가 정적인 컨텐츠를 처리하면서 동적 …","fields":{"slug":"/level3-level-log/"},"frontmatter":{"date":"2023년 08월 29일 08:08","title":"레벨3 레벨로그","tags":["레벨로그","레벨3","우테코"]},"rawMarkdownBody":"\n## WS, WAS\n\n- WS\n\t- 주로 정적 컨텐츠를 클라이언트에 제공한다. 클라이언트의 요청에 따라 파일을 찾아 그대로 반환한다.\n\t- Apache, nginx 가 있다.\n- WAS\n\t- 동적인 컨텐츠를 처리하는 데 필요한 로직을 실행하고 결과를 웹 서버에 전달하여 클라이언트에게 제공하는 역할을 한다. \n\t- Tomcat, JBoss 가 있다.\n- 웹 서버가 정적인 컨텐츠를 처리하면서 동적 요청은 WAS 로 전달하는 방식으로 작동한다.\n\n### nginx\n\n- 수 많은 동시 연결을 효율적으로 처리할 수 있다. 제한된 수의 worker process 를 사용하여 수천 개의 동시 연결을 처리할 수 있다.\n- 클라이언트 요청을 실제 서버로 전달하고, 해당 서버의 응답을 클라이언트에게 반환한다.\n- 캐싱\n\t- 백엔드 서버의 응답을 캐시에 저장하고, 후속 요청에 대해 캐시된 데이터를 반환하여 백엔드 서버의 부하를 줄일 수 있다.\n- Reverse proxy\n\t- 서버 측에서 설정되며, 클라이언트의 요청을 받아 내부 서버에 전달하고 응답을 다시 클라이언트에게 반환하는 서버이다. \n\t- 로드밸런싱으로 여러 서버 간의 트래픽을 분산하여 부하를 줄일 수 있다.\n\t- 자주 요청되는 컨텐츠를 캐싱하여 빠른 응답 시간을 제공한다.\n\t- 리버스 프록시에서 SSL/TLS 연결을 종료하고(즉, 암호화를 해제하고), 내부 네트워크로는 암호화되지 않은 연결을 사용할 수 있다. 이를 통해 백엔드 서버에서의 암호화/복호화 처리 부하를 줄일 수 있다.\n\t- 내부 서버의 실제 IP 주소와 구조를 숨길 수 있어, 외부의 악의적인 공격으로부터 보호할 수 있다.\n- Front proxy\n\t- 클라이언트 쪽에서 설정되고, 클라이언트의 요청을 받아 서버로 중계하는 서버이다.\n\t- 특정 웹사이트나 서비스 접근을 차단하거나 허용한다. 데이터 압축 또는 캐싱을 통해 대역폭 사용을 줄인다.\n\n#### Certbot\n\n- 자동 갱신을 위해서는 우분투에 기본 설치되어 있는 `Crontab` 을 사용하여 Cerbot 이 만료되는 주기로 갱신하는 스크립트를 작성하여 실행시켜주면 된다.\n\n### HTTP, HTTPS\n\n두 가지는 모두 데이터를 전송하는 데 사용되는 프로토콜이다. \n\n#### HTTP\n\n- 데이터는 암호화되지 않고 평문으로 전송된다. \n- 인증서가 필요하지 않다.\n- 기본 포트번호가 80이다.\n\n#### HTTPS\n\n- SSL/TLS 인증서가 필요하다. \n\t- SSL (Secure Sockets Layer) 나 TLS (Transport Layer Security) 를 사용하여 암호화되어 전송된다. 이를 통해 데이터의 기밀성과 무결성이 보장된다.\n- 기본 포트번호는 443 이다.\n- 과거에는 HTTPS 가 암호화 / 복호화 과정으로 인해 HTTP 에 비해 성능 저하가 있었으나, 현재는 최적화된 알고리즘과 하드웨어 가속 기술로 차이가 거의 미미한 수준이다.\n- 웹사이트의 보안성을 향상시키기 때문에, 많은 검색엔진들이 HTTPS 를 사용하는 웹사이트에 SEO 가점을 제공한다.\n\n## JPA\n\n- JPA 와 객체지향 - 엔티티 사이의 연관관계\n- OSIV 설정을 꺼 두었을 때, 컨트롤러까지 영속성 컨텍스트가 유지되지 않기 때문에 조회한 엔티티가 영속 상태를 유지하지 않고, 영속성 컨텍스트의 변경 감지도 동작하지 않는다.\n- Entity 생명주기\n\n### 영속성 컨텍스트\n\n인스턴스로 존재하는 엔티티를 관리하고 영속화시키는 논리적 영역\n\n### 생명 주기\n\n- 비영속\n\t- 엔티티가 영속성 컨텍스트와 전혀 관련이 없다.\n- 영속\n\t- 영속성 컨텍스트에서 관리되고 있는 상태이다. DB 에 저장된 상태가 아니다.\n\t- persist 를 사용하여 비영속 엔티티를 영속상태로 만들 수 있다.\n\t- Entity Manager 가 DB에서 조회해온 데이터도 영속 상태인 엔티티가 된다.\n\t- 영속 상태인 같은 엔티티를 조회하면 DB 접근을 하지 않고 1차 캐시 저장소에 있는 엔티티를 반환한다.\n- 준영속\n\t- 영속성 컨텍스트에서 관리되던 엔티티가 영속성 컨텍스트에서 관리되지 않는 것이다.\n\t- 방법\n\t\t- 엔티티 매니저의 `detach()` 사용\n\t\t- 영속성 컨텍스트 전체를 초기화 시키는 `clear()` -> 쿼리문 저장소의 보관된 쿼리들도 모두 초기화된다. 모든 엔티티가 전부 준영속 상태가 된다.\n\t\t- 영속성 컨텍스트 닫는 `close()` 사용\n- 삭제\n\t- 엔티티를 영속성 컨텍스트에서 관리하지 않게 되고, 해당 엔티티를 DB 에서 삭제하는 DELETE 쿼리를 보관한다.\n\n### Dirty Checking\n\n트랜잭션이 끝나는 시점에 최초 조회 상태에서 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영해준다.    \n\n영속성 컨텍스트가 관리하는 엔티티에만 적용된다.    \n\n### OSIV\n\n영속성 컨텍스트를 뷰까지 열어두는 기능이다. 스프링 프레임워크에서는 기본적으로 true 로 설정되어 있다.\n\n켜져있는 경우, 트랜잭션이 끝나도 영속 상태를 유지한다. 이런 경우, 실시간 트래픽이 중요한 애플리케이션에서 커넥션이 모자라서 서비스 장애의 원인이 될 수 있다.\n\n꺼져있는 경우, 트랜잭션이 끝나면 즉시 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다. 커넥션 리소스를 낭비하지 않아 좋지만, 지연 로딩을 모두 트랜잭션 안에서 처리해야 한다는 단점이 있다.\n\n동일한 트랜잭션을 사용하는 경우, 항상 같은 영속성 컨텍스트를 사용하게끔 구현되어 있다. 다른 트랜잭션은 다른 영속성 컨텍스트를 사용한다.\n\n만약 서버 사이드 렌더링을 수행하는 경우 문제가 될 수 있다.     \n조회한 엔티티와 연관된 엔티티를 함께 사용해야 한다. 연관 엔티티는 지연 로딩으로 설정되었다고 가정하자.     \n이때, 조회된 엔티티는 프록시 객체로 Presentation layer 에 반환된 상태이다.     \n결론적으로 실제 데이터를 불러오려고 초기화를 시도할 때 지연 로딩이 작동하지 않아 예외가 발생한다. \n\n#### 문제점\n\n- Presentation Layer 가 엔티티를 변경할 수 있다. OSIV 설정이 켜진 상태에서는 변경 감지가 작동하므로, 변경된 값이 바로 DB 에 반영되어 버릴 수 있다는 것이다. \n- 트랜잭션 롤백 시 주의해야 한다.\n- Presentation Layer 에서 엔티티가 변경되고 난 후, 비즈니스 로직을 실행하면 실제 엔티티가 수정될 수 있다.\n\n#### 스프링의 OSIV\n\n스프링 프레임워크가 제공하는 OSIV 는 비즈니스 계층에서 트랜잭션을 사용하는 OSIV 이다.     \n\n1. 요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 생성한다. (트랜잭션은 시작하지 않는다.)\n2. 서비스 계층에서 트랜잭션을 시작할 때, 1번에서 미리 생성해 둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.\n3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 영속성 컨텍스트는 종료되지 않는다.\n4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 '유지' 한다.\n5. 서블릿 필터나 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때, 플러시를 호출하지 않고 바로 종료한다.\n\n#### 트랜잭션 없이 읽기\n\n영속성 컨텍스트를 통한 모든 변경은 트랜잭션 안에서 이루어져야 한다.    \n그러나 단순 조회는 트랜잭션 없이도 가능하다.\n\n#### 그래서?\n\n- admin 페이지 같이 실시간 트래픽이 중요하지 않은 경우 OSIV 를 사용해도 괜찮다.\n- command 와 query 를 분리하는 것이 좋다.\n\t- 명령 (command) 서비스, 조회 (query) 서비스를 분리한다. Query Service 에서는 DTO projection 을 사용한다.\n\n### DTO Projection\n\n엔티티 대신에 DTO 를 편리하게 조회할 때 사용한다.     \n엔티티의 일부 속성만 가져오고 싶을 때 사용할 수 있다.      \nJoin 한 모든 내용 대신, 노래와 전체 좋아요만 가져오려고 사용했다.\n\n#### 인터페이스 기반 Projection\n\n구현 객체는 JPA 가 프록시로 만들어준다.\n\nprojection 된 결과 객체는 영속성이 유지되지 않는다.\n\n#### 클래스 기반 Projection\n\n생성자의 파라미터 이름으로 Projection 이 동작한다.\n쿼리에 패키지 이름까지 다 써줘야 한다.\n\n#### Open Projection\n\n인터페이스에 정의된 메서드에 대한 구체적인 구현을 제공할 수 있다.    \n개발자가 원하는 로직에 따라 값을 반환하게 된다.\n\n#### Closed Projection\n\n인터페이스에 정의된 메서드만 사용되며, 엔티티의 특정 속성에 직접 매핑된다.\n\n#### 주의\n\nprojection 을 사용하면 기존 설정을 무시하고 eager loading 을 하는 듯하다.\n\n## CORS\n\n- 다른 origin 끼리 리소스를 공유하게 할 수 있다. SOP 정책으로 동일하지 않은 다른 출처의 스크립트가 실행되지 않도록 브라우저에서 사전에 방지한다.\n- Preflight Request\n- Credentialed Request\n\n### CORS 설정\n\n- nginx 에서 설정\n\t- METHOD 이름이 OPTION 인 경우 허용한다.\n\n## JWT\n\n인증에 필요한 정보들을 JSON 으로 표현한 데이터 토큰이다.    \n토큰 자체가 서명되어 있고, 인증에 필요한 정보들을 지니고 있다.   \n\n### 구조\n\n- Header\n\t- 토큰의 타입, 서명에 사용된 알고리즘에 대한 정보가 담겨 있다.    \n\t- 우리 서비스에서는 HS256 을 사용했다.\n- Payload\n\t- 토큰을 통해 제공되는 데이터들이 key-value 형태로 들어가 있다.\n\t- iat : 해당 토큰이 발급된 시간\n\t- exp: 해당 토큰의 만료 시간\n\t- 토큰의 발급 대상, 토큰 제목, 토큰의 활성화 날짜, 토큰 발급자, 토큰 식별자 등이 있다. \n- Signature\n\t- 서명에 대한 정보이다. 헤더와 페이로드를 인코딩한 값을 합치고 특정 알고리즘과 특정 키로 암호화되어 있는 값이다.    \n\t- 헤더와 페이로드는 Base64 로 인코딩 되어 있는 값이므로 시그니쳐를 추가하여 위변조를 판별한다.\n\n### 암호화 방식\n비대칭 암호 방식을 이용해서 암호화한다.    \n\n### 세션과 비교\n세션 방식은 브라우저와 웹 서버가 연결되어 브라우저가 종료될 때까지의 시점이다.    \n클라이언트는 요청시 쿠키에 세션 아이디를 저장해서 보내고, 서버는 전달받은 세션 아이디로 DB 에서 세션을 조회한다.    \n\n#### 세션 장점\n- 세션 아이디가 탈취되더라도 DB 에 저장된 세션을 삭제하면 된다.\n- 쿠키에 아무런 의미가 없는 세션 ID 가 저장되므로, 탈취되더라도 해석할 수 없다.\n\n#### 세션 단점\n- 매 요청 시마다 세션 저장소를 조회해야 하는 단점이 존재한다.\n- 서버에 세션 객체를 저장하므로 사용자가 다수일 경우 부하가 높아진다.\n- scale out 시 모든 서버가 접근할 수 있도록 별도의 중앙 세션 관리 시스템이 필요하다.\n- 서버가 추가될 경우, 각 서버마다 세션 정보가 저장되므로 확장성이 좋지 않다.\n\n#### JWT 장점\n- JWT 가 이미 인증된 정보이므로, 이를 저장하기 위한 저장소가 필요하지 않다. \n- 서버에서 클라이언트 상태를 저장할 필요가 없다.\n- 서버 측 부하를 낮출 수 있다.\n\n#### JWT 단점\n- 토큰을 강제로 만료시킬 방법이 없다.\n- 페이로드에 민감한 정보를 담기 어렵다.\n- 토큰이 쿠키나 로컬스토리지 등에 저장되므로 탈취당할 위험이 존재한다.\n\n### Refresh Token\n\nAccess Token 의 유효기간을 짧게 해서 보안을 강화하면서도, 사용자가 자주 로그인하지 않도록 하기 위해서 등장했다.     \n\n#### Refresh Token 이 탈취된다면, 대비하는 방법\n\n- RTR : Refresh Token 을 한 번만 사용할 수 있도록 한다. 새로운 Access Token 을 발급받을 때마다 Refresh Token 도 새롭게 발급한다. 이미 사용된 Refresh Token 임을 검사해서 서비스 측에서 탈취를 확인할 수도 있다.\n\n보안적 측면에서 DB 에 저장하고, RTR 과 같은 방법으로 안전하게 관리하는 것이 좋다.     \n\n"},{"excerpt":"LOG 알고리즘 3문제 풀었다. 처음으로 백준 스트릭 7일 넘겼다..ㅋㅋㅋ 용우, 세진과 설입에서 점심 먹었다. 동기들 또 오랜만에 만나니까 재밌었다. 내년에 학교 갔을 때도 아는 동기들 많았으면 좋겠다. 배운 것 lis 내용을 보강했다. 파이썬에서는 이분 탐색으로 LIS 배열을 어떻게 구하는지 공부했다. 느낀 것 아직은 언제까지 집중해야 지치지 않는지 …","fields":{"slug":"/2023-08-27/"},"frontmatter":{"date":"2023년 08월 27일 09:08","title":"2023년 08월 27일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 3문제 풀었다. 처음으로 백준 스트릭 7일 넘겼다..ㅋㅋㅋ\n- 용우, 세진과 설입에서 점심 먹었다. 동기들 또 오랜만에 만나니까 재밌었다. 내년에 학교 갔을 때도 아는 동기들 많았으면 좋겠다.\n\n## 배운 것\n\n- [[lis]] 내용을 보강했다. 파이썬에서는 이분 탐색으로 LIS 배열을 어떻게 구하는지 공부했다.\n\n## 느낀 것\n\n- 아직은 언제까지 집중해야 지치지 않는지 모르겠다. 오늘도 알고리즘 풀다가 완전히 지쳐버려서 힘들었다. 내일부터는 뽀모도로 공부법을 도입해봐야지\n- 나는 지금 주체적인 삶을 살고 있나? 정말로 내 인생에서 내가 주인공일 수 있을까? 나는 주변의 행동, 말투, 이야기에 내가 너무나도 쉽게 흔들린다는 걸 알고 있다. 내가 믿었던 것에 의심을 가지지 않는 방법도 잘 모르겠다. 이런 건 고쳐야 하는 걸까?\n- 여전한 것 같다가도, 또 아닌 것 같다가도, 다시 이런 생각을 한다. 나는 아직 약한 사람이다. 그래도 예전보다는 솔직하다. 지금은 그 사실에 만족하자. 내일은 오늘보다 더 나아가자."},{"excerpt":"LOG 점심으로 바싹 불고기를 먹었는데 맛있었다. 채그로에 가서 알고리즘을 풀었다. 카페도 크고 공부할 곳도 많아서 좋았다. 새로 산 펜이 너무 마음에 든다. 부드럽게 잘 써져서 좋다. 배운 것 느낀 것 평소보다 많이 먹지는 못하고 있다. 식사할 때 갑자기 물이 마시고 싶어져서 계속 마시게 되는데, 그러다 보니 배를 채우지는 못하고 있다. 내 못난 행동을…","fields":{"slug":"/2023-08-25/"},"frontmatter":{"date":"2023년 08월 25일 05:08","title":"2023년 08월 25일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 점심으로 바싹 불고기를 먹었는데 맛있었다.\n- 채그로에 가서 알고리즘을 풀었다. 카페도 크고 공부할 곳도 많아서 좋았다. \n- 새로 산 펜이 너무 마음에 든다. 부드럽게 잘 써져서 좋다.\n\n## 배운 것\n\n## 느낀 것\n\n- 평소보다 많이 먹지는 못하고 있다. 식사할 때 갑자기 물이 마시고 싶어져서 계속 마시게 되는데, 그러다 보니 배를 채우지는 못하고 있다.\n- 내 못난 행동을 경계하자."},{"excerpt":"플로이드-워셜 알고리즘 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구할 수 있는 알고리즘이다. (ㄷㄷ) 플로이드-워셜 알고리즘은 단계마다 '거쳐 가는 노드' 를 기준으로 알고리즘을 수행한다. 또한 정점의 개수가 V일 때, V 번 만큼의 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 DP 라고 볼 수 있다. 점화식은 다음과 같다.…","fields":{"slug":"/floyd-warshall-algorithm/"},"frontmatter":{"date":"2023년 08월 24일 07:08","title":"플로이드-워셜 알고리즘","tags":["algorithm","graph"]},"rawMarkdownBody":"\n## 플로이드-워셜 알고리즘\n\n모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구할 수 있는 알고리즘이다. (ㄷㄷ)    \n플로이드-워셜 알고리즘은 단계마다 '거쳐 가는 노드' 를 기준으로 알고리즘을 수행한다.     \n\n또한 정점의 개수가 V일 때, V 번 만큼의 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 DP 라고 볼 수 있다.     \n\n점화식은 다음과 같다.     \n\n![[floyd-warshall-dp.png]]\n\n즉, 기존에 저장된 거리보다 a 에서 k 로 가는 거리 + k 에서 b 로 가는 거리가 더 짧으면 갱신한다는 뜻이다.     \n\n## 수행 과정\n\n1. 주어진 그래프에 맞게 최단 거리 테이블을 갱신해둔다. \n2. 1 ~ N 번 정점을 거쳐가는 경우를 고려하여 테이블을 갱신한다. \n\n## 코드\n\n```python\ndef floyd_warshall(n, dist):  \n    for i in range(1, n + 1):  \n        for a in range(1, n + 1):  \n            for b in range(1, n + 1):  \n                dist[a][b] = min(dist[a][b], dist[a][i] + dist[i][b])\n```\n\n## 주의할 점\n\n정점의 개수가 V 일 때, V 번의 단계를 수행하면서 단계마다 O(V^2) 의 연산을 수행하여 현재 정점을 거쳐가는 모든 경로를 고려한다.     \n\n따라서 시간 복잡도가 O(V^3) 이므로 정점의 개수 값이 작을 경우에만 사용해야 한다.     "},{"excerpt":"벨만-포드 알고리즘 한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘이다. 다익스트라 알고리즘과는 달리, 간선의 가중치가 음수일 때도 최단 거리를 구할 수 있다. 정점 - 1 번의 매 단계마다 모든 간선을 전부 확인하면서 모든 노드간의 최단 거리를 구한다. 언제나 다익스트라 알고리즘에서의 최적의 해를 포함하게 된다. 시간복잡도는 O(VE) 로 느리…","fields":{"slug":"/bellman-ford-algorithm/"},"frontmatter":{"date":"2023년 08월 24일 07:08","title":"벨만-포드 알고리즘 정리","tags":["algorithm","graph"]},"rawMarkdownBody":"\n## 벨만-포드 알고리즘\n\n한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘이다.    \n다익스트라 알고리즘과는 달리, 간선의 가중치가 음수일 때도 최단 거리를 구할 수 있다.     \n\n정점 - 1 번의 매 단계마다 모든 간선을 전부 확인하면서 모든 노드간의 최단 거리를 구한다.     \n언제나 다익스트라 알고리즘에서의 최적의 해를 포함하게 된다.\n\n시간복잡도는 O(VE) 로 느리다.    \n\n### 다익스트라 알고리즘\n\n방문하지 않은 노드들 중에서 현재 노드에서 최단 거리가 가장 짧은 노드를 선택하여 한 단계씩 최단 거리를 구한다.    \n\nPQ 를 사용한 개선된 다익스트라 알고리즘을 사용했을 때 시간 복잡도는 O(E log V) 이다.     \n\n## 수행 과정\n\n1. 출발 노드를 설정한다.\n2. 출발 노드의 최단 거리 테이블을 초기화한다.\n3. 다음의 과정을 (정점의 개수 - 1) 만큼 반복한다.\n\t1. 모든 간선 E 개를 하나씩 확인한다.\n\t2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.\n\n음수 간선 사이클이 존재하는지 확인하기 위해서는 3번 과정을 한 번 더 수행하여, 최단 거리 테이블이 갱신되는 경우 음수 간선 사이클이 존재한다고 판단할 수 있다.      \n\n> 어떻게 음수 간선 사이클이 존재한다고 판단할 수 있을까?\n\n사이클이 존재하는 경우, 사이클을 계속해서 돌면서 사이클 내부의 노드에서 다른 노드로 가는 비용을 무한히 줄일 수 있다.      \n원래는 3번의 과정을 마쳤을 때, 모든 노드를 확인하여 최단 거리가 확정되었기 때문에 더 이상 값이 변경되지 않는다.\n\n## 코드\n\nBOJ 11657 의 정답과 동일하다.\n\n```python\nimport sys  \n  \ninput = sys.stdin.readline  \nINF = float('inf')  \n  \nn, m = map(int, input().strip().split())  \ngraph = list()  \n  \nfor _ in range(m):  \n    a, b, cost = map(int, input().strip().split())  \n    graph.append((a, b, cost))  \n  \n  \ndef bellman_ford(start):  \n    dist = [INF] * (n + 1)  \n    dist[start] = 0  \n    for i in range(n):  \n        for start, next_node, cost in graph:  \n            if dist[start] != INF and dist[next_node] > dist[start] + cost:  \n                if i == n - 1:  \n                    return -1  \n                dist[next_node] = dist[start] + cost  \n    return dist  \n  \n  \nresult = bellman_ford(1)  \nif result == -1:  \n    print(-1)  \nelse:  \n    for i in range(2, n + 1):  \n        print(result[i] if result[i] != INF else -1)\n```\n\n## 주의할 점\n\n벨만-포드 알고리즘은 |V| - 1 만큼 순회하므로 O(V), 매번 O(E) 만큼 탐색하므로 O(|V||E|) 가 된다.    \n\n그런데 밀집 그래프의 경우 E 는 V^2 에 가까워지므로, 최악의 경우 O(V^3) 이 된다. \n(밀집 그래프는 간선의 수가 최대 간선의 수에 가까운 그래프를 말한다.)\n\n다익스트라 알고리즘에 비해 시간 복잡도가 높으므로, 벨만-포드 알고리즘은 간선의 가중치에 음수가 존재할 경우에만 채택하는 것이 좋다.     "},{"excerpt":"LOG TIL 을 일주일 간 못 썼다. 레벨3 때는 바빠서 못 썼고, 방학 되어서는 공부하고 노느라 못 썼다. 이제 다시 열심히 써볼까 한다. 알고리즘 5문제 풀었다. 목표는 이번 달 안에 플레5 찍기 알고리즘 풀려고 샀던 펜을 다 썼다. 영풍문고에 가서 펜을 두 개나 샀다. 더 열심히 해서 또 펜을 사고 싶다. 배운 것 bellman-ford-algor…","fields":{"slug":"/2023-08-24/"},"frontmatter":{"date":"2023년 08월 24일 07:08","title":"2023년 08월 24일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- TIL 을 일주일 간 못 썼다. 레벨3 때는 바빠서 못 썼고, 방학 되어서는 공부하고 노느라 못 썼다. 이제 다시 열심히 써볼까 한다.\n- 알고리즘 5문제 풀었다. 목표는 이번 달 안에 플레5 찍기\n- 알고리즘 풀려고 샀던 펜을 다 썼다. 영풍문고에 가서 펜을 두 개나 샀다. 더 열심히 해서 또 펜을 사고 싶다.\n\n## 배운 것\n\n- [[bellman-ford-algorithm]] 에 대해 공부했다.\n- [[floyd-warshall-algorithm]] 에 대해 공부했다.\n\n## 느낀 것\n\n- 집중력이 좋아지고, 한 문제에 싫증내지 않고 계속해서 집중할 수 있게 되니 알고리즘 푸는 게 재밌다. 나도 끈기있게 할 수 있는 사람이었군 신기하다\n- 벌써 4일차 스트릭! 스트릭도 계속해서 유지해보자. 최대 6일인데..ㅋㅋㅋ 이번에야말로 스트릭 갱신을 위해 파이팅\n- 2023년 안에 코테 볼 수 있는 수준으로 알고리즘 실력 끌어올리기. 아자아자"},{"excerpt":"Monitor Lock 과 synchronized Java 의 synchronized 키워드가 동기화를 제공하는 방법인 Monitor Lock 에 대해 알아본다. 또한 Monitor Lock 이 사용되는 이유와 어떤 경우에 사용되면 좋은지 알아본다. Lock 왜 사용할까? critical section 에 대해 상호 배제 (mutual exclusion)…","fields":{"slug":"/java-synchoronized/"},"frontmatter":{"date":"2023년 08월 21일 07:08","title":"모니터와 synchronized","tags":["java"]},"rawMarkdownBody":"\nMonitor Lock 과 synchronized\n\nJava 의 synchronized 키워드가 동기화를 제공하는 방법인 Monitor Lock 에 대해 알아본다. 또한 Monitor Lock 이 사용되는 이유와 어떤 경우에 사용되면 좋은지 알아본다.\n\n## Lock\n\n### 왜 사용할까?\n\n1. critical section 에 대해 상호 배제 (mutual exclusion) 을 제공한다. 공유 데이터를 한 스레드만 접근할 수 있도록 제한하는 것을 의미한다.\n2. 스레드 간의 협업 또는 동기화의 역할을 수행한다. 어떤 작업을 완료하거나 특정 상태에 도달하는 경우 다른 스레드에 알려주어 해당 스레드가 동작할 수 있도록 한다.\n\n\n\n## Intrinsic Locks\n\nSynchronization (동기화) 은 내장 락, 모니터 락이라고 알려진 내부 엔티티를 중심으로 구축된다.\n\n## 동시성\n\n프로그램, 알고리즘, 또는 문제의 여러 부분이나 단위를 결과에 영향을 주지 않고 순서 없이 또는 부분적으로 실행할 수 있는 기능\n\nhttps://en.wikipedia.org/wiki/Concurrency_(computer_science)\n\n### Read-Modify-Write 패턴\n\n## 참고\n\n- https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html\n- https://backtony.github.io/java/2022-05-04-java-50/\n- http://happinessoncode.com/2017/10/04/java-intrinsic-lock/\n- https://www.baeldung.com/java-synchronized"},{"excerpt":"","fields":{"slug":"/why-string-is-final/"},"frontmatter":{"date":"2023년 08월 21일 05:08","title":"왜 Java 에서 String 은 불변인가?","tags":["java","string"]},"rawMarkdownBody":"\n"},{"excerpt":"과정 회고 중... 새로운 기술을 적극적으로 도입하고, 팀원들을 설득하는 과정이 많은 공부가 되었습니다.\n팀원들의 방식대로 개발을 하게 되면서, 지금까지 해오던 방식과 다른 방식으로 개발하게 되었습니다. 팀에서 정한 방식과 내가 정한 방식의 장단을 비교할 수 있었던 것이 성장에 도움이 되었습니다.\n내 의견만 밀고 나가는 것만이 정답이 아님을 알게 되었습니…","fields":{"slug":"/level3-launching-festival-retrospect/"},"frontmatter":{"date":"2023년 08월 19일 03:08","title":"론칭 페스티벌 회고","tags":["레벨3","우테코","shook","회고"]},"rawMarkdownBody":"\n## 과정 회고 중...\n\n새로운 기술을 적극적으로 도입하고, 팀원들을 설득하는 과정이 많은 공부가 되었습니다.\n팀원들의 방식대로 개발을 하게 되면서, 지금까지 해오던 방식과 다른 방식으로 개발하게 되었습니다. 팀에서 정한 방식과 내가 정한 방식의 장단을 비교할 수 있었던 것이 성장에 도움이 되었습니다.\n내 의견만 밀고 나가는 것만이 정답이 아님을 알게 되었습니다. 팀원들과 충분히 상의하고, 프로젝트 주제에 대한 싱크를 맞춘 후에 프로젝트를 진행하는 것이 얼마나 중요한 일인지 알게 되었습니다.\n데드라인이 2주 정도로 맞춰져 있어 일정에 맞춰 개발할 수 있게 되었습니다."},{"excerpt":"LOG 팀원들은 밤샘을 한다... 마음만은 함께야 다들 파이팅 배운 것 swagger API 문서를 열려면 swagger 의 css, js 파일이 필요한데,  의 정적 파일에 접근할 때 root 만 접근할 수 있기 때문에 ubuntu 로 접근하면 권한 문제가 발생한다. ubuntu 에도 권한을 부여해주면 접근할 수 있다!!! 궁금한 것 느낀 것","fields":{"slug":"/2023-08-17/"},"frontmatter":{"date":"2023년 08월 17일 09:08","title":"2023년 08월 17일","tags":null},"rawMarkdownBody":"## LOG\n\n- 팀원들은 밤샘을 한다... 마음만은 함께야 다들 파이팅\n\n## 배운 것\n\n- swagger API 문서를 열려면 swagger 의 css, js 파일이 필요한데, `/var/nginx` 의 정적 파일에 접근할 때 root 만 접근할 수 있기 때문에 ubuntu 로 접근하면 권한 문제가 발생한다. ubuntu 에도 권한을 부여해주면 접근할 수 있다!!!\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"문제 상황","fields":{"slug":"/swagger-trouble-shooting/"},"frontmatter":{"date":"2023년 08월 17일 04:08","title":"swagger 경로 설정 오류","tags":["shook","레벨3","trouble-shooting"]},"rawMarkdownBody":"\n## 문제 상황\n\n\n\n![[swagger-fail-load.png]]"},{"excerpt":"상황 설명 S-HOOK 은 로그인 된 회원만 투표, 좋아요, 댓글 활동을 할 수 있습니다. 그러려면 인증/인가 로직이 필수적으로 필요합니다. 해당 사용자가 우리 회원인지 확인하고, 회원인 경우에만 투표 / 좋아요 / 댓글 기능을 쓸 수 있게 만들어야 하기 때문이죠. 이를 위해 OAuth + JWT 인증 로직을 도입했는데요, JWT 를 통해 클라이언트로 전…","fields":{"slug":"/interceptor-argument-resolver-authenticated/"},"frontmatter":{"date":"2023년 08월 16일 01:08","title":"Interceptor 나 Argument Resolver 에서 member를 조회해서 컨트롤러로 전달해주면 안 되나?","tags":["spring","interceptor","argument-resolver","shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 상황 설명\n\nS-HOOK 은 로그인 된 회원만 투표, 좋아요, 댓글 활동을 할 수 있습니다.     \n그러려면 인증/인가 로직이 필수적으로 필요합니다. 해당 사용자가 우리 회원인지 확인하고, 회원인 경우에만 투표 / 좋아요 / 댓글 기능을 쓸 수 있게 만들어야 하기 때문이죠.      \n\n이를 위해 OAuth + JWT 인증 로직을 도입했는데요, JWT 를 통해 클라이언트로 전달되는 값은 회원의 id 값입니다.      \n\n현재 s-hook 의 코드에서는 interceptor 단에서 따로 id를 통해 member 가 존재하는지 조회하지 않습니다. 토큰이 유효하기만 한다면 그대로 파싱된 id 를 argument resolver 로 전달하는 로직입니다.     \n\n이런 인증 과정에 대해 들었던 개인적인 의문과 이에 답할 수 있는 여러 의견들을 정리해보았습니다.\n\n## 의문이 들었던 부분들\n\n### 회원의 id 를 interceptor 에서 검증하지 않아도 될까?\n\n가장 먼저 의문이 들었던 부분은 `JWT 내부에 들어있는 회원의 id 값을 검증하지 않아도 될까?`  라는 것입니다.     \n\n토큰 내부에 있는 id 가 데이터베이스에 존재하지 않는 member 라면 문제가 발생할 수도 있지 않을까요? \n#### JWT\n\n결론만 말하자면, 저희 서비스에서 사용하는 JWT 에서는 토큰 내부에 있는 값을 검증할 '필요가 없습니다'\n\n그 이유는 JWT 의 목적에 있습니다.     \n\nJWT 는 데이터를 암호화하기 위함이 아닌, 데이터의 무결성을 보장하기 위한 목적으로 설계 되었습니다. 즉, 데이터가 변조되지 않았다는 것만을 확인하기 위한 것입니다.     \n\n또한 JWT 는 사용자 인증 후에 '서버' 로부터 발급받는 것이므로, 토큰이 발급되는 시점에서 사용자는 이미 검증되었다고 간주합니다.    \n\n따라서 토큰이 유효하고, 변조되지 않았고, 토큰이 만료되지 않았다면 토큰 내부의 데이터는 신뢰할 수 있다고 볼 수 있습니다. 물론 JWT 를 생성할 때 필요한 secret key 는 반드시 외부에 노출되지 않았어야 하겠지요.\n\n#### JWT 인증 과정\n\nJWT 의 인증을 위해서는 다음과 같은 과정을 수행해야 합니다.     \n\n1. 토큰의 서명 확인\n2. 유효 기간 확인\n3. 토큰 발급자 확인\n4. 토큰 수신자 확인\n5. 토큰 고유 식별자 확인\n\n이런 인증 과정을 모두 통과한 JWT 는 우리 서버에서 발급한 토큰이라고 간주되어, 내부의 데이터를 신뢰할 수 있습니다.     \n\n무엇보다 JWT 를 사용하는 주된 이유는 인증 후에 사용자의 상태나 세션 정보를 저장하지 않고, 서버에서 stateless 하게 시스템을 운영하기 위해서입니다. \n\n즉, 매 요청마다 사용자의 ID 와 비밀번호를 검증하는 것을 피하기 위해 JWT 를 사용하는 것이죠.\n\n### 사용자의 ID 는 민감한 정보가 아닐까?\n\nJWT 를 생성할 때 중요하게 고려해야 하는 사항이 있습니다. JWT 는 암호화를 하는 것이 아니기 때문에 내부의 데이터가 민감한 정보인 경우, 불특정 다수에게 정보가 노출될 수 있습니다.    \n\n그러므로 S-HOOK 서버에서 발행한 JWT 내부에 들어가는 사용자의 ID 는 민감한 정보가 아니어야 합니다.     \n\n그렇다면 사용자 ID 는 민감한 정보가 아닐까요?\n마찬가지로 '저희 서비스에서는' YES 입니다.    \n\nS-HOOK 은 사용자 ID 만으로 수행할 수 있는 요청은 존재하지 않습니다. ID 를 가지고 서버 시스템 내부를 조작하거나 특정 행동을 수행할 수는 없습니다.     \n\n또한 대개의 경우, 사용자 ID 는 민감한 정보로 간주되지 않는다고 합니다. 사용자 ID 를 JWT 페이로드에 포함하는 것이 관행일 만큼 말이죠.     \n\n### 컨트롤러 메서드 파라미터에 Member 객체를 넘겨주면 안 될까?\n\nJWT 내부의 ID 를 검증하지 않아도 되는 건 이제 알겠습니다.     \n\n그렇다면 컨트롤러 메서드 파라미터로 Member id 를 전달하는 대신, Member 를 만들어서 보내주면 안 되는 걸까요?     \n\n현재 인증 로직에서는 Member 가 필요한 각 서비스마다 `MemberService` 를 주입 받아 id 로 Member 를 조회하는 중복 코드가 존재합니다. Interceptor 나 Argument Resolver 가 대신 `MemberService` 를 주입 받아서 Member 를 만들어준다면 중복 코드도 없어지고 좋지 않을까요?\n\n#### 계층적 관점으로 보았을 때 괜찮을까?\n\n먼저 계층적 관점에서 살펴보겠습니다.     \nInterceptor 와 Argument Resolver 에서 Member 를 조회해도 '괜찮은 걸까요'?\n\nS-HOOK 의 코드는 Layered Architecture 를 기반으로 설계되었습니다.     \n\n계층적 구조를 따르면 각 계층마다 명확한 책임을 가지고 있어서, 기능과 역할을 더 쉽게 관리할 수 있습니다.    \n또한 각 계층을 독립적으로 개발 / 테스트할 수 있어 단위 테스트가 용이합니다.    \n특히 특정 계층의 구현이 변경되어도 다른 계층에 비교적 적은 영향을 미칩니다. 이를 통해 유지보수와 확장성을 향상시킬 수 있습니다.     \n\n그렇다면 Argument Resolver / Interceptor 에서 Member 를 조회하면 계층적 구조를 위반해서 문제가 발생할까요?     \n\n엄밀히 말하면 계층적 구조를 위반한다고도 볼 수 있습니다. Interceptor 와 Argument Resolver 는 Web Layer 에 속한다고 생각한다면, Application Layer 에 속하는 `MemberService` 에 접근하는 것은 Presentation Layer 를 거치지 않아 규칙을 위반한 것이기 때문이죠.\n\n그러나 실용적으로 생각했을 때, 횡단 관심사인 `Member` 의 조회를 Interceptor 나 Argument Resolver 에서 수행하는 것은 효율적이고 편리한 접근 방식입니다.      \n\n다만 아래와 같은 문제점이 발생할 수 있다는 것은 인지해야 합니다.     \n\n1. 테스트가 복잡하다.\n도메인 객체가 Argument Resolver / Interceptor 를 통해 전달되는 경우, 컨트롤러의 단위 테스트를 작성할 때 코드가 복잡해질 수 있습니다.     \n\n2. 코드의 유연성이 떨어질 수 있다.\n도메인 객체의 조회 로직이나 생성 방식이 변경되는 경우 Argument Resolver / Interceptor 로 영향이 전파될 수 있습니다.\n\n문제점을 충분히 이해했고 감안할 수 있는 부분이라고 생각된다면, 다음으로 넘어가 봅시다!\n\n#### 도메인 객체가 Presentation 계층에 노출되었을 때 문제점은 없을까?\n\nArgument Resolver 나 Interceptor 에서 Member 를 조회한다면, 컨트롤러 메서드 파라미터로 Member 객체가 전달됩니다.     \n이로써 비즈니스 로직이 포함된 도메인 객체가 Presentation 계층에 노출되었다고 볼 수 있습니다. 이럴 때 발생할 수 있는 문제점은 없을까요?\n\n**문제점**\n\n1. 도메인과 컨트롤러의 결합도가 증가합니다.\n도메인 객체에 변경이 발생한 경우, Presentation Layer 에도 영향을 줄 수 있으므로 시스템의 결합도가 높아진다고 볼 수 있습니다.     \n\n2. 비즈니스 로직의 흐름을 파악하기 어려울 수 있습니다.\n서비스가 직접적으로 인증 / 인가 로직을 포함하지 않기 때문에, 프로젝트 팀원이 아닌 사람이 비즈니스 로직의 전체 흐름을 파악하기 어려울 수 있습니다.     \n\n그러나 현재 저희 애플리케이션에서는 단순히 ID 로 Member 를 조회하는 로직만 수행하기 때문에, 아직까지 위의 문제점이 크게 문제가 되는 부분은 없을 듯 합니다. (프로젝트를 함께 진행하고 있는 팀이 계층간의 분리를 중시한다면 다른 판단을 내릴 수도 있을 것입니다)\n\n### Interceptor vs Argument Resolver\n\n그렇다면 Interceptor 또는 Argument Resolver 를 사용하는 것이 좋지 않을까? 라고 생각하셨을 겁니다.\n그렇다면 둘 중 어디에서 `MemberService` 를 사용하여 Member 를 조회하는 것이 좋을까요?\n\n#### Member 를 interceptor 에서 조회하자\n\nInterceptor 는 요청의 전처리 / 후처리와 요청 / 응답의 변경, 로깅, 인증과 권한 체크 같은 기능을 수행할 때 사용됩니다. 또한 여러 컨트롤러에 대해 동일한 로직을 적용하고 싶을 때 효과적으로 사용할 수 있습니다.     \n\n그러나 Interceptor 에서 id로 부터 Member 를 생성하는 것은 Interceptor 가 수행해야 하는 일을 넘어섰다고도 볼 수 있습니다.    \nid 값으로부터 Member 를 조회하여 전달하는 것은 '요청과 응답을 가공' 하는 것과는 거리가 멀기 때문입니다.     \n\n또한 Interceptor 는 요청의 생명 주기 내에서 `preHandle`, `postHandle`, `afterCompletion` 에서 동작하므로, 파라미터를 변환하는 데에 적합한 생명주기를 갖고 있다고 말하기 어려울 수 있습니다. 변환될 Member 는 요청 전체에서 사용되는 것이 아닌, 컨트롤러의 메서드 파라미터로 전달되어 Service 로 넘겨지기 위해서 사용되기 때문입니다. \n\n그러므로 Interceptor 에서는 JWT 의 유효성 검사나 권한을 체크하는 등, 인증 / 인가와 관련된 로직을 수행하는 것이 더 적합하다고 할 수 있겠습니다.\n\n#### Member 를 Argument Resolver 에서 조회하자\n\nArgument Resolver 는 컨트롤러의 메서드 파라미터를 동적으로 생성하거나 변환하는 로직을 구현할 때 주로 사용됩니다.    \n\nJWT 로부터 얻은 사용자의 ID 를 Member 로 변환하기 위해 Member 를 조회하는 것은 Argument Resolver 가 수행하는 것이 어색하지 않습니다.\n\n#### JPA를 사용할 때 발생할 수 있는 문제점\n\n> 오 그러면 Argument Resolver 에서 Member 조회해서 컨트롤러로 전달해야겠다 😄\n\n그러나 이 글을 읽고 계시는 분이 프로젝트에서 JPA 를 사용하신다면 반드시 고려하셔야 하는 사항이 있습니다.     \n\n**OSIV**\n\nOSIV 는 Open Session In View 의 약자로, JPA 의 Session 이나 Hibernate 의 SessionFactory 가 HTTP 요청의 시작부터 종료까지 열린 상태로 유지되게 하는 패턴입니다.     \nSpring 에서는 기본적으로 활성화가 되어 있지만, 하나의 세션 안의 트랜잭션들이 동일한 영속성 컨텍스트를 공유하기 때문에 주의를 요합니다.      \n\n(OSIV 에 대해서는 추후 글을 자세하게 적어보겠습니다.)\n\nArgument Resolver 에서 주의해야 하는 경우는 **OSIV 설정이 꺼져있을 때** 입니다.     \n\n다음과 같이 yaml 파일에서 OSIV 설정을 꺼줄 수 있습니다.\n\n```yaml\nspring:\n\tjpa:\n\t\topen-in-view: false\n```\n\nArgument Resolver 가 `MemberService` 로 Member 를 조회한다고 해봅시다.\n\n```java\n@Component  \npublic class AuthArgumentResolver implements HandlerMethodArgumentResolver {  \n  \n    private final AuthContext authContext;  \n    private final MemberService memberService;  \n  \n    public AuthArgumentResolver(final AuthContext authContext, final MemberService memberService) {  \n        this.authContext = authContext;  \n        this.memberService = memberService;  \n    }  \n  \n    @Override  \n    public boolean supportsParameter(final MethodParameter parameter) {  \n\t\treturn parameter.hasParameterAnnotation(Authenticated.class);  \n    }  \n  \n    @Override  \n    public Object resolveArgument(  \n        final MethodParameter parameter,  \n        final ModelAndViewContainer mavContainer,  \n        final NativeWebRequest webRequest,  \n        final WebDataBinderFactory binderFactory  \n    ) {  \n        return memberService.findById(authContext.getMemberId());  \n    }  \n}\n```\n\n실험을 위해 기존에 Argument Resolver 로부터 Member 의 ID 를 전달받던 `KillingPartLikeController` 를 다음과 같이 변경했습니다.     \n\n```java\npublic class KillingPartLikeController {  \n  \n    private final KillingPartLikeService killingPartLikeService;  \n  \n    @PutMapping  \n    public ResponseEntity<Void> createLikeOnKillingPart(  \n        @PathVariable(name = \"killing_part_id\") final Long killingPartId,  \n        @Valid @RequestBody final KillingPartLikeRequest request,  \n        @Authenticated final Member member  \n    ) {  \n        killingPartLikeService.updateLikeStatus(killingPartId, member, request);  \n  \n        return ResponseEntity.status(HttpStatus.CREATED).build();  \n    }  \n}\n```\n\n`KillingPartCommentService` 에서는 `EntityManager` 를 가져와서 Member 가 존재하는지 확인해보겠습니다.     \n\n```java\n@Transactional(readOnly = true)  \n@Service  \npublic class KillingPartLikeService {  \n  \n    private final KillingPartRepository killingPartRepository;  \n    private final MemberRepository memberRepository;  \n    private final KillingPartLikeRepository likeRepository;  \n  \n    @Autowired  \n    private EntityManager entityManager;  \n  \n    @Transactional  \n    public void updateLikeStatus(  \n        final Long killingPartId,  \n        final Member member,  \n        final KillingPartLikeRequest request  \n    ) {  \n        System.out.println(\"====================Member 가 존재할까====================\");  \n        System.out.println(entityManager.contains(member));  \n        System.out.println(\"====================결과 출력 완료====================\");  \n        \n        ...\n    }\n```\n\n이렇게 설정해두고, 실제 요청을 보내게 되면 `MemberService` 에서 열린 새로운 트랜잭션의 영속성 컨텍스트에는 Argument Resolver 에서 조회한 Member 가 포함되어 있지 않는 것을 볼 수 있습니다.    \n\n![[entity-manager-cannot-find-member.png]]\n\n왜 이런 일이 발생했을까요?     \n\nArgument Resolver 에서 Member 를 조회한 후에 컨트롤러에 전달합니다. 그런데 `MemberService` 의 트랜잭션이 닫히면서 조회한 Member 는 준영속 상태가 됩니다.     \n준영속 상태인 엔티티가 영속성 컨텍스트에 포함되기 위해서는 DB 에서 Member 를 다시 조회해야 합니다.      \n\n결국 Service의 메서드 파라미터로 전달된 Member 에 변경이 발생했어도 영속성 컨텍스트는 변경 감지를 할 수 없게 됩니다.     \n\n현재 저희 서비스에서는 Member 가 변경되는 일이 존재하지 않습니다. 그러나 추후 OSIV 설정을 꺼 둔 상태에서 Member 에 변경이 발생하는 경우 문제의 원인을 찾기 힘들 것입니다.      \n\n따라서 JPA 를 사용하고 OSIV 설정을 꺼두었을 경우, Argument Resolver 나 Interceptor 에서 Member 를 조회해서 컨트롤러로 전달할 때 주의해야 합니다.     \n\n## 결론\n\n> 그래서 뭐 어떻게 하면 좋다는 거야 🤷🏻‍♂️\n\n라는 생각이 드실지도 모르겠습니다.      \n\n제 나름의 결론은 다음과 같습니다.\n\n- JWT 를 사용할 때 토큰 내부의 값을 검증할 필요는 없다.\n- Argument Resolver 와 Interceptor 중에서는 Argument Resolver 에서 Member 를 조회하는 것이 낫다.\n- OSIV 설정이 꺼져 있고, 비즈니스 로직 상에서 Member 의 변경이 발생할 가능성이 있는 경우 오히려 준영속 상태의 Member 를 조회하기 위한 쿼리가 추가로 발생하므로, 중복 코드가 발생하더라도 Service 에서 Member 를 조회하는 것이 좋아보인다.\n\n제 결론이 정답은 아니고 다양한 상황이 있을 수 있으므로 상황에 맞게 사용하시면 좋겠습니다."},{"excerpt":"5분 스피치 주제 여러분, 이런 경험 없으셨나요? 여기 맨날 듣던 노래 말고 다른 좋은 노래 듣고 싶다. 그런데 노래를 처음부터 듣기는 귀찮아... 결국 이렇게 똑같은 노래를 다시 들어보신적 없으신가요? 이 노래 들어봐 너무 좋아! 하면서 노래를 추천했는데, 첫 소절만 들어보고 별로라고 하는 친구 때문에 클라이막스가 진짜 좋다고 제발 클라이막스를 들어달라…","fields":{"slug":"/shook-five-minute-speech/"},"frontmatter":{"date":"2023년 08월 15일 03:08","title":"S-HOOK 5분 스피치","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 5분 스피치 주제\n\n여러분, 이런 경험 없으셨나요?\n\n여기 맨날 듣던 노래 말고 다른 좋은 노래 듣고 싶다. 그런데 노래를 처음부터 듣기는 귀찮아... 결국 이렇게 똑같은 노래를 다시 들어보신적 없으신가요?\n\n이 노래 들어봐 너무 좋아! 하면서 노래를 추천했는데, 첫 소절만 들어보고 별로라고 하는 친구 때문에 클라이막스가 진짜 좋다고 제발 클라이막스를 들어달라고 애원하는 B 씨도 있습니다.\n\n왜 이런 상황들이 발생했을까요?\n바로, 노래를 첫 소절부터 들을 때, 한 번에 좋은 노래인지 파악할 수 없다는 문제 때문입니다. 첫 소절부터 좋은 노래는 흔치 않으니까요.      \n그렇다면 노래를 듣자마자 좋은 노래인지 알 수 있다면 어떨까요?       \n\nS-HOOK 은 이 질문에서부터 시작합니다.      \n\nS-HOOK 의 핵심 가치는 지금 들을 좋은 노래를 슉! 하고 빠르게 찾자는 것입니다.      \n\n이를 위해서는 총 세 가지가 필요합니다.      \n\n첫 번째, '다함께' 입니다.     \nS-HOOK 의 킬링파트는 모든 유저와 함께 만들어져야 합니다.     \n\n두 번째, '빠르게' 입니다.     \n킬링파트만으로 다양한 노래를 빠르게 탐색할 수 있어야 합니다.     \n\n세 번째, '즐겁게' 입니다.     \n킬링파트를 들어보고, 다른 사람들과 의견을 나누며 S-HOOK 을 사용하는 것이 즐거운 경험이어야 합니다.\n\n이 핵심가치를 실현하기 위한 S-HOOK 의 기능들을 소개합니다.     \n\nS-HOOK 에서는 사람들이 요즘 어떤 노래를 듣는지 알 수 있습니다.       \n유저들이 가장 많이 좋아했던 노래들을 들어보실 수 있습니다.\n\n다음은 노래를 빠르게 찾을 수 있는 기능, 킬링파트입니다.      \n킬링파트는 5초에서 15초의 길이로 지정되어 있고, 오른쪽의 버튼을 누르면 킬링파트 영상 url 을 복사할 수 있습니다. 재생 버튼을 누르면 킬링파트가 재생됩니다.      \n\n킬링파트를 이용해서 처음부터 노래를 들을 필요 없이, 사람들이 가장 좋아하는 킬링파트를 들어볼 수 있습니다.     \n스와이프로 노래를 넘기며 많은 노래를 빠르게 들어보세요!\n\nS-HOOK 의 킬링파트는 유저들의 참여로 만들어집니다.      \n킬링파트의 길이를 선택하고, 슬라이더로 범위를 지정한 뒤, 등록할 수 있습니다.     \n만약 여러분이 좋아하는 노래가 있으시다면 그 노래의 킬링파트에 기여해보세요!        \n\n모두가 믿고 들을 수 있는 킬링파트를 위해, 로그인을 하지 않은 유저는 킬링파트를 등록할 수 없습니다.     \n\n킬링파트가 마음에 드신다면, 좋아요를 눌러 킬링파트에 대한 여러분의 관심을 표현하실 수 있습니다. \n만약, 킬링파트에 대해 의견이 있으시다면, 킬링파트 댓글로 여러분의 의견을 나누어주세요. \n\n내가 예전에 좋아했던 부분을 다시 들어보고 싶다면, 마이페이지에서 좋았던 킬링파트들을 언제든지 다시 들어보세요.     \n\n좋은 음악이 필요한 순간, S-HOOK이 여러분과 함께 하겠습니다.       \n지금까지 S-HOOK 의 발표였습니다. 감사합니다.   "},{"excerpt":"LOG 배운 것  에서 읽기 전용 트랜잭션으로 멤버를 조회한 후, 컨트롤러에 전달한다. 그러나 읽기 전용 트랜잭션이 종료되면서, 멤버는 준영속 상태가 된다. 준영속 상태인 엔티티를 다시 영속성 컨텍스트에 포함하려면 다시 조회해야 한다. 궁금한 것 느낀 것","fields":{"slug":"/2023-08-16/"},"frontmatter":{"date":"2023년 08월 15일 02:08","title":"2023년 08월 16일","tags":null},"rawMarkdownBody":"## LOG\n\n## 배운 것\n\n- `interceptor` 에서 읽기 전용 트랜잭션으로 멤버를 조회한 후, 컨트롤러에 전달한다. 그러나 읽기 전용 트랜잭션이 종료되면서, 멤버는 준영속 상태가 된다. 준영속 상태인 엔티티를 다시 영속성 컨텍스트에 포함하려면 다시 조회해야 한다.\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"테스트 격리가 되지 않으면 발생하는 문제 인수 테스트 메서드를 추가했는데, 이전에는 잘 동작하던 테스트가 깨지는 상황이 발생했다.  문제는 테스트 격리가 되어 있지 않기 때문이다. 조회를 하기 위해 repository 로 값을 저장해둔 상태였는데, 다른 테스트 메서드에서 조회할 때 다른 테스트 메서드에서 저장해둔 값이 함께 조회된 것이었다.  에 이전에 …","fields":{"slug":"/test-isolation/"},"frontmatter":{"date":"2023년 08월 12일 16:08","title":"S-HOOK 테스트 격리","tags":["shook","테스트","레벨3","우테코","spring","trouble-shooting"]},"rawMarkdownBody":"\n## 테스트 격리가 되지 않으면 발생하는 문제\n\n인수 테스트 메서드를 추가했는데, 이전에는 잘 동작하던 테스트가 깨지는 상황이 발생했다.    \n\n![[acceptance-test-failed.png]]\n\n문제는 테스트 격리가 되어 있지 않기 때문이다.    \n\n조회를 하기 위해 repository 로 값을 저장해둔 상태였는데, 다른 테스트 메서드에서 조회할 때 다른 테스트 메서드에서 저장해둔 값이 함께 조회된 것이었다.     \n\n```java\n@DisplayName(\"특정 노래를 조회할 때, 이전 노래와 다음 노래의 정보를 담은 응답을 반환한다.\")  \n@Test  \nvoid findById() {  \n    // given  \n    final VotingSong beforeSong = votingSongRepository.save(  \n        new VotingSong(\"제목1\", \"비디오URL\", \"이미지URL\", \"가수\", 20));  \n    final VotingSong standardSong = votingSongRepository.save(  \n        new VotingSong(\"제목2\", \"비디오URL\", \"이미지URL\", \"가수\", 20));  \n  \n    // when  \n    final VotingSongSwipeResponse response = RestAssured.given().log().all()  \n        .when().log().all()  \n        .get(\"/voting-songs/{voting_song_id}\", standardSong.getId())  \n        .then().log().all()  \n        .statusCode(HttpStatus.OK.value())  \n        .extract()  \n        .body().as(VotingSongSwipeResponse.class);  \n  \n    // then  \n    final List<VotingSongResponse> expectedBefore = Stream.of(beforeSong)  \n        .map(VotingSongResponse::from)  \n        .toList();  \n  \n    assertAll(  \n        () -> assertThat(response.getBeforeSongs()).usingRecursiveComparison()  \n            .isEqualTo(expectedBefore),  \n        () -> assertThat(response.getCurrentSong()).usingRecursiveComparison()  \n            .isEqualTo(VotingSongResponse.from(standardSong)),  \n        () -> assertThat(response.getAfterSongs()).isEmpty()  \n    );  \n}\n```\n\n`getBeforeSongs` 에 이전에 등록했던 값들이 마구 추가되어 있었다.\n\n인수테스트에서 테스트 사이에 영향을 줄 수 없도록, 인수테스트 격리를 해보자!\n\n## 테이블 TRUNCATE 하기\n\n```java\npackage shook.shook.support;  \n  \nimport jakarta.annotation.PostConstruct;  \nimport jakarta.persistence.Entity;  \nimport jakarta.persistence.EntityManager;  \nimport jakarta.persistence.PersistenceContext;  \nimport jakarta.persistence.metamodel.EntityType;  \nimport java.util.List;  \nimport org.springframework.context.annotation.Profile;  \nimport org.springframework.stereotype.Component;  \nimport org.springframework.transaction.annotation.Transactional;  \n  \n@Component  \n@Profile(\"test\")  \npublic class DataCleaner {  \n  \n    private static final String TRUNCATE_FORMAT = \"TRUNCATE TABLE %s\";  \n    private static final String ALTER_TABLE_FORMAT = \"ALTER TABLE %s ALTER COLUMN ID RESTART WITH 1\";  \n    private static final String CAMEL_CASE_REGEX = \"([a-z])([A-Z]+)\";  \n    private static final String SNAKE_CASE_REGEX = \"$1_$2\";  \n  \n    private List<String> tableNames;  \n  \n    @PersistenceContext  \n    private EntityManager entityManager;  \n  \n    @PostConstruct  \n    public void findDatabaseTableNames() {  \n        tableNames = entityManager.getMetamodel().getEntities().stream()  \n            .filter(DataCleaner::isEntityClass)  \n            .map(DataCleaner::convertCamelCaseToSnakeCase)  \n            .toList();  \n    }  \n  \n    private static boolean isEntityClass(final EntityType<?> e) {  \n        return e.getJavaType().getAnnotation(Entity.class) != null;  \n    }  \n  \n    private static String convertCamelCaseToSnakeCase(final EntityType<?> e) {  \n        return e.getName().replaceAll(CAMEL_CASE_REGEX, SNAKE_CASE_REGEX).toLowerCase();  \n    }  \n  \n    @Transactional  \n    public void clear() {  \n        entityManager.flush();  \n        entityManager.clear();  \n        truncate();  \n    }  \n  \n    private void truncate() {  \n        for (String tableName : tableNames) {  \n            entityManager.createNativeQuery(String.format(TRUNCATE_FORMAT, tableName))  \n                .executeUpdate();  \n            entityManager.createNativeQuery(String.format(ALTER_TABLE_FORMAT, tableName))  \n                .executeUpdate();  \n        }  \n    }}\n```\n\n### 설명\n\ntest 프로필에서만 bean 이 주입되도록 `@Profile(\"test\")` 를 달아주었다.     \n\n**`findDatabaseTableNames()`**\n\n해당 bean이 생성된 이후에 entity 클래스들을 가져와서 클래스 이름을 Camelcase 에서 snake_case 로 변경해준다.     \nDB 테이블 이름은 snake_case 이기 때문이다!\n\n**`clear()`**\n\n쓰기 지연 저장소에 남아있는 쿼리들을 모두 수행한다.     \n영속성 컨텍스트에 남아있는 데이터들을 모두 삭제한 후, 테이블을 `TRUNCATE` 한다.\n\n**`truncate()`**\n\n테이블을 `TRUNCATE` 하고, auto-increment 된 PK 값을 1로 돌려 놓는다.\n\n## `AcceptanceTest` 클래스 생성\n\nS-HOOK 에서 인수테스트는 공통적으로 `@SpringBootTest` 를 사용한다.     \n따라서 모든 인수테스트에서 동일하게 테스트 격리를 수행하기 위해 + `DataCleaner` 를 언제나 `@Autowired` 하는 귀찮음을 덜기 위해 공통 부분을 `AcceptanceTest` 클래스로 분리했다.    \n\n```java\npackage shook.shook.support;  \n  \nimport io.restassured.RestAssured;  \nimport org.junit.jupiter.api.BeforeEach;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.boot.test.context.SpringBootTest;  \nimport org.springframework.boot.test.context.SpringBootTest.WebEnvironment;  \nimport org.springframework.boot.test.web.server.LocalServerPort;  \n  \n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)  \npublic class AcceptanceTest {  \n  \n    @Autowired  \n    private DataCleaner dataCleaner;  \n  \n    @LocalServerPort  \n    private int port;  \n  \n    @BeforeEach  \n    void setUp() {  \n        RestAssured.port = port;  \n        dataCleaner.clear();  \n    }  \n}\n```\n\n이제 인수테스트를 작성할 때 `AcceptanceTest` 를 상속 받아 사용하면 된다.    \n\n```java\nclass VotingSongControllerTest extends AcceptanceTest {\n\t// ...\n}\n```\n\n![[acceptance-test-success.png]]\n\n테스트 격리가 완료되어 모든 테스트가 통과하는 것을 볼 수 있다!"},{"excerpt":"운영 서버 설정 커스텀 로그 저장을 위해  내부에 app, warn, error 디렉터리를 추가했다. ( 는 새로 만든 디렉터리) nginx 설정 먼저 nginx 를 설치한다. Certbot 설정 SSL 인증서 발급을 위해 Certbot 을 설치한다. 여러 개의 도메인 인증서 발급을 위해 다음과 같이 작성한다. 팀 이메일을 입력하고 생성했더니 에러가 발생…","fields":{"slug":"/shook-prod-server-setting/"},"frontmatter":{"date":"2023년 08월 11일 09:08","title":"S-HOOK 운영 서버 설정 실록","tags":["aws","shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 운영 서버 설정\n\n커스텀 로그 저장을 위해 `/etc/log` 내부에 app, warn, error 디렉터리를 추가했다. (`/etc/log` 는 새로 만든 디렉터리)\n### nginx 설정\n\n먼저 nginx 를 설치한다.\n\n```bash\nsudo apt-get install nginx\n```\n\n```bash\ncd /etc/nginx\n```\n\n### Certbot 설정\n\nSSL 인증서 발급을 위해 Certbot 을 설치한다. \n\n```bash\nsudo apt-get install certbot python3-certbot-nginx\n```\n\n여러 개의 도메인 인증서 발급을 위해 다음과 같이 작성한다.\n\n```bash\nsudo certbot --nginx -d s-hook.com -d www.s-hook.com\n```\n\n팀 이메일을 입력하고 생성했더니 에러가 발생했다.    \n\n문제는... 가비아 서브 도메인이 잘못 설정되어 있었다.     \n\n기존에는 CNAME 으로 호스트 이름에 dev, 값에 `s-hook.com` 으로 해두었는데, 기존 `s-hook.com` 개발 서버로 연결되었다. CNAME 을 사용하면 기존 도메인으로 리다이렉트 해주는 듯 하다.      \n\n해결 방법은 쉽다!     \nA 레코드로 호스트 이름에 새로운 서브도메인으로 사용할 prefix를 작성하고 (ex. dev) 값에 새로운 운영 서버 ip 를 작성한다.      \n\n![[gabia-cname-a-record.png]]\n\n기존 개발 서버가 사용하는 도메인을 운영 서버에서 등록하려고 했는데, 등록할 수 없다는 에러가 발생했다.     \n\n원인은 이미 도메인이 연결되어서 그렇다! \n\n### 개발 서버 도메인 인증서 삭제\n\n기존에 개발 서버에서 `s-hook.com` 을 사용하고 있었기 때문에 `s-hook.com` 을 사용하기 위해서는 개발 서버의 인증서를 삭제해야 한다.     \n\n`certbot delete --cert-name s-hook.com` 로 기존 도메인을 삭제했다.     \n또한 nginx default 파일 (`/etc/nginx/sites-enabled`)에서 certbot 이 작성한 코드를 삭제한다.\n\n개발 서버에는 개발 서브 도메인을 새롭게 연결해주었다.     \n\n프론트엔드 .env.production 파일의 도메인 이름을 변경해준 뒤, frontend 파일들을 재빌드했다.\n\n```bash\nsudo npm ci\nsudo npm run build\n```\n\n이렇게 하면 `dev.s-hook.com` 은 개발서버로 연결되어 새롭게 접속할 수 있다.\n\n### 다시 운영 서버 인증서 발급\n\n운영 서버에서 해당 도메인에 대해 새롭게 인증서를 발급받는다.      \n\n```bash\nsudo certbot --nginx -d s-hook.com www.s-hook.com\n```\n\n여기까지 진행하면 certbot 이 nginx 파일을 바꿔준다.    \n\n```bash\nnginx -t\nsudo service nginx restart\n```\n\n### 서브 모듈 설정\n\nS-HOOK 은 민감한 정보를 보호하기 위해 서브 모듈을 사용한다.     \n\n그러나 서버에 아무 설정도 하지 않으면 운영 서버에서 서브 모듈을 pull 받아올 수 없다. private 레포이기 때문에 권한이 없기 때문이다.     \n따라서 운영 서버에도 서브 모듈을 사용하려면 SSH 설정을 해주어야 한다!     \n\n```bash\nssh-keygen -t rsa\n```\n\n다음과 같이 ssh 키를 생성한다.      \n생성된 ssh key를 서브모듈 레포지토리 owner 의 SSH Key 에 넣어주면 된다.     \n\n![[ssh-key-register.png]]\n\n새롭게 서브모듈을 설정하므로 init 을 해주어야 한다.    \n\n```bash\ngit submodule init\ngit submodule update\n```\n\n여기까지 했는데 갑자기 Username 을 적으라고 한다.\n\n![[submodule-exception.png]]\n\n아무리 Username 과 Password 를 쳐도 소용 없다.    \n서브모듈을 등록하기 위해 서브 모듈을 삭제하고, 캐시도 지웠다.    \n\n```bash\nrm -rf shook-security/\ngit rm -r --cached shook-security\n```\n\nEC2에서 발급한 Key 를 등록하고, Git Submodule add 를 다시 진행한다.    \nSSH 주소는 서브모듈의 ssh git 링크를 가져와야 한다.     \n\n![[submodule-ssh-address.png]]\n\n중간에 npm 이 없어서 `sudo apt-get install npm` 을 해주었다.    \n\n순탄하게 설치될 줄 알았으나.... npm 설치하는데 서버가 죽을뻔했다.    \n아예 서버 접속이 안 됐다.     \n한 10분 기다려서 접속됐는데 free -m 해보니 메모리를 다 쓰고 있었다.     \n\n`npm --version` 하는데 10분째다.     \n\n![[dying-shook-prod-server.png]]\n\n그래서 일단 타자라도 치기 위해 npm 을 죽였다...ㅋㅋㅋ    \n\n```bash\nsudo kill -9 3897\n```\n\n### 스왑 메모리 설정\n\n이런 일이 발생하지 않게 하기 위해 스왑 메모리를 설정했다.    \n\n```bash\nsudo fallocate -l 4G /swapfile # 스왑 메모리의 크기는 4G 로 설정했다. \nsudo chmod 600 /swapfile # 읽기 / 쓰기 권한을 소유자에게 부여한다.\nsudo mkswap /swapfile  # swapfile 설정\nsudo swapon /swapfile # swap 메모리 켜기\n```\n\n### 다시 npm 설치\n\n잘못된 버전의 npm 을 삭제하고 LTS npm 을 설치한다.\n\n```bash\nsudo apt-get remove npm\nsudo apt-get install npm\n```\n\n도밥 왈, npm install 은 frontend 파일이 있는 곳에서 수행해야 한다고 한다.     \n\nnode 버전이 안 맞아서 node 버전 업그레이드도 해줬다.    \n\n```bash\nsudo n lts  # 노드 최신 버전 업그레이드\nhash -r # 캐시 삭제\n```\n\nfrontend 에서 `sudo npm install` 을 수행한다.    \n\n### frontend 배포\n\nfrontend 가 요청을 보낼 url 을 설정해준다.    \n\n`/frontend/.env` 의 `.env.production` 에 API 를 요청할 도메인 이름을 적어준 후, frontend 파일을 빌드한다.    \n\n```bash\nsudo npm ci\nsudo npm run build\n```\n\n### Java 설치\n\n백엔드 배포를 하다가 Java 가 없는 걸 발견했다.     \n즉시 설치해주자. \n\n```bash\nwget -O- [https://apt.corretto.aws/corretto.key](https://apt.corretto.aws/corretto.key) | sudo apt-key add -  \n sudo add-apt-repository ‘deb [https://apt.corretto.aws](https://apt.corretto.aws/) stable main’\n\nsudo apt-get install -y java-17-amazon-corretto-jdk\n```\n\n백엔드 배포를 했더니 에러가 발생했다!! build가 잘 됐다는 뜻이다 드디어 ㅠㅠㅠ\n\n![[shook-prod-slack-notification.png]]\n\n운영 DB 를 설정해주지 않았기 때문에 에러가 발생했다.      \n그래도 슬랙으로 에러 알림이 잘 오는 것을 확인했다.    \n\n이제 운영 DB를 설정해보자!\n## 운영 DB 설정하기\n\n### pem 키 옮기기\n\nDB 서버는 프라이빗 ip 만 존재하기 때문에 운영 서버로만 접근할 수 있다.     \n그래서 로컬에 있는 운영 서버 pem 키를 운영 서버로 전송했다.     \n\n```bash\nscp -i 2023-shook.pem 2023-shook.pem ubuntu@우리ip:~\n```\n\nbad permission 에러를 막기 위해 pem key 에 권한을 부여한다.    \n\n```bash\nchmod 400 2023-shook.pem\n```\n\n운영 서버에서 DB 서버로 접속한다.     \n\n```bash\nssh -i pemkey이름 ubuntu@DB서버ip\n```\n\n### MySQL 설치\n\nMySQL 을 사용할 것이므로 MySQL 을 설치해준다.    \n\n```bash\nsudo apt-get update\nsudo apt-get install mysql-server\n```\n\nMySQL을 실행한다.     \n\n```bash\nsudo systemctl start mysql\n```\n\n다 했으니 MySQL 에 접속해보자!\n\n```bash\nsudo /usr/bin/mysql -u root -p\n```\n\n잘 접속된다!\n\n팀 내부에서 root 대신 새로운 사용자를 등록하기로 했기 때문에, MySQL 에 새로운 사용자를 추가하자.\n\n### MySQL 사용자 추가\n\n새로운 사용자를 추가하기 위해서는 다음과 같이 설정해주면 된다.\n\n```mysql\ncreate user 사용자이름@운영서버ip identified by '비밀번호';\n```\n\n하다가 잘못된 유저를 만든 경우 (우리의 경우...) 유저를 삭제해준다.    \n\n```mysql\ndrop user '사용자이름'@'호스트';\n```\n\n사용자를 만든 뒤에, 권한을 설정해준다.    \n모든 권한을 주려면 아래와 같이 설정한다.    \n\n```mysql\ngrant all privileges on *.* to '사용자이름'@'호스트';\nflush privileges;\n```\n\n### 데이터베이스 생성\n\n운영 서버에서 사용할 데이터베이스를 생성해준다.   \n\n```mysql\ncreate database 데이터베이스이름;\n```\n\n현재 `sql.init=always` 설정이 되어 있기 때문에 data.sql 을 삭제했다.    \n\n기존에 dev 용으로 사용하던 더미 데이터가 운영 DB에 올라가면 안 되기 때문이다.     \n이제 더 이상 `sql.init` 설정은 사용하지 않을 예정이다.    \n\n### bind-address\n\n외부 접속을 허용해주기 위해 `/etc/mysql/mysql.conf.d` 의 `mysqld.cnf` 에 들어가서 bind-address 를 수정해준다.   \n\n설정 파일을 수정하고, mysql 을 재시작한다.\n\n```bash\nsudo systemctl restart mysql\n```\n\n## 백엔드 배포\n\n### log 디렉터리 권한 에러\n\n배포를 시작하는데 log 에 권한 에러가 발생했다.    \n로그와 관련된 모든 디렉터리에 권한을 할당해주었다.     \n\n```bash\nsudo chmod 775 etc/\nsudo chmod 777 app\nsudo chmod 777 error\nsudo chmod 777 warn\n```\n\n이렇게 했더니 DB Connection Refused 가 발생했다.    \n로그 파일을 보다보니까 서버 시간 설정을 까먹었다는 사실을 발견했다.\n### 서버 시간 설정하기\n\n서버 시간을 서울 시간대로 변경해주었다.    \n\n```bash\nsudo timedatectl set-timezone Asia/Seoul\n```\n\n이 과정을 거쳐... 드디어 백엔드 서버를 배포했더니 잘 됐다!!!!!\n\n![[shook-prod-swagger.png]]\n\nswagger 가 열리는 걸 보니 잘 돌아갑니다 ^^\n\n너무 힘드네요 진짜로"},{"excerpt":"프로젝트 요구사항에 모니터링 CloudWatch 란","fields":{"slug":"/shook-cloudwatch/"},"frontmatter":{"date":"2023년 08월 11일 08:08","title":"CloudWatch 도입 고민기","tags":["shook","레벨3","모니터링","우테코"]},"rawMarkdownBody":"\n프로젝트 요구사항에 모니터링\n\n## CloudWatch 란"},{"excerpt":"도입 계기 S-HOOK 에서는 서비스 내부에서 앨범 자켓 이미지를 사용한다.  초기에는 mania DB 이미지 url 을 그대로 사용하려고 했으나 굉장히 큰 문제가 발생했다. 바로 maniaDB API 요청 속도가 매우매우매우매우 느리다는 것이다... 아래가 maniaDB API 를 그대로 사용했을 때의 이미지 로딩 속도이다.  파일 크기도 1MB 정도로…","fields":{"slug":"/shook-s3-introduce/"},"frontmatter":{"date":"2023년 08월 11일 06:08","title":"S-HOOK S3 도입 요청","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 도입 계기\n\nS-HOOK 에서는 서비스 내부에서 앨범 자켓 이미지를 사용한다.     \n\n![[shook-image-list.png]]\n\n초기에는 mania DB 이미지 url 을 그대로 사용하려고 했으나 굉장히 큰 문제가 발생했다.     \n바로 maniaDB API 요청 속도가 매우매우매우매우 느리다는 것이다...\n\n아래가 maniaDB API 를 그대로 사용했을 때의 이미지 로딩 속도이다.    \n\n![[maniadb-image-load-rate.png]]\n\n파일 크기도 1MB 정도로 큰 편인데, 1.2MB 파일을 가져오는데 43.52초가 걸린다.     \n곡이 사용자에게 리스트 형태로 보여지기 때문에, 많은 이미지가 한 번에 로딩되어야 한다.     \n어떤 이미지는 빠르게 로딩되고, 어떤 이미지는 느리게 로딩된다면 사용자에게 좋지 않은 경험이 될 것이다.    \n\n물론 다른 API 를 사용할 수도 있다.      \n멜론의 앨범 자켓 이미지 url 을 그대로 가져오는 것이다.     \n그렇지만 이 방법은 단순히 다른 서비스의 image url을 임의로 도용하는 것이기 때문에 문제가 발생할 가능성이 크다.    \n\n따라서 S3 에 앨범 자켓 이미지를 저장한 후, S3에서 앨범 자켓 이미지를 가져오는 방식을 사용하기로 결정하였다.     "},{"excerpt":"트랜잭션 논리적 작업 단위 transactional ACID 속성 원자성: 트랜잭션과 관련된 작업은 모두 실행되거나 모두 실패함 일관성: 트랜잭션은 참조 무결성 등의 제약 조건을 위반하지 않고 유효한 상태에서 또 다른 유효한 상태로 변경함 격리성: 트랜잭션은 다른 트랜잭션이 존재하지 않는 것처럼 서로 간섭 없이 수행되어야 한다. 지속성: 트랜잭션 커밋 후…","fields":{"slug":"/level3-last-lecture/"},"frontmatter":{"date":"2023년 08월 11일 01:08","title":"쿼리 실행 계획","tags":null},"rawMarkdownBody":"\n## 트랜잭션\n\n- 논리적 작업 단위\n\n[[transactional]]\n\n### ACID 속성\n\n- 원자성: 트랜잭션과 관련된 작업은 모두 실행되거나 모두 실패함\n- 일관성: 트랜잭션은 참조 무결성 등의 제약 조건을 위반하지 않고 유효한 상태에서 또 다른 유효한 상태로 변경함\n- 격리성: 트랜잭션은 다른 트랜잭션이 존재하지 않는 것처럼 서로 간섭 없이 수행되어야 한다.\n- 지속성: 트랜잭션 커밋 후에는 시스템이 중단되거나 장애가 발생해도 데이터가 그대로 유지되어야 한다.   \n\n`@@autocommit` 이 지정되면 statement 하나 당 커밋이 된다. 기본적으로는 1로 설정되어 있는 듯\n\n## 격리 수준\n\n- 트랜잭션이 동시에 변경을 수행하고 쿼리를 수행할 때 성능과 안정성, 일관성 및 결과 재현성 간의 균형을 미세 조정하는 설정\n\t- 트랜잭션이 동시에 수행될 때 다른 트랜잭션에서 변경하거나 조회하는 데이터를 어디까지 볼 수 있도록 허용할 것인지에 대한 설정\n\n## 인덱스\n\n### 인덱스 구분\n\n- primary vs secondary\n\t- mysql 은 모든 key 에 대해 index 를 만든다.\n- key는 자료를 식별하는 값, index는 자료의 구조\n\n"},{"excerpt":"LOG 태풍이 와서 재택을 했다. 근데 태풍이 너무 조용히 지나감 ㅋㅋㅋ 그냥 집에서 쉰 사람 됐다 😄 오늘 t1 과 kt 의 플옵 2라운드가 있었다. 서머 2라운드 때 1승 7패하기도 했고, 아무래도 다들 합을 맞추기에는 어려울 거 같아서 당연히 패자조 갈 생각하고 있었는데 이겼다 !!!!!!!!!!!!!! 흑흐그ㅠㅡㅡ흐그흑 다들 최고야.... 결승 직…","fields":{"slug":"/2023-08-10/"},"frontmatter":{"date":"2023년 08월 10일 14:08","title":"2023년 08월 10일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 태풍이 와서 재택을 했다. 근데 태풍이 너무 조용히 지나감 ㅋㅋㅋ 그냥 집에서 쉰 사람 됐다 😄\n- 오늘 t1 과 kt 의 플옵 2라운드가 있었다. 서머 2라운드 때 1승 7패하기도 했고, 아무래도 다들 합을 맞추기에는 어려울 거 같아서 당연히 패자조 갈 생각하고 있었는데 이겼다 !!!!!!!!!!!!!! 흑흐그ㅠㅡㅡ흐그흑 다들 최고야.... 결승 직행 달다... 🥹\n- 오늘 내내 리팩토링했다. 4차 데모데이 직전에 갑자기 큰 변경 사항들이 막 생겨서 기능 파티 하는 중 ^^... 얼른 기능 개발하고 데모데이 발표 준비도 해야 한다\n\n## 배운 것\n\n\n## 궁금한 것\n\n## 느낀 것\n- "},{"excerpt":"LOG 텀블러 설거지를 하는 걸 깜빡했더니 텀블러에 곰팡이가 폈다..ㅎ 무서워서 먹지 못하는 중 ㅋㅎㅋㅎㅋㅎㅋㅎㅋ.... 당분간은 세제물을 넣어두어야 겠다.... 배운 것  : 현재 timezone 을 확인할 수 있다. 궁금한 것 느낀 것","fields":{"slug":"/2023-08-09/"},"frontmatter":{"date":"2023년 08월 09일 04:08","title":"2023년 08월 09일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 텀블러 설거지를 하는 걸 깜빡했더니 텀블러에 곰팡이가 폈다..ㅎ 무서워서 먹지 못하는 중 ㅋㅎㅋㅎㅋㅎㅋㅎㅋ.... 당분간은 세제물을 넣어두어야 겠다....\n\n## 배운 것\n\n- `select now(), @@system_time_zone as timezone;` : 현재 timezone 을 확인할 수 있다.\n\n## 궁금한 것\n\n## 느낀 것"},{"excerpt":"무중단 배포 서비스를 다운시키지 않고 배포하는 것. 요즘 큰 회사들은 서비스 점검 공지를 보이지 않는다. 인프라 변경 JPA DDL auto 설정 또는 flyway 를 이용하여 운영 DB의 스키마를 관리하고 있지는 않은가?   => 운영 환경에서는 거의 사용하지 않는다. 운영 환경에서는 alter 권한이 없는 사용자를 사용한다. 롤백 롤백이란 배포한 서비…","fields":{"slug":"/rollback-release/"},"frontmatter":{"date":"2023년 08월 08일 01:08","title":"배포와 롤백 강의","tags":["우테코","레벨3"]},"rawMarkdownBody":"\n## 무중단 배포\n\n서비스를 다운시키지 않고 배포하는 것. 요즘 큰 회사들은 서비스 점검 공지를 보이지 않는다.\n\n## 인프라 변경\n\nJPA DDL auto 설정 또는 flyway 를 이용하여 운영 DB의 스키마를 관리하고 있지는 않은가?\n- `spring.jpa.hibernate.ddl-auto: update`\n- `spring.flyway.enbaled:true`\n=> 운영 환경에서는 거의 사용하지 않는다. 운영 환경에서는 alter 권한이 없는 사용자를 사용한다. \n\n## 롤백\n\n롤백이란 배포한 서비스를 이전 상태 (버전) 으로 돌리는 것\n\n### 롤백과 문제 상황\n\n코드를 배포할 때 스키마 변경을 했다면 롤백은 어떻게 하지?\n프론트엔드와 백엔드 중 무엇을 먼저 롤백할 것인가?\n배포한 뒤 문제가 생겨 핫픽스를 했는데, 롤백해야 하느나 상황이 되면 어떻게 하지?\n롤백을 하려고 했는데 실패한다면?\n\n운영 환경과 개발 환경은 다를 수 있다.\n- 인프라 구성\n- 데이터의 양\n\n"},{"excerpt":"보통 API 자동화 툴이라고 하면 swagger, REST API docs 가 자주 고려된다. 서치하다보니 추가로 restdocs-api-spec 이라는 라이브러리도 알게 되어 각각의 장단점을 함께 비교해보려고 한다. Swagger swagger 는 OpenAPI 사양을 사용하기 때문에, 표준화된 형식을 지원한다. 또한 우리의 프론트엔드 팀원들이 API …","fields":{"slug":"/api-docs-search/"},"frontmatter":{"date":"2023년 08월 07일 13:08","title":"S-HOOK API 자동화 툴 정하기","tags":["shook","레벨3","spring"]},"rawMarkdownBody":"\n보통 API 자동화 툴이라고 하면 swagger, REST API docs 가 자주 고려된다.     \n서치하다보니 추가로 restdocs-api-spec 이라는 라이브러리도 알게 되어 각각의 장단점을 함께 비교해보려고 한다.    \n\n## Swagger\n\nswagger 는 OpenAPI 사양을 사용하기 때문에, 표준화된 형식을 지원한다.    \n\n또한 우리의 프론트엔드 팀원들이 API 문서 페이지에서 직접 API 호출을 시도해볼 수 있는 대화형 인터페이스를 제공한다.     \n\n무엇보다 시작하기 쉽다. swagger 의존성만 있어도 API 문서를 만들어준다!\n\n### 단점\n\n가장 크고 자주 지적되는 단점은 프로덕션 코드에 swagger 코드가 침투한다는 것이다.     \n컨트롤러에 swagger 코드가 추가되어 가독성을 떨어뜨릴 수 있다는 단점이 있다.    \n\nTest 를 강제하지 않기 때문에 문서의 신뢰도를 높게 유지하기 어려운 문제가 있다. \n\n### 보완법\n\n\n\n## Spring REST docs\n\n가장 손꼽히는 장점은 테스트로부터 API 문서를 생성하므로 문서는 언제나 실제 코드와 함께 최신 상태라는 것이 보장된다.    \nintegration 테스트를 작성해서, 테스트가 통과해야만 문서가 작성된다. 따라서 문서의 신뢰도가 높게 유지된다.     \n개발 리소스가 발생하기는 하지만, 테스트를 강제하기 때문에 유지보수에도 도움이 된다고 한다.    \n\nswagger 와는 달리 컨트롤러 코드에 어노테이션을 달지 않아도 된다. 소스 코드에 변경을 주지 않기 때문에 비즈니스 로직과 테스트케이스가 분리된다는 장점이 있다.\n\n### 단점\n\nascii docs 를 써야 한다.... 테스트 코드가 추가될 때마다 ascii doc 에 적어야 한다.     \n또한 Swagger UI 와 다르기 때문에, 클라이언트 쪽에서 API 를 호출해볼 수 없다. \n\n추가적으로 UI 가 swagger 에 비해서는 우아하지 않다. (예쁜 것도 중요하다.)     \n\n그러나 테스트 코드가 변경될 떄마다 직접 문서를 수정해야 하는 상황이 발생할 수 있다. (즉, 매우 귀찮다.)\n\n## restdocs-api-spec\n\nSpring ReST Docs 에서 OpenAPI 사양을 생성할 수 있다.    \n"},{"excerpt":"LOG 백준 17299 번을 풀었다. 처음엔 생각해낼 줄 알았는데 시간초과가 계속 나서 결국 답을 봤다 🥺 알고리즘 아자자... 배운 것  by 바론 코드  를 쓰면 내부의 값을 소문자로 바꿔준다!  를 사용하면 리스트에 있는 값들의 빈도 수를 자동으로 세 준다. 궁금한 것 느낀 것 알고리즘 어려워 ㅠㅠ","fields":{"slug":"/2023-08-07/"},"frontmatter":{"date":"2023년 08월 07일 11:08","title":"2023년 08월 07일","tags":null},"rawMarkdownBody":"\n## LOG\n- 백준 17299 번을 풀었다. 처음엔 생각해낼 줄 알았는데 시간초과가 계속 나서 결국 답을 봤다 🥺 알고리즘 아자자...\n\n## 배운 것\n- `@Query(\"SELECT s FROM Song s WHERE LOWER(s.singer.name) = LOWER(:singer)\")` by 바론 코드\n\t- `LOWER` 를 쓰면 내부의 값을 소문자로 바꿔준다!\n- `Collections.Counter(리스트)` 를 사용하면 리스트에 있는 값들의 빈도 수를 자동으로 세 준다.\n\n## 궁금한 것\n\n## 느낀 것\n- 알고리즘 어려워 ㅠㅠ"},{"excerpt":"LOG 배운 것 python 의 slicing 은 O(K) (K는 slicing 될 리스트의 크기) 의 시간 복잡도를 갖는다. python list 비교는 == 으로 가능하다... ㄷㄷ 내부 구현: 두 리스트의 길이가 다르면 O(1). 최악의 경우 O(N) 의 선형 시간 복잡도. 궁금한 것 느낀 것","fields":{"slug":"/2023-08-06/"},"frontmatter":{"date":"2023년 08월 06일 07:08","title":"2023년 08월 06일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n\n- python 의 slicing 은 O(K) (K는 slicing 될 리스트의 크기) 의 시간 복잡도를 갖는다.\n- python list 비교는 == 으로 가능하다... ㄷㄷ\n\t- 내부 구현: 두 리스트의 길이가 다르면 O(1). 최악의 경우 O(N) 의 선형 시간 복잡도.\n\n## 궁금한 것\n\n## 느낀 것"},{"excerpt":"LOG 배운 것  을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴해주고, key 가 존재하지 않을 때는 지정한 값을 리턴한다.  을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴하고, key 가 존재하지 않을 때는 지정한 값을 저장한 후, 값을 리턴한다. 궁금한 것 느낀 것 DP 공부를 하기도 했고, 과외를 하면서…","fields":{"slug":"/2023-08-05/"},"frontmatter":{"date":"2023년 08월 05일 05:08","title":"2023년 08월 05일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n\n- `{dict 이름}.get(가져올 key 값, key 값이 없을 때 리턴할 값)` 을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴해주고, key 가 존재하지 않을 때는 지정한 값을 리턴한다.\n- `{dict 이름}.setdefault(가져올 key 값, key 값이 없을 때 저장할 값)` 을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴하고, key 가 존재하지 않을 때는 지정한 값을 저장한 후, 값을 리턴한다.\n\n## 궁금한 것\n\n## 느낀 것\n- DP 공부를 하기도 했고, 과외를 하면서 계속 설명을 하다보니 이제 좀 이해가 잘 된다. 재미없는 분야에 대해서는 이해가 느린 편이라... 이렇게 남에게 설명하면서 이해하는 게 가장 쉬운 듯."},{"excerpt":"어느덧 2주 후면 4차 데모데이고, 레벨3가 끝난다. S-HOOK 프로젝트를 진행한 후로 시간이 많이 흐른 지금 프로젝트 회고를 작성해보려고 한다. S-HOOK 이란 스플릿의 아이디어로 시작된 S-HOOK은 주제를 보자마자 하고 싶었던 프로젝트였다. 그때 당시의 서비스 소개는 대략적으로 '킬링파트로 노래를 추천하는 서비스' 라고 적혀있었던 것 같다. 그래…","fields":{"slug":"/shook-third-demoday-retrospect/"},"frontmatter":{"date":"2023년 08월 04일 11:08","title":"S-HOOK 3차 데모데이 회고","tags":["회고","shook","레벨3","우테코"]},"rawMarkdownBody":"\n어느덧 2주 후면 4차 데모데이고, 레벨3가 끝난다.     \nS-HOOK 프로젝트를 진행한 후로 시간이 많이 흐른 지금 프로젝트 회고를 작성해보려고 한다.    \n\n## S-HOOK 이란\n\n스플릿의 아이디어로 시작된 S-HOOK은 주제를 보자마자 하고 싶었던 프로젝트였다.   \n그때 당시의 서비스 소개는 대략적으로 '킬링파트로 노래를 추천하는 서비스' 라고 적혀있었던 것 같다. 그래서 인공지능을 쓰는 프로젝트일 것 같아 잘 될까? 하는 회의적인 시각도 있었다.    \n\n스플릿은 자신이 도입부만 들어보고 별로라고 생각했던 노래가, 나중에 들었을 때 좋은 노래였다는 것을 알게 된 후에 기획하게 된 서비스라고 했다.      \n\n우리의 서비스, S-HOOK 은 좋아하는 노래의 '킬링파트'를 다른 사람들과 공유할 수 있다. 또한 노래의 가장 좋은 부분인 '킬링파트'를 먼저 들어봄으로써 새로운 노래를 빠르게 탐색할 수 있다.     \n\n### 비하인드\n\n사실 이런 정의를 내릴 수 있게 된 것도 그렇게 오래되지는 않았다 ㅋㅋㅋ    \n다들 프로젝트를 해보았다면 알 것이다. 모두가 나와 같은 생각을 하고 있다고 생각하지만 모두가 다 다른 각자의 생각을 갖고 있을 때가 훨씬 많다는 것을.\n\n우리 팀도 동일했다. '이게 이런 기능 아니었어?', '이거 하자고 한 거 아니었어?' 라는 말을 수없이 했다. 수없이 했던 이야기를 반복했고, 수없이 똑같은 문제에 대해 토론했다.      \n\n특히 1차 데모데이, 2차 데모데이 기간까지는 우리도 우리 서비스가 무엇인지 명확하게 정의내리기 어려웠다.     \n\n### 가장 많이 생각했던 페르소나\n\n가장 고민했던 것은 우리 서비스가 제공하고 싶은 가치였다. \n\n1차 데모데이 때 정했던 첫 페르소나는 다음과 같다.    \n\n```markdown\n인디음악 매니아\n- 27세 바쁜 직장인\n- 인디음악 매니아\n- 콘서트 좋아함\n\nNeed\n- 자신만의 숨은 명곡을 뽐내고 싶다\n- 노래 중 자신만의 핵심 파트를 뽐내고 싶다\n- 내가 좋아하는 가수의 다른 노래 중 좋은 노래를 찾고 싶다\n```\n\n이때 코치분들에게 '주어진 기능에 맞춰서 페르소나를 지정한 것은 아닌가?' 라는 피드백을 받았다. 아무래도 구현하기로 계획했던 기능이 '등록 / 공유', '조회' 였어서 더 그런 것 같다.     \n팀 내에서도 그런 의견이 나왔어서, 이후로 페르소나 정립을 다시 해야 했다.     \n\n처음 정했던 아이디어 대로라면 공유에 초점을 둔 서비스가 맞았다. 그렇지만 공유를 통해서 우리가 사용자에게 '줄 수 있는 가치' 는 너무나도 모호했다. \n\n너무나도 어려운 시간이었지만, 다시 페르소나를 구축했다.    \n그렇게 새롭게 만들어진, 2차 데모데이까지의 페르소나는 다음과 같다.     \n공유에 초점을 둔 페르소나이다.\n\n```markdown\n킬링파트를 등록하고 공유하는 것이 메인인 페르소나\n\n- 내가 좋아하는 부분을 사람들도 좋아한다는 걸 인정받고 싶다.\n    - 내가 좋아하는 걸 다른 사람들도 좋아한다고 느낄 때의 인정 (보편적)\n        - 사람들이 좋아할 만한 부분을 공유 / 내가 좋아하는 걸 역시 다른 사람들도 좋아하네 → 대중적인 귀\n```\n\n이 페르소나를 정할 때, S-HOOK이 공유에 초점을 둔 서비스일까? 추천에 초점을 둔 서비스일까? 를 계속해서 고민했다.     \n\n추천에 초점을 두게 되면 어쩔 수 없이 사용자의 취향을 알아야만 했는데, 현실적으로 우리가 짧은 기간 안에 구현할 수 없는 기능이라 결론 내렸다.     \n\n따라서 공유에 초점을 둔 페르소나를 선정하기로 했고, 그 중에서도 사람들에게 킬링파트를 공유하고, 자신의 음악 취향을 인정받고 싶은 사용자를 타겟으로 한 페르소나를 만들었다.\n\n그러나 이 페르소나에도 하나의 문제점이 있었다.    \n\n해당 페르소나에게 '인정받는 느낌'을 주기 위해 지금까지 높은 득표를 한 킬링파트에 투표를 하게 되면 '축하한다는 메시지'와 '등수'를 띄워주었다. 이를 위해서는 킬링파트의 득표수가 숨겨져야 했고, 결국 킬링파트 투표를 하고 싶지 않은 사용자는 킬링파트를 확인할 수 없게 되었다.    \n\n그렇다. 우리가 줄 수 있는 인정에는 한계가 있었다.     \n처음에는 내가 등록한 킬링파트의 순위가 높다면 사용자가 '인정받았다' 라고 생각하지 않을까? 라고 생각했다.    \n그러나 그렇게 기능을 제공하게 되면 사용자는 높은 등수의 킬링파트를 계속해서 '찾기만 하는' 등수 퀴즈 서비스 정도로 S-HOOK 을 인지하게 될 것이다. 또한 킬링파트 리스트를 보여주지 않는다면, 킬링파트를 찾기만을 원하는 사용자들을 대거 놓치게 된다. 그것은 우리가 원하는 방향이 아니었다. \n\n그래서 결국 공유를 통한 '인정'을 주는 것은 제외했다. 2차 데모데이에 구현한 기능들은 '공유' 할 수 있게 하는 기능이었다고 정의하기로 했다.     \n\n그리고 지금, 3차 데모데이 까지의 페르소나는 다음과 같다.     \n\n```markdown\n사람들이 많이 소비하는 노래를 찾고 싶은 페르소나\n\n### Needs\n\n- 들어보지 않은 좋은 노래를 찾고 싶다.\n- 최근에 사람들이 많이 소비한 노래들 중에서 안 들어본 좋은 노래를 찾고 싶다.\n\n### Goals\n\n- 새로운 노래의 킬링파트들을 들어보며 좋은 노래인지 판단할 수 있었다.\n```\n\n킬링파트 소비에 목적을 둔 페르소나이다.     \n그렇지만 여전히 순탄하게 정해지지는 않았다...ㅋㅋㅋ\n\n![[third-demoday-persona-1.png]]\n![[third-demoday-persona-2.png]]\n길었던 3차 데모데이 페르소나 회의의 일부분이다.\n\n3차 데모데이 페르소나를 정하면서도 토론이 오갔다. 이 날은 페르소나에 대한 이야기만 5시간을 했다.     \n모두들 우리의 서비스가 제공하고 싶은 가치가 무엇인지 확신하지 못해서 긴 시간을 회의한 것이라 생각한다. 시간은 오래 걸렸지만, 서비스를 위해서는 너무나도 필요한 시간이었다.     \n\n팀원 각자의 의견들을 들어보고, 각 의견들의 모순점을 찾아내고, 모순의 해결점을 찾아내는 회의를 했다.     \n어떤 서비스를 만들고 싶은지, 어떤 서비스가 되었으면 좋겠는지, 이 가치를 실현하는 데 있어서 이런 기능들이 필요한 지... 와 관한 이야기를 했다. 그렇게 정해진 페르소나다.\n\n그렇다. 우리가 고민했던 것은 결국 '사용자' 다.\n\n우리는 서비스를 통해 **사용자**에게 어떤 가치를 줄 수 있나?      \n우리의 서비스를 통해 **사용자**가 얻어갔으면 하는 것은 무엇인가?     \n궁극적으로 우리의 서비스를 통해 **사용자**의 니즈를 달성할 수 있을까?     \n\n라는 질문들에 대답하기 힘겨웠던 날들이 많았다.     \n\n이를 해결하기 위해 했던 회의들은 끝도 없다. 우리 팀은 다른 팀들 사이에서 '회의 많이 하는 팀' 으로 불리고 있었으니까. 오히려 개발보다도 서로의 싱크를 맞추기 위한 회의를 더 많이 했던 것 같다.    \n\n결국 우리가 내린 결론은 이것이다.\n\n우리의 핵심은 유저들이 킬링파트를 만들어 나가며 즐겁게 소비하는 플랫폼을 만드는 것이다.  \n그 중에서는 여러 가치가 있는데\n\n- 노래의 킬링파트를 유저들이 만들어 나간다.\n- 자신이 등록한 파트를 지인들에게 편하게 제공할 수 있다.\n- 유저들이 새로운 노래를 찾는데 킬링파트가 도움이 되도록 한다.\n\n결국 이 가치를 찾기 위해서 멀리 돌아왔고, 그런 과정을 통해 팀원 모두가 인정할 수 있는 서비스와 가치가 만들어졌다고 생각한다.     \n\n무엇보다 기쁜 것은 서비스가 바라보는 것이 기술과 기능이 아니라, '사용자' 라는 것이다.     \n그러니 우리는 앞으로 개발을 할 때 '왜 이런 기능을 만들어야 하지?' 라는 의문에 휘둘리지 않을 것이다. 이미 그런 고민들은 6주 동안 했다.     \n\n### 다음으로 제공할 가치는?\n\n이제 기본적으로 '공유'하고, '소비'하는 페르소나에 대한 정의가 완료되었으므로 사용자의 편의를 높여줄 수 있는 가치들을 구상했다.    \n\n```\n- 사용자에게 신뢰성 있는 킬링파트를 제공한다.\n- 킬링파트를 편리하게 소비할 수 있다.\n```\n\n여담이지만, 각 스프린트마다 구현해야 할 '가치'를 잡고 가는 것은 정말 좋은 방법이다.    \n팀원들 모두 가치를 반영하는 방향으로 움직일 수 있고, 불필요한 기능들을 쳐낼 수도 있다.     \n다들 한 번 시도해보시길.\n\n각각의 가치들을 잘 반영하는 방향으로 마지막 4차 데모데이도 잘 준비하려 한다.     \n\n---\n2차 데모데이까지는 기획 지적을 많이 받았는데, 이번에는 기획이 아닌 UX, UI 지적을 받아서 오히려 좋다. 기획은 어느 정도 틀이 잡힌 것 같다. (이제서야)     \n\n브라운이 구현도가 높아서 실제 서비스를 쓰는 것 같다고 해주셔서 너무 기분 좋았다.     \n4차 데모데이가 끝나고 만들어질 S-HOOK 이 기대된다.     "},{"excerpt":"LOG 3차 데모데이가 있었다. 사실 우리 팀 모두 다 얻어맞을 각오하고 반성하는 대답 적어갔는데 칭찬을 많이 받아서 기뻤다!! 그렇지만 어제 다른 크루들 / 지인들에게 받았던 피드백인 '투표하는 방법을 모르겠다' 같은 UX 관련 내용들은 함께 계속해서 이야기해봐야 할 것 같다. 배운 것 궁금한 것 느낀 것 우리 팀은 기획 관련 회의가 많아서 개발 부분에…","fields":{"slug":"/2023-08-04/"},"frontmatter":{"date":"2023년 08월 04일 07:08","title":"2023년 08월 04일","tags":null},"rawMarkdownBody":"\n## LOG\n- 3차 데모데이가 있었다. 사실 우리 팀 모두 다 얻어맞을 각오하고 반성하는 대답 적어갔는데 칭찬을 많이 받아서 기뻤다!! 그렇지만 어제 다른 크루들 / 지인들에게 받았던 피드백인 '투표하는 방법을 모르겠다' 같은 UX 관련 내용들은 함께 계속해서 이야기해봐야 할 것 같다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n- 우리 팀은 기획 관련 회의가 많아서 개발 부분에서는 조금 뒤처지고 있지 않나라는 생각을 (잠시) 했었는데, 오히려 그 방향이 옳았던 것 같다. 사용자가 어떤 것을 필요로 할 것이고, 우리 서비스로 어떤 것을 얻어가고 싶은지 모든 팀원들이 반복해서 고민했기 때문에 혼란이 적었다. 기술을 고민하는 것도 좋지만, 사용자의 니즈에 따라서 기술이 고안 되어야 한다는 것을 다시 한 번 느끼는 계기가 되었다. \n- 우리 팀 테트리스 왤케 열심히 함 "},{"excerpt":"현재 S-HOOK 의 서비스 DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 합니다. 그 중에서 S-HOOK은  를 채택하게 되었는데, 이유는 다음과 같습니다. WebClient 란? 웹으로 API 를 호출하기 위해 사용되는 Http Client 모듈 중 하나이다. 기존의 동기 API 를 제공할 뿐만…","fields":{"slug":"/shook-webclient-reason/"},"frontmatter":{"date":"2023년 08월 03일 07:08","title":"WebClient를 도입하게 된 이유","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n현재 S-HOOK 의 서비스 DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 합니다.     \n\n그 중에서 S-HOOK은 `WebCient` 를 채택하게 되었는데, 이유는 다음과 같습니다.      \n\n## WebClient 란?\n\n웹으로 API 를 호출하기 위해 사용되는 Http Client 모듈 중 하나이다.     \n기존의 동기 API 를 제공할 뿐만 아니라, nonblocking 과 async 접근 방식을 지원하며 효율적인 통신이 가능하다.\n\n## RestTemplate을 사용하지 않는 이유\n\n### Maintenance Mode의 RestTemplate\n\n> NOTE: As of 5.0 this class is in maintenance mode, with only minor requests for changes and bugs to be accepted going forward. Please, consider using the org.springframework.web.reactive.client.WebClient which has a more modern API and supports sync, async, and streaming scenarios.\n\n> 5.0 버전부터 `RestTemplate` 은 maintenance mode 에 있으며, 앞으로는 사소한 변경과 버그 요청만 받아들여질 예정입니다. 동기, 비동기, streraming 서비스를 지원하는 최신 API 가 포함된 `WebClient` 를 고려해 보세요.\n\nSpring 의 공식 문서에서도 Spring 5.0 부터는 해당 모듈에 기능을 추가하지 않을 것이라고 명시되어 있습니다. 즉, `RestTemplate` 은 버전 업그레이드가 수행되면 Deprecated 될 수도 있습니다.    \n\n따라서 향후 대응을 위해 `WebClient` 로 작성하는 것이 좋을 것이라 생각합니다. (사실 이게 가장 큰 이유입니다.)     \n\n### non-blocking, async 지원\n\n`RestTemplate` 의 경우는 `synchronous`, `blocking call` 만 가능하지만, `WebClient` 는 `async`, `nonblocking` 을 지원합니다.     \n\n이후 외부 API 에 요청을 보낼 때 `async`, `nonblocking` 요청이 필요하게 될 경우에는 `WebClient` 가 강점을 가진다고 할 수 있겠습니다.     \n\n그러나 현재 `WebClient` 가 사용된 부분은 `blocking` 으로 동작하고 있습니다. 외부 API 에서 받아오는 요청을 가공해서 사용자에게 보내주어야 하기 때문에 요청이 받아질 때까지 기다려야 합니다.     \n그러므로 현재로써는 큰 장점은 아니지만, 추후 해당 기능이 필요해지는 경우 `RestTemplate` 보다 강점을 갖게 될 것입니다.     \n\n### 동시 사용자 성능\n\nSpring Boot 2 부터 IO 가 빈번한 경우에 성능이 향상되었습니다.    \n\n동시 사용자의 규모가 별로 없는 경우에는 `RestTemplate` 을 사용하는 것은 별 문제 없지만, 어느 정도의 규모가 있는 경우에는 `WebClient` 를 선택하는 것이 바람직하다고 할 수 있습니다.     \n\n### 구현 상의 이점\n\n`WebClient` 는 예외처리를 람다로 할 수 있습니다. \n\n다음은 S-HOOK 에서 사용한 코드 중 일부입니다.\n\n```java\nprivate ManiaDBAPISearchResponse getResultFromManiaDB(final String searchUrl) {  \n    return webClient.get()  \n        .uri(searchUrl)  \n        .accept(MediaType.TEXT_XML)  \n        .acceptCharset(StandardCharsets.UTF_8)  \n        .retrieve()  \n        .onStatus(HttpStatusCode::is4xxClientError, (clientResponse) -> {  \n            throw new ExternalApiException.ManiaDBClientException();  \n        })  \n        .onStatus(HttpStatusCode::is5xxServerError, (clientResponse) -> {  \n            throw new ExternalApiException.ManiaDBServerException();  \n        })  \n        .bodyToMono(ManiaDBAPISearchResponse.class)  \n        .block();  \n}\n```\n\n이렇게 status 마다 각 예외를 람다 함수로 따로 처리해줄 수 있습니다.    \n\n그러나 `RestTemplate` 을 사용하는 경우, 반드시 `try-catch` 를 사용해주어야 합니다.    \n마찬가지로 S-HOOK 의 코드 중 일부입니다.\n\n```java\npublic GoogleMemberInfoResponse getMemberInfo(final String accessToken) {  \n    try {  \n        ...\n    } catch (HttpClientErrorException e) {  \n        throw new OAuthException.InvalidAccessTokenException();  \n    } catch (HttpServerErrorException e) {  \n        throw new OAuthException.GoogleServerException();  \n    }\n```\n\n사람마다 취향차이가 있을 수 있지만, 개인적으로는 람다로 예외처리를 하는 방식이 좀 더 우아해보입니다. \n\n---\n위와 같은 이유로 S-HOOK 에서는 외부 API 를 호출할 때, `WebClient` 를 도입하기로 결정하였습니다.    \n"},{"excerpt":"지난 피드백 내용 🎙️ S-HOOK 개별 피드백: 등록과 투표를 하나의 플로우에 보여주려고 하다보니, 사용자 입장에서 플로우가 잘 이해되지 않았다는 피드백 🎧 등록을 삭제하고, 투표라는 말로 통일했다. 투표 페이지에서는 '투표'가 메인 기능이며, '공유'가 부가 기능이라는 것을 확실하게 이해시키기 위해 투표 페이지를 다음과 같이 (FE 에서 반영된 부분이므…","fields":{"slug":"/shook-third-demoday/"},"frontmatter":{"date":"2023년 08월 02일 08:08","title":"S-HOOK 3차 데모데이 자료","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 지난 피드백 내용\n\n🎙️ S-HOOK 개별 피드백: 등록과 투표를 하나의 플로우에 보여주려고 하다보니, 사용자 입장에서 플로우가 잘 이해되지 않았다는 피드백\n\n🎧 등록을 삭제하고, 투표라는 말로 통일했다. 투표 페이지에서는 '투표'가 메인 기능이며, '공유'가 부가 기능이라는 것을 확실하게 이해시키기 위해 투표 페이지를 다음과 같이 (FE 에서 반영된 부분이므로 이 부분 내용 추가 필요) 재구성했다.\n\n🎙️ S-HOOK 개별 피드백: 서비스 내부에서 사용자에게 만족감을 주려고 하는 방식이 와닿지 않았다는 피드백\n\n🎧 파트에 투표할 때 보여졌던 '순위', '축하' 키워드를 제거했다.\n\n🎙️ 공통 피드백: 대부분의 팀이 공유의 중요성을 강조하고 있는데, 공유가 적절하게 이루어지고 있는가?\n\n- 부족하다고 느꼈던 부분\n\t- FE, BE 끼리 API 명세를 공유하는 데에는 소홀했던 것 같다.\n\t- 해결한 문제를 wiki로 공유하기로 했는데, wiki 에 글을 생각보다 많이 못 썼다. (공적인 글이라는 부담감, markdown 의 불편함 등의 이유)\n\n- 해결책\n\t- 임시로 API 명세 자동화 툴 (swagger) 을 사용하여 명세가 변경될 때마다 자동으로 업데이트 될 수 있게 했다.\n\t- 팀 블로그를 개설했다. wiki는 팀 전체 아키텍쳐, 공통의 관심사에 관한 내용을 정리하고, 팀 블로그에는 트러블 슈팅 과정, 기술 도입기 등 기술과 관련된 포스팅을 하기로 결정했다.\n\n## 다음 데모 진행사항\n\n> 다음 데모까지 해결하고 싶은 가치\n\n- 사용자에게 신뢰도 있는 킬링파트를 제공한다.\n- 사용자들이 킬링파트를 더 편리하게 소비할 수 있도록 돕는다.\n\n> 가치로부터 도출된 구현 예정 기능\n\n1. 내가 원하는 노래를 찾아서 투표하고 싶어! 🎫 -> 노래 검색 기능\n2. 신뢰도 있는 킬링파트를 위해 노래 하나의 킬링파트 투표는 한 표씩만! 👮🏻‍♀️ -> 로그인\n\t**로그인 구현 후, 구현할 기능들**\n\t1. 내가 좋아했던 킬링파트는 어디? 모아보고 싶어! 😁 -> 내가 투표한 킬링파트 모아보기 기능\n\t2. 이 킬링파트에 대한 사람들의 의견이 궁금해 🤔 -> 킬링파트별 댓글 기능\n3. 내가 좋아하는 장르 노래를 들어보고 싶어! 🤓 -> 장르별 노래 필터 기능\n\n"},{"excerpt":"LOG 알고리즘 문제 2개나 풀었다. 사실 옆에서 같이 푼 문제 다시 본 거긴 하지만.. 그래도 뿌듯하다~ 꾸준히 풀었다는 것에 의의 두자. shook-third-demoday 준비했다. 오늘 내내 데모데이 준비 ㅠ 배운 것  의 기본값은  이다. 궁금한 것 느낀 것 shook 드디어 킥보드 완성..! 다음 데모데이 때는 꼭 자전거가 되어보자 ~ S-HO…","fields":{"slug":"/2023-08-03/"},"frontmatter":{"date":"2023년 08월 02일 06:08","title":"2023년 08월 03일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 문제 2개나 풀었다. 사실 옆에서 같이 푼 문제 다시 본 거긴 하지만.. 그래도 뿌듯하다~ 꾸준히 풀었다는 것에 의의 두자.\n- [[shook-third-demoday]] 준비했다. 오늘 내내 데모데이 준비 ㅠ\n\n## 배운 것\n- `defaultdict(bool)` 의 기본값은 `False` 이다.\n\n## 궁금한 것\n\n## 느낀 것\n- shook 드디어 킥보드 완성..! 다음 데모데이 때는 꼭 자전거가 되어보자 ~\n- S-HOOK 을 다른 사람들에게 써보라고 했는데, 투표 버튼을 못 찾는 사람들이 많았다. UX 에 좀 더 신경써야겠다."},{"excerpt":"VERO WIKI ⚖️ 공부한 것, 일기를 적는 개인 위키입니다 인덱스 페이지: wiki-index 이번 달의 TIL: 2023년 9월의 TIL✨ 현재 자주 쓰는 글들: 우아한테크코스, S-HOOK 개발기","fields":{"slug":"/readme/"},"frontmatter":{"date":"2023년 08월 01일 13:08","title":"readme","tags":null},"rawMarkdownBody":"# VERO WIKI\n\n**⚖️ 공부한 것, 일기를 적는 개인 위키입니다**\n\n* 인덱스 페이지: [[wiki-index]]\n* 이번 달의 TIL: [[2023-09|2023년 9월의 TIL✨]]\n* 현재 자주 쓰는 글들: [[wooteco|우아한테크코스]], [[shook|S-HOOK 개발기]]\n"},{"excerpt":"","fields":{"slug":"/shook-nginx/"},"frontmatter":{"date":"2023년 08월 01일 13:08","title":"nginx 설정기","tags":["shook","nginx","레벨3","우테코"]},"rawMarkdownBody":"\n"},{"excerpt":"CI에서도 Jenkins 를 사용하지 않았던 만큼, Github Action workflow와 동일한 문법을 사용하는 Github self-hosted runner를 사용하기로 했다. 그런데 생각보다 힘든 작업이었다... 설정하는 데 시간도 오래 걸렸다. CD file 개발 서버에서 QA 용으로 사용할 CD 파일이다. 특정 트리거를 달아두지 않고, 수동으…","fields":{"slug":"/github-self-hosted-runner/"},"frontmatter":{"date":"2023년 08월 01일 12:08","title":"Github Self-hosted Runner 설정","tags":["github","shook","레벨3","우테코","trouble-shooting"]},"rawMarkdownBody":"\nCI에서도 Jenkins 를 사용하지 않았던 만큼, Github Action workflow와 동일한 문법을 사용하는 Github self-hosted runner를 사용하기로 했다.     \n\n그런데 생각보다 힘든 작업이었다... 설정하는 데 시간도 오래 걸렸다.\n\n## CD file\n\n개발 서버에서 QA 용으로 사용할 CD 파일이다.     \n특정 트리거를 달아두지 않고, 수동으로 실행시킬 수 있도록 설정해두었다.    \n\n```yml\nname: Backend Develop Deploy (CD)\n\non:\n  workflow_dispatch:\n    inputs:\n      branch:\n        description: 'Branch Name'\n        required: true\n\njobs:\n  build:\n    name: Backend Deploy\n    runs-on: shook-runner\n\n    steps:\n      - name: Log pwd\n        shell: bash\n        run: pwd\n      - name: Log Branch Name\n        shell: bash\n        run: echo \"${{ github.event.inputs.branch }}\"\n      - name: Deploy\n        shell: bash\n        run: bash /home/ubuntu/deploy.sh ${{ github.event.inputs.branch }}\n```\n\n```yml\non:\n  workflow_dispatch:\n```\n\n위 설정을 추가하면, github 내부에서 브랜치를 지정해서 workflow를 실행할 수 있는 버튼이 생긴다.     \n\n![[workflow-dispatch-button.png]]\n\n`github.event.inputs.branch` 를 하게 되면 다음과 같이 workflow 실행할 때 같이 입력할 수 있는 값 입력 창이 생긴다.    \n\n![[cd-workflow-input.png]]\n\n## 발생한 Issues\n\n### Server가 끝까지 실행되지 않는 문제\n\n![[self-hosted-runner-error.png]]\n\nStarting ShookApplication 이라는 문구가 나오지 않고, Application 이 종료되었다.  \n\n그렇지만 이 부분은 우리 잘못이었다.    \nddl-auto를 사용하지 않고, 테이블 스키마를 바꾸었는데 테이블을 적용해주지 않으니 connection과 관련한 예외가 발생한 것이다.    \n\n데이터베이스에 추가한 컬럼을 넣어주니 해결되었다.    \n\n### Github Runner 실행 종료 후, Server가 종료되는 현상\n\nGithub Runner 내부에서 Server process 가 실행되었기 때문에, Github Runner 가 실행 종료 되면서 Server process 를 함께 종료하는 문제가 발생했다.    \n\n이 경우, Github Runner 같은 일반 프로그램이 Server Application 을 종료할 수 없도록 `sudo nohup java -jar ...` 처럼 서버를 실행할 때 `sudo` 권한으로 실행하여 문제를 해결했다.    \n\n### nohup.out 이 없어지는 현상\n\nself-hosted runner를 사용하면, runner 에서 서버 애플리케이션을 실행해서 그런지 nohup.out 파일이 어디에도 나타나지 않는다.    \n\n이런 경우에는 배포 스크립트에 다음과 같이 적어주면 해결 된다.    \n\n`sudo nohup java -jar /home/ubuntu/shook.jar > /home/ubuntu/2023-shook/backend/build/libs 2>&1 &` \n\n애플리케이션에서 발생하는 로그들을 어디에 저장할 지 명시해주게 되면, github self-hosted runner 화면에서는 더 이상 서버 실행 로그가 표시되지 않는다.    \n\n![[unexisted-nohup-log.png]]\n\n대신 위에서 명시한 경로에 nohup.out 에 로그가 쌓이게 된다.    \n\n## 단점이라고 생각되는 것들\n\n생각보다 로그가 빈약하다. 어떤 부분에서 예외가 발생하고, 어디에서 발생한 문제인지 알 수가 없다.     \n\nrunner 에서 예외가 발생했는지 아닌지도 알 수 없다. runner 는 성공적으로 수행됐지만, 우리 서버에서는 예외가 발생했을 수도 있다. \n\n디버깅이 너무 어렵다. 로그가 빈약하다보니 우리가 결국 EC2 내부에 들어가서 어디가 잘못됐을 지 무한 추측을 해야만 한다...\n\nJenkins 는 겪어보지 못해 모르겠지만, 생각보다 러닝커브가 있다.     \nyml 파일을 쓰는 것이 오래 걸리는 게 아니라, Runner가 어떤 동작을 하는지 모르니 예외 처리하기가 힘들다.     \n\n"},{"excerpt":"모든 API 는  prefix 와 함께 사용합니다. 노래 API 노래 ID로 노래 조회 URL\n Response id: 노래 id title: 노래 제목 singer: 가수 이름 videoLength: 영상 길이 songVideoUrl: 노래 영상 url killingParts","fields":{"slug":"/shook-api-doc/"},"frontmatter":{"date":"2023년 08월 01일 12:08","title":"S-HOOK API docs","tags":["shook"]},"rawMarkdownBody":"\n모든 API 는 `/api` prefix 와 함께 사용합니다.\n\n## 노래 API\n\n### 노래 ID로 노래 조회\n\n**URL**\n`/api/songs/{song_id}`\n\n**Response**\n\n- id: 노래 id\n- title: 노래 제목\n- singer: 가수 이름\n- videoLength: 영상 길이\n- songVideoUrl: 노래 영상 url\n- killingParts\n\n```json\n{\n\t\"id\" : 1,   \n\t\"title\" : \"Super Shy\",    \n\t\"singer\" : \"NewJeans\",\n\t\"videoLength\" :200,\n\t\"songVideoUrl\" : \"https://youtu.be/ArmDp-zijuc\",\n\t\"killingParts\" : []\n}\n```\n"},{"excerpt":"LOG 3시간 동안 self-hosted runner 설정하느라 좀 힘들었다.. 한 번에 될 줄 알았는데 시간이 늘어져서 더 그런 것 같다. 그래도 오늘 안에 끝낼 수 있었어서 다행이다. 아픈데도 3시간 동안이나 열심히 참여해준 스플릿 👍 다들 수고 많았어 🥹 드디어 프론트엔드 페이지를 배포했다. 우리도 이제 페이지에서 요청을 보낼 수 있다 🥹 우리 프론…","fields":{"slug":"/2023-08-01/"},"frontmatter":{"date":"2023년 08월 01일 02:08","title":"2023년 08월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 3시간 동안 self-hosted runner 설정하느라 좀 힘들었다.. 한 번에 될 줄 알았는데 시간이 늘어져서 더 그런 것 같다. 그래도 오늘 안에 끝낼 수 있었어서 다행이다. 아픈데도 3시간 동안이나 열심히 참여해준 스플릿 👍 다들 수고 많았어 🥹\n- 드디어 프론트엔드 페이지를 배포했다. 우리도 이제 페이지에서 요청을 보낼 수 있다 🥹 우리 프론트 짱짱\n\n## 배운 것\n- [[github-self-hosted-runner]] 를 설정했다.\n- [[spring-profile-trouble-shooting]] 의 local 프로필 내용이 덮어씌워지는 현상을 정리했다.\n- 코난이 설명해준 엄청난 이야기\n\t- 프론트 페이지를 통해 요청이 들어왔을 때, nginx 로 요청이 전달되어 우리 서버 내부의 정적 파일을 찾아서 넘겨준다. 정적 파일은 브라우저로 전달되는데, 이때 발생하는 API 요청은 EC2의 정적 파일이 아닌 브라우저의 정적 파일에서 발생한다. (리액트가 브라우저에서 실행된다고 했다. 내 방식대로 이해해서 정확하진 않을 수도 있다) \n\n## 궁금한 것\n\n## 느낀 것\n- 피곤하면 효율이 안 나온다.\n- 알고리즘이 후순위로 밀릴 때가 잦은 것 같다.\n- Github Runner를 사용할 때, 실제 브랜치에 반영되지 않으면 테스트 해볼 수 없어서 그 부분도 불편한 듯 ㅠ"},{"excerpt":"2023-08-01 2023-08-03 2023-08-04 2023-08-05 2023-08-06 2023-08-07 2023-08-09 2023-08-10 2023-08-16 2023-08-17 2023-08-24 2023-08-25 2023-08-27 2023-08-29 2023-08-30 2023-08-31","fields":{"slug":"/2023-08/"},"frontmatter":{"date":"2023년 08월 01일 02:08","title":"2023년 08월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-08-01]]\n- [[2023-08-03]]\n- [[2023-08-04]]\n- [[2023-08-05]]\n- [[2023-08-06]]\n- [[2023-08-07]]\n- [[2023-08-09]]\n- [[2023-08-10]]\n- [[2023-08-16]]\n- [[2023-08-17]]\n- [[2023-08-24]]\n- [[2023-08-25]]\n- [[2023-08-27]]\n- [[2023-08-29]]\n- [[2023-08-30]]\n- [[2023-08-31]]\n"},{"excerpt":"Local Profile 실행이 안 되는 문제 현재 default profile을 실행시키고 있으므로, 서브 모듈에 존재하는 prod profile은 실행되지 않아야 한다. 그런데 애플리케이션을 실행시키니, 이런 예외가 발생했다.  옵션은 '활성화 되는' 프로필에 있어야 한다. 마찬가지로  옵션도 그렇다. local 환경에서는 'prod' 가 활성 프로필…","fields":{"slug":"/spring-profile-trouble-shooting/"},"frontmatter":{"date":"2023년 07월 31일 13:07","title":"Spring profile Trouble shooting","tags":["spring","개발","trouble-shooting"]},"rawMarkdownBody":"\n## Local Profile 실행이 안 되는 문제\n\n```bash\n22:18:51.159 [main] ERROR org.springframework.boot.SpringApplication -- Application run failed\norg.springframework.boot.context.config.InactiveConfigDataAccessException: Inactive property source 'Config resource 'class path resource [shook-security/application.yml]' via location 'classpath:shook-security/application.yml'' imported from location 'class path resource [shook-security/application.yml]' cannot contain property 'spring.profiles.group.prod' [origin: class path resource [shook-security/application.yml] - 4:13]\n```\n\n현재 default profile을 실행시키고 있으므로, 서브 모듈에 존재하는 prod profile은 실행되지 않아야 한다.     \n그런데 애플리케이션을 실행시키니, 이런 예외가 발생했다.     \n\n```yml\n# 기존 prod\nspring:  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n  config:  \n\timport: classpath:shook-security/application-jwt.yml, classpath:shook-security/application-oauth.yml\n...\n```\n\n`spring.profiles.group` 옵션은 '활성화 되는' 프로필에 있어야 한다.    \n마찬가지로 `spring.profiles.include` 옵션도 그렇다.    \n\nlocal 환경에서는 'prod' 가 활성 프로필이 아니기 때문에, 예외가 발생하는 것이다.    \n\n그러므로 다음과 같이 변경하면 된다.    \n\n```yml\n# 기존 prod 에서는 group 설정을 삭제한다.\n...\n```\n\n```yml\n# 기본 application.yml 에 group 설정을 해준다.\n\nspring:  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n  config:  \n    import: classpath:shook-security/application.yml\n```\n\n## local 프로필이 prod 프로필을 덮어 씌우는 문제\n\ngithub self-hosted runner 를 설정하면서, 로그를 확인했다.    \n분명 개발 서버에서는 prod 프로필으로 설정되어야 하는데, 이상하게도 데이터베이스 username은 prod 유저 이름인데, 데이터베이스 url이 local 프로필의 url 이었다.     \n\n왜 이런 상황이 발생했을까?\n\n```yml\n# main/resources 내부의 기본 application.yml\nspring:  \n  config:  \n    import: classpath:shook-security/application.yml  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n  \n---  \nspring:  \n  datasource:  \n    driver-class-name: org.h2.Driver  \n    url: jdbc:h2:mem:shook  \n  \n  sql:  \n    init:  \n      mode: always  \n      schema-locations: classpath:schema.sql  \n      data-locations: classpath:data.sql  \n  \n  jpa:  \n    properties:  \n      hibernate:  \n        format_sql: true  \n        show-sql: true  \n    hibernate:  \n      ddl-auto: validate\n```\n\n이때, 불러와지는 prod 프로필은 파일 하단이 아닌, local 프로필 위에 작성된다.     \n다음과 같이 말이다. \n\n```yml\n# main/resources 내부의 기본 application.yml\nspring:  \n  config:  \n    import: classpath:shook-security/application.yml  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n\n---\nprod profile....\n  \n---  \nspring:  \n  datasource:  \n    driver-class-name: org.h2.Driver  \n    url: jdbc:h2:mem:shook  \n...\n```\n\n따라서 prod 프로필에만 존재하는 username, password 는 제대로 설정된 반면, 중복되게 정의된 `spring.datasource.url` 은 local 프로필의 내용으로 덮어씌워진 것이다.     \n\n그렇다면 어떻게 해결할 수 있을까?      \n\n답은 간단하다. local profile 의 이름을 정해주면 된다.     \n\n```yml\nspring:  \n  config:  \n    import: classpath:shook-security/application.yml  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n    active: local  \n  \n---  \nspring:  \n  config:  \n    activate:  \n      on-profile: local\n...\n```\n\nlocal 에서는 실행했을 때 local 프로필로 실행될 수 있도록 `active` 설정을 해주고, `on-profile` 로 이름을 명시해준다.     \n\n이전 파일에서는 local profile 이라는 명시가 없었기 때문에, 그냥 해당 application.yml 파일이 실행될 때 같이 실행되는 설정으로 인식한 듯 하다.    \n\n이렇게 하면 정상적으로 각 프로필을 지정하는 것을 볼 수 있을 것이다.    \n\n## Profile에 대한 짧은 지식\n\n- profile 파일 이름으로 `application-{profile-name}.yml` 을 적으면, 굳이 `spring.config.activate.on-profile` 에 이름을 명시하지 않아도 잘 동작한다.    \n\n- `spring.config.import` 는 대부분의 경우 없어도 잘 동작한다고 한다. 즉, yml 파일이 다른 경로에 있어도 알아서 prod를 읽어온다... 그렇지만 명시적으로 적어주는 게 좋다고 한다.    "},{"excerpt":"DTO Projection 이란 엔티티 대신에 DTO 를 편리하게 조회할 때 사용한다. 엔티티의 일부 속성만 가져오고 싶을 때 사용할 수 있다. 프로젝트에서 Join 한 모든 내용 대신, 노래 정보와 전체 좋아요만 가져오려고 사용했다. 인터페이스 기반 Projection 구현 객체는 JPA 가 프록시로 만들어 준다. projection 된 결과 객체는 영…","fields":{"slug":"/jpa-dto-projection/"},"frontmatter":{"date":"2023년 07월 31일 12:07","title":"JPA의 DTO Projection","tags":["jpa","database"]},"rawMarkdownBody":"\n## DTO Projection 이란\n\n엔티티 대신에 DTO 를 편리하게 조회할 때 사용한다.     \n엔티티의 일부 속성만 가져오고 싶을 때 사용할 수 있다.      \n프로젝트에서 Join 한 모든 내용 대신, 노래 정보와 전체 좋아요만 가져오려고 사용했다.\n\n## 인터페이스 기반 Projection\n\n구현 객체는 JPA 가 프록시로 만들어 준다.\n\nprojection 된 결과 객체는 영속성이 유지되지 않는다.\n\n### interface projection 은 언제 써야 할까?\n\ninterface projection 은 다음과 같은 부분에서 이점을 갖는다. 보통 가독성 측면의 장점이 많은 것 같다.\n\n단순하다. (개인적으로 가장 장점이라 생각한다) 원하는 필드에 해당하는 getter 메서드로 인터페이스를 선언하기만 하면 Spring Data 가 알아서 처리해준다.    \n\n생성자가 필요없다. 그렇지만 이 부분은 lombok 을 쓰면 되니 class projection 에 비해 큰 장점이라고 하기는 어려울 수도 있다.    \n\n현재 dto projection으로 가져오는 데이터가 단순한 평면 구조의 데이터이고, 클래스 내부에서 추가 가공이 이루어지지 않기 때문에 굳이 class projection 을 사용하지 않아도 될 듯 하다.    \n중첩된 DTO가 있는 복잡한 데이터 구조가 필요하거나, DTO 생성자에서 계산을 수행하는 경우에는 class projection이 좋은 선택이 될 수도 있다고 한다.\n\n## 클래스 기반 Projection\n\n생성자의 파라미터 이름으로 Projection 이 동작한다.\n쿼리에 패키지 이름까지 다 써줘야 한다.\n\n## Class Projection 사용 시 주의 점\n\nClass projection을 사용할 때, query 앞에 패키지 경로를 적지 않으면 작동을 하지 않습니다.    \n\n```java\n@Query(\"SELECT NEW shook.shook.song.domain.SongTotalVoteCountDto(s, COUNT(v)) ... \")\n```\n\n이런 식으로 query 내부에 패키지를 적어줘야 합니다.    \n\n## Open Projection\n\n인터페이스에 정의된 메서드에 대한 구체적인 구현을 제공할 수 있다.    \n개발자가 원하는 로직에 따라 값을 반환하게 된다.\n\n## Closed Projection\n\n인터페이스에 정의된 메서드만 사용되며, 엔티티의 특정 속성에 직접 매핑된다.\n\n## 주의\n\nDTO projection 을 사용하면 기존 설정을 무시하고 eager loading 을 하는 듯하다."},{"excerpt":"LOG 아침부터 의자에 올라가고 싶은 날이었다.. 가끔 아침부터 에너지가 주체 안 되는 날이 있는데 그게 바로 오늘이었다. 끝나고 잠실에 놀러갔다. 토리, 포이, 망고랑 저녁으로 신천직화를 먹었다. 오랜만에(?) 잠실 와서 그런가 13층인지 14층인지 헷갈렸다 ㅋㅋㅋ 배운 것 를 사용할 때 가져오는 Response가 0-1개라면 를 사용해야 한다. 100…","fields":{"slug":"/2023-07-27/"},"frontmatter":{"date":"2023년 07월 27일 14:07","title":"2023년 07월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 아침부터 의자에 올라가고 싶은 날이었다.. 가끔 아침부터 에너지가 주체 안 되는 날이 있는데 그게 바로 오늘이었다.\n- 끝나고 잠실에 놀러갔다. 토리, 포이, 망고랑 저녁으로 신천직화를 먹었다. 오랜만에(?) 잠실 와서 그런가 13층인지 14층인지 헷갈렸다 ㅋㅋㅋ \n\n## 배운 것\n- `WebClient`를 사용할 때 가져오는 Response가 0-1개라면 `Mono`를 사용해야 한다.\n- 1000ms 는 1초다.\n\n## 궁금한 것\n\n## 느낀 것\n- 토리가 저녁에 잠실 거실 풍경(?)을 보면서 감동적이라고 한 게 너무 웃겼다 ㅋㅋㅋ\n"},{"excerpt":"발단 S-HOOK의 검색 기능을 구현하면서, 많은 노래를 검색할 수 있어야 하는 기능이 필요해졌다. 그래서 maniaDB의 API 를 사용해서 가수 이름, 노래 이름으로 조회하는 검색 API 를 추가하기로 했다. 그런데 maniaDB의 search API 는 리턴되는 Response가 XML이다... 그렇기 때문에 기존에 우리가 사용하던 JSON DTO의…","fields":{"slug":"/spring-xml-parsing/"},"frontmatter":{"date":"2023년 07월 26일 14:07","title":"Spring에서 외부 API XML Response 파싱하기","tags":["spring","shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 발단\n\nS-HOOK의 검색 기능을 구현하면서, 많은 노래를 검색할 수 있어야 하는 기능이 필요해졌다.    \n그래서 maniaDB의 API 를 사용해서 가수 이름, 노래 이름으로 조회하는 검색 API 를 추가하기로 했다. \n\n그런데 maniaDB의 search API 는 리턴되는 Response가 XML이다... 그렇기 때문에 기존에 우리가 사용하던 JSON DTO의 방식을 그대로 사용할 수가 없다. \n\nSpring 에서 XML 을 파싱하는 방법에 대해 알아보자.\n\n## \n\n## 참고\n\n- [GPT와 나눈 대화](https://chat.openai.com/share/7a487192-168b-4d19-b8d8-5689a40f177e)"},{"excerpt":"현재 S-HOOK DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 한다. 그 중에서 S-HOOK은  를 채택했는데, 이유는 다음과 같다. RestTemplate 란? 간단하고 사용하기 쉽다. sync-blocking 으로 작동한다. 모든 주요 HTTP 메서드에 대해 메서드를 제공하여 모든 종류의 HT…","fields":{"slug":"/spring-external-api-call-method/"},"frontmatter":{"date":"2023년 07월 26일 08:07","title":"Spring 에서 외부 API를 호출하는 방법 비교","tags":["spring","shook","레벨3"]},"rawMarkdownBody":"\n현재 S-HOOK DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 한다.     \n\n그 중에서 S-HOOK은 `WebCient` 를 채택했는데, 이유는 다음과 같다.      \n\n## RestTemplate 란?\n\n간단하고 사용하기 쉽다. sync-blocking 으로 작동한다.    \n모든 주요 HTTP 메서드에 대해 메서드를 제공하여 모든 종류의 HTTP 요청을 쉽게 수행할 수 있다.    \n\n그러나 Spring 5부터 `RestTemplate` 에 대한 업데이트는 없다. 따라서 새 프로젝트에서는 `WebClient` 를 사용하는 것을 추천한다고 한다.     \n\n## WebClient\n\nSpring MVC 에서도 `WebClient` 를 사용할 수 있다.     \nNon-blocking 으로 동작하여 많은 수의 동시 요청을 효율적으로 처리하는 데 적합하여 확장성을 향상시킬 수 있다.    \n\n그러나 Spring MVC 에서 사용되는 경우, non-blocking 특성이 각 request-response 주기에 대해서 스레드가 block 되는 서블릿 기반 애플리케이션에서는 이점이 없을 수도 있다.     \n\n또한 Spring MVC 애플리케이션의 동기식 메서드에서 `WebClient` 호출 결과를 사용해야 하는 경우, 다음과 같이 `block()` 을 호출하여 결과를 기다려야 할 수도 있다.     \n\n```java\nMono<String> result = webClient.get()\n   .uri(\"/api/resource\")\n   .retrieve()\n   .bodyToMono(String.class);\n\n// To get the result synchronously\nString response = result.block();\n```\n\n일반적으로 reactive programming 에서는 권장되지 않는다고 한다.\n\n## Feign\n\nNetflix 에서 개발 후, 나중에 Spring Cloud 생태계에 통합되었다.    \nSpring Cloud 애플리케이션으로 작업 중이고, 로드 밸런싱과 같은 다른 Spring Cloud 기능과 쉽게 통합하려는 경우, 좋은 선택이 될 수 있다.    \n\n그러나 Spring Cloud context 에 있지 않은 경우, 과한 구현이 될 수 있다.     \n\n## 결론...\n\n아무래도 이미 deprecated 된 `RestTemplate` 을 쓰는 것보다는 `WebClient` 를 사용해봐야겠다.    \n\n추후 다른 글을 작성해보겠다."},{"excerpt":"Search API v0.5 Request url:  노래 이름 검색:  노래 이름 검색은 검색어가 포함된 노래를 전부 리턴하는 듯 가수 이름으로도 노래를 검색할 수 있다. 다만 가수 이름에 검색어만 포함되어 있으면 전부 리턴하는 것 같음. 데이터 개수는 1부터 100까지 가능하다. 페이지네이션은 존재하지 않고, 최대 100개의 데이터만 가져올 수 있다.…","fields":{"slug":"/shook-maniadb/"},"frontmatter":{"date":"2023년 07월 26일 07:07","title":"maniaDB 정리 문서","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## Search API v0.5\n\n### Request \n\n- url: `http://www.maniadb.com/api/search/[keyword]/?sr=[artist|album|song]&display=[1~100]&key=[apikey]&v=[version]`\n\n- 노래 이름 검색: `http://www.maniadb.com/api/search/노래이름검색어/?sr=song&display=데이터개수&key=example&v=0.5`\n\t- 노래 이름 검색은 검색어가 포함된 노래를 전부 리턴하는 듯\n\t- 가수 이름으로도 노래를 검색할 수 있다. 다만 가수 이름에 검색어만 포함되어 있으면 전부 리턴하는 것 같음.\n\n- 데이터 개수는 1부터 100까지 가능하다. 페이지네이션은 존재하지 않고, 최대 100개의 데이터만 가져올 수 있다.\n\napi key 는 추후 변경 가능하다. 기존에는 이메일 validation check를 했었으나, 현재는 하고 있지 않다고 한다.\n\n### Response\n\nXML 로 이루어져 있다.\n\n#### 노래 검색\n- item: 검색된 결과 \n\t- title: 노래 이름\n\t- runningtime: 곡 길이 (없는 값도 존재한다)\n\t- maniadb:album\n\t\t- title: 앨범 이름\n\t\t- image: 앨범 이미지\n\t- maniadb:trackartists\n\t\t- maniadb:artist\n\t\t\t- name: 가수 이름\n"},{"excerpt":"LOG 절댓값 힙, 가장 증가하는 부분 수열 2를 풀었다. 배운 것  를 하면 db 확장자를 갖는 파일을 모두 삭제할 수 있다. spring properties를 사용해서 h2의 기본 username, password를 설정 안 하면 그냥 빈 값으로 넣고 들어가야 한다. github action에서 특정 디렉터리의 변경만 감지하고 싶다면 다음과 같이 작성…","fields":{"slug":"/2023-07-26/"},"frontmatter":{"date":"2023년 07월 26일 01:07","title":"2023년 07월 26일","tags":null},"rawMarkdownBody":"## LOG\n- 절댓값 힙, 가장 증가하는 부분 수열 2를 풀었다.\n\n## 배운 것\n- `rm *.db` 를 하면 db 확장자를 갖는 파일을 모두 삭제할 수 있다.\n- spring properties를 사용해서 h2의 기본 username, password를 설정 안 하면 그냥 빈 값으로 넣고 들어가야 한다.\n- github action에서 특정 디렉터리의 변경만 감지하고 싶다면 다음과 같이 작성하면 된다.\n\n```yaml\non:\n  pull_request:\n    ...\n    paths:\n      - \"backend/**\"\n```\n\n- lower_bound\n\n```python\ndef lower_bound(lo, hi, target_index):  \n    while lo < hi:  \n        mid = (lo + hi) // 2  \n        if dp[mid] >= a[target_index]:  \n            hi = mid  \n        else:  \n            lo = mid + 1  \n  \n    return hi\n```\n\n- [[spring-external-api-call-method]] 을 정리했다.\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG 준에게 SHOOK 피드백을 부탁했다. 가치있는 피드백을 받아서 기분좋다. 킬링파트에 대한 리액션을 할 수 있다면 더 재밌을 것 같다. 서비스를 사용하는 순간에 대한 맥락이 존재한다면 사용자에게 공감을 더 받을 수 있고, 확실하게 사용자에게 어필할 수 있는 수단이 될 듯. 킬링파트라는 포인트는 재밌다. 돈카라 김치 우동은 별로야... 스플릿이 먹은 …","fields":{"slug":"/2023-07-25/"},"frontmatter":{"date":"2023년 07월 25일 07:07","title":"2023년 07월 25일","tags":null},"rawMarkdownBody":"## LOG\n- 준에게 SHOOK 피드백을 부탁했다. 가치있는 피드백을 받아서 기분좋다.\n\t- 킬링파트에 대한 리액션을 할 수 있다면 더 재밌을 것 같다.\n\t- 서비스를 사용하는 순간에 대한 맥락이 존재한다면 사용자에게 공감을 더 받을 수 있고, 확실하게 사용자에게 어필할 수 있는 수단이 될 듯.\n\t- 킬링파트라는 포인트는 재밌다.\n- 돈카라 김치 우동은 별로야... 스플릿이 먹은 모둠카츠랑 바론이 먹은 치킨 가라아게 카레는 맛있다고 했다. 나중엔 카레 먹어봐야지\n\n## 배운 것\n- \n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG upper bound 문제를 풀었다. 사실 물어보면서 푼 문제지만 뿌듯하네요 발목 약을 꾸준히 먹었다. SHOOK 페르소나에 대해 다시 이야기하고, 3차 데모데이 어떤 기능을 구현할지 회의했다. 배운 것 lower-bound-and-upper-bound 에 upper bound의 주의할 점을 배웠다. shook-persona 에 SHOOK 의 가치…","fields":{"slug":"/2023-07-24/"},"frontmatter":{"date":"2023년 07월 25일 00:07","title":"2023년 07월 24일","tags":null},"rawMarkdownBody":"## LOG\n- upper bound 문제를 풀었다. 사실 물어보면서 푼 문제지만 뿌듯하네요\n- 발목 약을 꾸준히 먹었다. \n- SHOOK 페르소나에 대해 다시 이야기하고, 3차 데모데이 어떤 기능을 구현할지 회의했다.\n\n## 배운 것\n- [[lower-bound-and-upper-bound]] 에 upper bound의 주의할 점을 배웠다.\n- [[shook-persona]] 에 SHOOK 의 가치와 페르소나 관련 이야기를 추가했다.\n \n## 궁금한 것\n\n## 느낀 것\n- 역시 회의로 싱크를 맞추는 것이 굉장히 굉장히 중요하다... 우리 회의가 많고 절대적인 시간도 길지만 확실히 가치가 있다."},{"excerpt":"우리 팀의 서비스를 한 줄로 소개한다면? 누구나 듣던 노래들이 지루하고, 지겨워질 때가 있습니다. 그렇지만 좋은 노래를 찾으려면 다시 추천을 받고, 처음부터 들어봐야 하는 과정이 귀찮아 그냥 듣던 노래를 들었던 적이 있지 않으신가요? 도입부가 별로여서 듣지 않았던 노래가 나중에 들어보니 하이라이트가 내 취향이어서 놀랐던 경험은 한 번쯤 있으셨을 겁니다. …","fields":{"slug":"/shook-service-introduce/"},"frontmatter":{"date":"2023년 07월 24일 06:07","title":"S-HOOK 서비스 소개 글","tags":["shook","레벨3","우테코","기획"]},"rawMarkdownBody":"\n### 우리 팀의 서비스를 한 줄로 소개한다면?\n\n누구나 듣던 노래들이 지루하고, 지겨워질 때가 있습니다. \n\n그렇지만 좋은 노래를 찾으려면 다시 추천을 받고, 처음부터 들어봐야 하는 과정이 귀찮아 그냥 듣던 노래를 들었던 적이 있지 않으신가요?     \n도입부가 별로여서 듣지 않았던 노래가 나중에 들어보니 하이라이트가 내 취향이어서 놀랐던 경험은 한 번쯤 있으셨을 겁니다.      \n\n저희는 좋은 노래를 찾기 위한 과정들에 걸리는 시간들을 줄이고 싶었습니다.    \n어떻게 하면 좋은 노래를 빠르게 찾을 수 있을지 고민하다, 노래의 가장 좋은 부분인 '킬링파트'만 들어보고 노래를 찾을 수 있는 서비스 'S-HOOK' 을 만들었습니다.     \n\nS-HOOK에서는 노래를 끝까지 들어볼 필요는 없습니다. 킬링파트만 먼저 들어보고, 마음에 든다면 노래를 끝까지 들어보는 거죠. 이제는 더 이상 마음에 들지 않는 노래까지 처음부터 들으실 필요 없습니다.     \n\n등록된 킬링파트가 마음에 들지 않으시다면, 직접 킬링파트를 등록하실 수도 있습니다!     \nS-HOOK은 내가 추천한 노래를 다른 사람들이 듣고 좋아하는 걸 즐기시는 분들을 환영합니다.     \n사람들이 많이 등록한 파트는 그 노래의 '킬링파트'가 됩니다. 내가 선정한 파트가 '킬링파트'로 선정되는 즐거움을 느껴보세요. \n\n이제 당신도 S-HOOK의 혁신적인 음악 탐색 방식을 통해, 새로운 최애곡을 몇 초 만에 만드실 수 있습니다. 더 이상 곡을 찾는 데 많은 시간을 쓸 필요가 없습니다. \n\n### 최종본\n  \n가끔 노래를 끊임없이 반복해서 듣다 보면 지루함이 찾아오곤 합니다. 새로운 노래를 찾기 위해 알고리즘에게 추천을 받아보고, 처음부터 들어보는 과정은 때로는 지루하고 귀찮기만 합니다. 또한, 도입부가 별로여서 넘겼던 노래가 나중에는 당신의 취향에 딱 맞는 노래였던 경험은 한 번쯤 있으셨을 거라 생각합니다.\n\n그런 당신을 위해 'S-HOOK'이라는 서비스를 만들었습니다.     \nS-HOOK는 노래의 가장 강렬한 부분인 '킬링파트'만을 듣고 당신의 새로운 최애곡을 발견할 수 있게 도와줍니다.\n\n더 이상 노래를 처음부터 끝까지 들어보며 시간을 낭비할 필요가 없습니다. 킬링파트만 먼저 들어보고, 마음에 든다면 노래를 끝까지 들을 수 있습니다. 이를 통해, 당신이 원하지 않는 노래를 처음부터 들을 필요가 없어져 빠르게 노래를 탐색할 수 있습니다.    \n\n등록된 '킬링파트'보다 더 좋은 부분을 알고 계신가요? 그렇다면 직접 파트를 등록해보세요! \nS-HOOK에서는 자유롭게 좋아하는 노래의 파트를 등록할 수 있습니다. 당신이 좋아하는 파트가 '킬링파트' 로 선정되는 즐거움을 느껴보세요. \n\nS-HOOK를 통해 빠르게 새로운 음악을 탐색하고, 나만의 새로운 최애곡을 몇 초 만에 발견하세요. S-HOOK에서 당신의 새로운 음악을 찾는 여정을 시작하세요!\n\n## 중간 글\n\n\"강렬한 인상을 주는 노래 한 소절\", 유저들이 킬링파트를 만들고 공유하며 즐기는 서비스 S-HOOK입니다.\n\n가끔 노래를 끊임없이 반복해서 듣다 보면 지루함이 찾아오지 않으신가요?\n새로운 노래를 찾기 위해 알고리즘의 추천을 받아보고, 처음부터 들어보는 과정은 때때로 지루하고 귀찮게 느껴집니다.\n도입부가 별로여서 넘겼던 노래가 나중에는 취향에 딱 맞는 노래였던 적도 있을 거에요.\n\n그런 당신을 위해 'S-HOOK'이라는 서비스를 만들었습니다.\n'S-HOOK'은 노래의 가장 강렬한 부분인 '킬링파트'만을 듣고 당신의 새로운 최애곡을 발견할 수 있게 도와줍니다.\n\n### 자유롭게 킬링파트를 등록하고 공유하세요 🗽\n\n현재 '킬링파트' 보다 더 좋은 부분을 알고 계신가요? 그렇다면 직접 파트를 등록해보세요!\nS-HOOK에서는 좋아하는 노래의 파트를 자유롭게 등록할 수 있습니다.\n당신이 좋아하는 파트가 '킬링파트' 가 되는 즐거움을 느껴보세요.\n\n### 킬링파트만으로 음악을 더 효율적으로 탐색하세요 🔍\n\n더 이상 노래를 처음부터 끝까지 들어보며 시간을 낭비할 필요가 없습니다.\n많은 유저들로부터 인정받은 킬링파트를 먼저 들어보고, 빠르게 당신의 취향에 맞는 노래를 파악할 수 있습니다.\n\nS-HOOK과 함께 여러분의 킬링파트를 유저들과 나누세요\n\n## 최종본\n\n출근길, 이어폰에서 흘러나오는 어제와 똑같은 노래와 우울한 기분.     \n무언가 새로운 음악을 들어보고 싶지만, 알 수 없는 노래의 시작과 끝을 다 듣기엔... 짧은 출근 시간.\n\n> 어쩌면 오늘 들어볼 노래 10곡 중에 내 새로운 최애 곡이 있을 수도 있잖아?\n\n하지만 노래를 다 들어보기엔 피곤하고, 시간이 아까워.\n\n이런 당신에게 필요한 것, 바로 **'S-HOOK'** 입니다!\n\n### 킬링파트로 음악을 더 효율적으로 탐색하세요 🔍\n\nS-HOOK은 노래의 가장 좋은 부분, 킬링파트만을 선별해 여러분에게 제공합니다.     \n지금 듣는 이 노래가 당신의 취향에 맞는 노래인지 30초 내로 확인해 보세요!\n\n더 이상 좋은 노래를 찾기 위해 처음부터 끝까지 들어보며 시간을 낭비하지 않아도 됩니다.     \n당신의 귀를 사로잡는 바로 그 순간만을 즐기세요!\n\n### 당신의 킬링파트, 사람들과 나눠보세요 ✨\n\n당신의 선택으로 노래에 새로운 생명을 불어넣어 보세요! S-HOOK은 여러분의 킬링파트를 모아 새로운 노래의 킬링파트를 선정합니다.  \n당신만 알던 킬링파트가 모두가 아는 킬링파트로 기억될 기회를 놓치지 마세요.      \n함께 만들어 가는 음악 이야기에 참여해 보세요!\n\n### 핫한 노래, 놓치지 마세요 🔥\n\nS-HOOK 유저들이 어떤 노래를 자주 듣는지 궁금하다면? S-HOOK에서 사람들이 많이 찾는 노래의 킬링파트를 바로 들어보세요.     \n핫한 트렌드를 놓치지 말고 함께 즐겨봐요 🔥\n\n이제, 당신의 출근길을 S-HOOK이 함께합니다.      \n매일 새로운 음악과 함께 오늘 하루를 특별하게 시작하세요 🎧"},{"excerpt":"upper bound x 값보다 큰 값이 처음으로 나타나는 위치 lower bound x 값 이상인 값이 처음으로 나타나는 위치 주의할 점 upper bound 에서 hi는 안 되는 값이어야 한다.","fields":{"slug":"/lower-bound-and-upper-bound/"},"frontmatter":{"date":"2023년 07월 23일 14:07","title":"Lower Bound, Upper Bound","tags":["알고리즘"]},"rawMarkdownBody":"## upper bound\n\nx 값보다 큰 값이 처음으로 나타나는 위치\n\n```python\ndef upper_bound(lo, hi, target_index):  \n    while lo < hi:  \n        mid = (lo + hi) // 2  \n        if dp[mid] <= a[target_index]:  \n            lo = mid + 1  \n        else:  \n            hi = mid  \n      \n    return hi\n```\n\n## lower bound\n \nx 값 이상인 값이 처음으로 나타나는 위치\n\n```python\ndef lower_bound(lo, hi, target_index):  \n    while lo < hi:  \n        mid = (lo + hi) // 2  \n        if dp[mid] >= a[target_index]:  \n            hi = mid  \n        else:  \n            lo = mid + 1  \n  \n    return hi\n```\n\n## 주의할 점\n- upper bound 에서 hi는 안 되는 값이어야 한다.\n"},{"excerpt":"LOG 발목 검사를 받으러 정형외과에 갔는데, 아킬레스 힘줄염?이라고 했다. 근데 아무리 생각해도 아킬레스 건 다친 건 아닌 거 같은데 ㅋㅋㅋㅋ 그냥 왼쪽 발 복사뼈 아래 쪽이 아픈 건데. 물리 치료까지 받았다. 과외 끝나고 비 안 와서 얼른 뛰어 가고 있었는데 갑자기 비가 왕창 와서 육교 밑에서 비를 피했다... 이제 우리나라도 semi 열대 지방이다.…","fields":{"slug":"/2023-07-22/"},"frontmatter":{"date":"2023년 07월 22일 13:07","title":"2023년 07월 22일","tags":null},"rawMarkdownBody":"\n## LOG\n- 발목 검사를 받으러 정형외과에 갔는데, 아킬레스 힘줄염?이라고 했다. 근데 아무리 생각해도 아킬레스 건 다친 건 아닌 거 같은데 ㅋㅋㅋㅋ 그냥 왼쪽 발 복사뼈 아래 쪽이 아픈 건데. 물리 치료까지 받았다.\n- 과외 끝나고 비 안 와서 얼른 뛰어 가고 있었는데 갑자기 비가 왕창 와서 육교 밑에서 비를 피했다... 이제 우리나라도 semi 열대 지방이다. 스콜이 내린다;;\n- 비 올 때 steal the show 들으니까 좋았다.\n\n## 배운 것\n- [[fibonaci-matrix]] 를 공부했다. 뒷고리즘\n\n## 궁금한 것\n\n## 느낀 것"},{"excerpt":"보통 피보나치 수열은 O(N) 으로 구할 수 있다. 그런데 피보나치 수 6 에서는 N이 1,000,000,000,000,000,000 이다..ㅋㅋㅋ N 이 엄두도 안 난다 ㄷㄷ 이런 경우에 사용할 수 있는 행렬 곱셈으로 피보나치 수열을 구하는 방법이 있다. 미래의 나를 위한 글이기 때문에 증명은 생략한다. 풀이는 행렬 곱셈과 완전히 동일하다. 단순히  를…","fields":{"slug":"/fibonaci-matrix/"},"frontmatter":{"date":"2023년 07월 22일 13:07","title":"행렬 곱셈으로 피보나치 수 구하기","tags":["알고리즘"]},"rawMarkdownBody":"\n보통 피보나치 수열은 O(N) 으로 구할 수 있다.    \n그런데 [피보나치 수 6](https://www.acmicpc.net/problem/11444) 에서는 N이 1,000,000,000,000,000,000 이다..ㅋㅋㅋ N 이 엄두도 안 난다 ㄷㄷ\n\n이런 경우에 사용할 수 있는 행렬 곱셈으로 피보나치 수열을 구하는 방법이 있다.     \n미래의 나를 위한 글이기 때문에 증명은 생략한다. \n\n```python\ndef solve(n):  \n    if n == 1:  \n        return BASE  \n  \n    half = solve(n // 2)  \n    value = multiply(half, half)  \n    if n % 2 == 1:  \n        value = multiply(value, solve(1))  \n    return value  \n  \n  \ndef multiply(a, b):  \n    result = [[0, 0], [0, 0]]  \n    for i in range(2):  \n        for j in range(2):  \n            for k in range(2):  \n                result[i][j] += a[i][k] * b[k][j]  \n            result[i][j] %= p  \n    return result  \n  \n  \nn = int(input())  \nBASE = [[1, 1], [1, 0]]  \np = 1000000007  \n  \nprint(solve(n)[0][1])\n```\n\n풀이는 행렬 곱셈과 완전히 동일하다.     \n단순히 `BASE = [[1, 1], [1, 0]]` 를 N번 곱하면 된다. 이때, 피보나치 수열의 N번째 값은 BASE 를 N번 곱한 값의 `[0][1]` 값이나, `[1][0]` 값이다."},{"excerpt":"Full-Text Search 란 MySQL 테이블의 문자 기반 데이터에 대해 복잡한 검색 쿼리를 수행할 수 있는 기능이다.","fields":{"slug":"/mysql-full-text-search/"},"frontmatter":{"date":"2023년 07월 21일 05:07","title":"MySQL Full Text Search","tags":["mysql","shook","레벨3","database"]},"rawMarkdownBody":"\n## Full-Text Search 란\n\nMySQL 테이블의 문자 기반 데이터에 대해 복잡한 검색 쿼리를 수행할 수 있는 기능이다."},{"excerpt":"CORS Cross-Origin Resource Sharing. 어떤 출처에서 실행중인 웹 애플리케이션이 다른 출처의 리소스에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제 Origin URL 은 protocol, Host, Path, Query String, Fragment, 포트 번호로 구성되어 있다.  을 예시로 들어보자. Protoco…","fields":{"slug":"/cors/"},"frontmatter":{"date":"2023년 07월 20일 06:07","title":"CORS","tags":["네트워크","개발"]},"rawMarkdownBody":"\n## CORS\n\nCross-Origin Resource Sharing. 어떤 출처에서 실행중인 웹 애플리케이션이 다른 출처의 리소스에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제\n\n### Origin\n\nURL 은 protocol, Host, Path, Query String, Fragment, 포트 번호로 구성되어 있다.\n\n`https://vero.wiki:443/til/2023-08?page=1#오늘` 을 예시로 들어보자.\n\n- Protocol: `https://`\n- Host: `vero.wiki`\n- Port: `443` (생략 가능)\n- Path: `/til/2023-08`\n- Query String: `?page=1`\n- Fragment: `오늘`\n\n이 중, Protocol, Host, Port 3가지가 같으면 동일 출처 (origin) 이라고 한다.\n\n### SOP\n\nSame-Origin Policy. 같은 출처에서만 리소스를 공유할 수 있다는 정책이다.    \n다른 출처로부터 조회한 자원들의 읽기 접근을 막아 다른 출처의 공격을 예방한다.    \n\n그러나 웹에서 다른 출처의 리소스를 가져와서 사용하는 일은 흔하다. 이런 예외 상황을 위해 CORS 정책을 지킨 리소스 요청은 출처가 다르더라도 허용하기로 했다.\n\n### 왜 SOP 가 생겨났을까?\n\n웹 초기 단계에서 웹 보안의 기본 원칙으로 도입되었다. 다양한 웹 사이트와 서비스가 정보와 리소스를 공유하는 환경에서 동작할 때, 다른 출처의 리소스에 자유롭게 액세스하는 것은 큰 보안 위험을 야기할 수 있다.\n\nSOP 는 정보의 무분별한 액세스를 제한한다. 웹사이트 A 의 스크립트가 웹사이트 B 의 데이터와 리소스에 접근할 수 있다면, 웹사이트 A 가 B의 사용자 데이터를 쉽게 읽어올 수 있을 것이다. 이는 CSRF 나 XSS 공격이 발생했을 때 사용자의 민감한 정보가 노출되는 결과가 발생할 수 있다.\n\n(`Cross-Site Scripting` , 즉 XSS 공격이란 공격자가 악의적인 스크립트를 웹 페이지에 삽입하여 다른 사용자가 스크립트를 실행하게 하는 공격이다.)\n\n### 출처를 비교하는 로직의 주체\n\n출처를 비교하는 로직은 브라우저에 구현되어 있다. CORS 정책을 위반하는 리소스 요청을 서버로 보내더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다고 설정된 경우가 아니면 서버는 정상적으로 응답한다.     \n\n즉, 서버간 통신을 할 때에는 이 정책이 적용되지 않는다.\n\n## Preflight Request\n\n본 요청을 보내기 전에 보내는 예비 요청이다. OPTION 메서드가 사용된다.    \n\nOrigin 헤더에 현재 요청하는 origin을 담고, Access-Control-Request-Method 헤더에는 요청하는 HTTP 메서드, Access-Control-Request-Headers 에는 요청 시 사용할 헤더를 담아 서버로 요청을 전송한다.\n\n브라우저가 서버에게 예비 요청을 먼저 보내고, 서버는 이 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고 금지하는지에 대한 정보를 응답 헤더에 담아 브라우저에 돌려준다.\n\n브라우저가 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교한 후, 요청을 보내도 안전하다고 판단되면 본 요청을 보낸다. \n\n## Simple Request\n\nCORS Preflight 를 발생시키지 않는 요청이다.    \n예비 요청 없이 본 요청만으로 CORS 정책 위반 여부를 검사하기도 한다.\n\n예비 요청없이 바로 서버에게 본 요청을 보낸 후, 응답 헤더에 `Access-Control-Allow-Origin` 과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다. \n\n다음과 같은 조건들을 모두 만족해야만 예비 요청을 생략할 수 있다.\n\n1. 요청의 메서드는 GET, HEAD, POST 중 하나여야 한다.\n2. Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width 를 제외한 헤더를 사용하면 안 된다. \n3. 만약 Content-Type 을 사용하는 경우 application/x-www-form-urlencoded, multipart/form-data, text/plain 만 허용된다.\n\n위 조건을 보면 알겠지만, 조건이 굉장히 까다롭기 때문에 대부분 만족시키기 어렵다.\n\n## Credentialed Request\n\n다른 출처간 통신에서 보안을 강화하고 싶을 때 사용하는 방법이다. \n\n요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션은 credentials 옵션으로, 다음과 같은 값을 사용할 수 있다.\n\n1. same-origin (기본값) : 같은 출처 간 요청에만 인증 정보를 담는다.\n2. include: 모든 요청에 인증 정보를 담는다.\n3. omit: 모든 요청에 인증 정보를 담지 않는다.\n\nsame-origin 이나 include 를 사용하여 리소스 요청에 인증 정보가 포함되면, 브라우저는 다음과 같은 규칙을 추가하여 좀 더 엄격하게 검사한다.    \n\n1. Access-Control-Allow-Origin 에는 와일드 카드를 사용할 수 없으며, 명시적인 URL 을 제공해야 한다.\n2. 응답 헤더에는 반드시 Access-Control-Allow-Credentials: true 가 존재해야 한다.\n\n## 참고\n- https://velog.io/@prayme/CORS-%EC%A0%95%EB%B3%B5%EA%B8%B0\n"},{"excerpt":"LOG 발목이 나은 줄 알았는데 안 나았다. 역시 병원에 갈 걸 그랬나 ㅋㅋ 데모데이 전 날... 처음으로 S-HOOK 데모를 봤는데 간지 ㄷㄷ 프론트가 열심히 일해준 덕분에 무사히 데모를 할 수 있을 거 같다. 배운 것  : nginx 테스트  : nginx 다시 켜기  : vim 에서 마우스로 커서를 움직일 수 있다. 궁금한 것 느낀 것 역시 프론트가…","fields":{"slug":"/2023-07-20/"},"frontmatter":{"date":"2023년 07월 20일 04:07","title":"2023년 07월 20일","tags":null},"rawMarkdownBody":"\n## LOG\n- 발목이 나은 줄 알았는데 안 나았다. 역시 병원에 갈 걸 그랬나 ㅋㅋ\n- 데모데이 전 날... 처음으로 S-HOOK 데모를 봤는데 간지 ㄷㄷ 프론트가 열심히 일해준 덕분에 무사히 데모를 할 수 있을 거 같다.\n\n## 배운 것\n- `sudo nginx -t` : nginx 테스트\n- `sudo service nginx reload` : nginx 다시 켜기\n- `:set mouse=a` : vim 에서 마우스로 커서를 움직일 수 있다.\n\n## 궁금한 것\n\n## 느낀 것\n- 역시 프론트가 있어야 뭔가 된다. 분명 백엔드만 있는 서비스는 아무도 안 쓸 거다.. ㅋㅋㅋㅋㅋㅋ 터미널과 까만 창, json으로 뭘 할 수 있는데!!! 슉 프론트 짱"},{"excerpt":"백엔드 기술 스택 개발에 들어가기 앞서, 팀원들과 함께 기술스택을 정하는 시간을 가졌다. Spring Boot 3.1 ver 이 부분을 정하는 것이 핫 포포포테이토였다. (아코 왈) 우리 팀 뿐만 아니라 다른 모든 팀들의 핵심 기술 스택이었다고 생각한다. 왜 Spring Boot를 사용하는가? Spring을 사용하는 경우 외부 라이브러리나 여러가지 dep…","fields":{"slug":"/shook-tech-stack/"},"frontmatter":{"date":"2023년 07월 19일 08:07","title":"S-HOOK 기술 스택","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 백엔드 기술 스택\n\n개발에 들어가기 앞서, 팀원들과 함께 기술스택을 정하는 시간을 가졌다.\n\n### Spring Boot 3.1 ver\n\n이 부분을 정하는 것이 핫 포포포테이토였다. (아코 왈)     \n우리 팀 뿐만 아니라 다른 모든 팀들의 핵심 기술 스택이었다고 생각한다.\n\n#### 왜 Spring Boot를 사용하는가?\n\nSpring을 사용하는 경우 외부 라이브러리나 여러가지 dependency를 추가하고 설정하는 많은 리소스가 필요하다.\n\n구성해야하는 여러가지 세부적인 라이브러리에 대한 레퍼런스를 추상화된 spring boot 라이브러리로 제공하기 때문에 편리하다.\n\n#### 왜 버전을 3.1.x 이상으로 사용하는가?\n\n우리는 우테코 기간 내내 Spring Boot는 2.7 ver 를 사용해왔다.    \n그러나 2.7 ver, 3.0 ver 의 OSS support 기간은 2023년 11월까지다.\n\nOSS Support 기간 동안은 Spring 커뮤니티의 지원을 통해 무료 보안 업데이트 및 버그 수정을 제공한다.    \n우리 팀은 프로젝트 이후에도 서비스를 진행하고 싶었기 때문에, OSS Support 가 가장 긴 3.1 ver를 사용하기로 했다.    \n\nOSS Support 는 여기에서 확인할 수 있다. -> https://spring.io/projects/spring-boot#support\n\n### Java 17 ver\n\n이 부분도 논란(?)이 많았다. \n\n일단 Spring Boot 3.1 ver 를 사용하는 순간부터 Java 17 이상을 사용하는 것이 필수였다.    이 이유가 가장 크다...\n\n또한 Java 17 이상의 버전 중 유일한 LTS 버전이라는 점에서 장점을 갖고 있다.    \nLTS 버전은 일반 버전 보다 보안 업데이트의 지원 기간이 길다.     \n\n따라서 Java 17 을 사용하기로 결정했다. \n\n## Spring Data JPA\n\nORM 프레임워크인 JPA를 사용하기로 했다.     \n\nDB 주도 설계와 객체지향 설계 패러다임 사이의 간극을 줄임으로써 객체지향 설계에 집중할 수 있다.     \n\nORM 프레임워크를 사용하지 않게 되면 코드가 DB에 의존하기 때문에 변경 사항이 모든 쿼리에 영향을 미칠 가능성도 생긴다.     \n\n또한 세부적인 구현 내용을 파악하기 위해 쿼리를 굳이 보지 않아도 되고, 데이터베이스 벤더의 변경에 유연하다.\n\n## Lombok\n\nLombok을 사용하게 되면 코드의 가독성이 올라간다. 모든 필드에 대한 getter 가 필요할 때, 예상 가능한 코드 (getter) 가 계속 추가되므로\n\n또한 코드에서 변경이 발생하게 되었을 때, getter, 생성자 같은 코드를 변경하는 데 소비되는 리소스가 줄어드는 점이 좋았다.    \n\n위와 같은 이유로 Lombok을 도입했다.      \n\n"},{"excerpt":"Git Branch 전략 재확립 Git Flow 에서 Github Flow로 변경하였다. 이전 Branch 전략  현재 Branch 전략  전략 재확립 이유 현재 프로젝트 상황에서는 단순한 Github Flow가 관리가 더 용이하다. 모든 개발 내용이 main으로 중심으로 이루어져서, develop, main의 싱크를 신경쓰지 않아도 된다. 웹 서비스이므…","fields":{"slug":"/shook-second-demoday/"},"frontmatter":{"date":"2023년 07월 19일 07:07","title":"2차 데모데이 자료 준비","tags":["shook","데모데이","레벨3","우테코"]},"rawMarkdownBody":"\n## Git Branch 전략 재확립\n\n- Git Flow 에서 Github Flow로 변경하였다.\n- 이전 Branch 전략\n```mermaid\n---\ntitle : S-HOOK Git diagram\n---\n%%{init: { 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel': false } } }%%\ngitGraph\ncommit\nbranch feature\ncheckout feature\ncommit\ncommit\ncommit\ncheckout main\nmerge feature\nbranch hotfix\ncommit\ncommit\ncheckout main\nmerge hotfix\n```\n\n![[current-shook-git-branch-strategy.png]]\n\n- 현재 Branch 전략\n\n```mermaid\n---\ntitle : S-HOOK Git diagram\n---\n%%{init: { 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel': false } } }%%\ngitGraph\ncommit\nbranch develop order: 2\ncommit\ncommit\ncheckout main\nmerge develop\nbranch hotfix order: 1\ncommit\ncheckout main\nmerge hotfix\ncheckout develop\nmerge hotfix\nbranch feature order: 3\ncommit\ncommit\ncommit\ncheckout develop\nmerge feature\ncheckout main\ncheckout develop\nbranch fix order: 4\ncommit\ncheckout develop\nmerge fix\ncheckout main\nmerge develop\n```\n\n![[prev-shook-git-branch-strategy.png]]\n\n- 전략 재확립 이유\n\t- 현재 프로젝트 상황에서는 단순한 Github Flow가 관리가 더 용이하다.\n\t- 모든 개발 내용이 main으로 중심으로 이루어져서, develop, main의 싱크를 신경쓰지 않아도 된다.\n\t- 웹 서비스이므로 버전을 관리할 필요가 없다고 판단했다.\n\t- 브랜치가 파생될 수 있는 곳이 main 밖에 없어 충돌 가능성이 적다.\n\n## 3차 데모데이에 구현할 기능\n\n- 로그인\n\t- 소셜 로그인\n\t- 그냥 로그인\n\t- 암호화\n\t\t- jwt\n\t\t- session\n- 유저들이 투표한 킬링파트를 볼 수 있다.\n- 유저들이 투표한 TOP 3 킬링파트를 볼 수 있다.\n- 킬링파트를 많이 알아본 순(?)으로 음잘알 배지를 제공한다.\n- 지정된 파트의 영상을 재생할 수 있다.\n- 파트 투표할 시 댓글도 함께 쓸 수 있도록 한다. (베로 개인 의견)\n- 등록한 파트를 공감하는 비율이 노래의 총 파트 투표 중에 몇 퍼센트인지 알려준다.\n- 등록하기 전에는 파트 순위를 볼 수 없고, 등록 후에 파트 순위를 볼 수 있다.\n- 파트 순위를 즉시 확인하는 기능 -> 대신 음잘알 배지나 순위에는 반영되지 않도록 한다. (베로 개인 의견)\n\n## 피드백\n\n### 코치 피드백\n\n#### S-HOOK\n\n- 기능에 집중하고, 기술에 집중하지 않는 것이 좋다.\n- 로그인 하지마\n\t- mock 유저를 사용해서 기능을 구현하자. 굳이 소셜이냐 뭐냐 고민 안 해도 될 듯.\n\t- 고도화는 레벨 4에\n- 애자일하게 진행하자. 애자일의 각 단위 때마다 의미가 있는 부분을 구현해야 한다.\n- 투표라는 말에 혼선이 존재한다. (모달에서 보여주는 '투표' 라는 말을 빼자)\n\t- 우리끼리 투표라는 말을 사용했지만, 다음 스프린트 때는 없어질 수도 있다.\n\t- 스프린트마다 용어를 다시 정의하기도 한다. 그것이 애자일이다 by 브라운\n- 사용자가 우리의 서비스를 사용할 때, 플로우를 공부(?) 해야 할 수도 있다. (사용 방식이 잘 와닿지 않는다는 것일지도)\n- 핵심적인 기능을 먼저 만들어서 우리가 전달하고자 하는 가치를 진짜 전달할 수 있을지 없는지를 검증하고 세부적으로 진행하는 것이 좋다.\n\t- 일단 만들어보고 -> 세부 사항을 검증해라\n\n#### 다른 팀\n\n- 기능 우선순위를 두고 구현해야 한다.\n\n### 개인 의견\n\n- 서비스의 기능 플로우를 좀 더 명확하게 보여주자.\n\t- 해당 기능을 통해 어떤 것을 의도했는지도 적어주면 좋을 거 같다.\n- 다음 데모데이 기능을 말할 때, 다음 데모데이의 중심 가치와 함께 발표하자.\n\t- 중심 가치가 우리 서비스의 어떤 가치를 충족할 수 있을지 함께 발표하자.\n- 3차 데모데이에 전달하고 싶은 우리 서비스의 가치에 대해 싱크를 맞추자. (내가 대답 못함..)\n- 질문 대답 같이 하는 거 좋은 듯\n- 구현할 기능 옆에 어떤 것을 의도했는지 적으면 좋을 듯\n- 로그인 했을 때 안 했을 때 나눠서 데모하는 것도 좋을 듯\n\n### 나에 대한 피드백\n\n- 답변할 때 생각 정리하고 말하기\n- 답변하기 전에 할 말 적어두기\n- 열린 자세로 의견을 수용하기\n- 의견을 비난이라고 속단하지 않기\n\n## 회고\n\n이 글 올리면 다들 잘 안 볼 거 같으니 여기다가 2주차 데모데이 회고를 적는다.\n\n### 함께하는 팀\n\n팀은 하나다. 우리는 장난스럽게 하는 말이기도 하지만, 나는 이 말을 가장 잘 지키는 팀은 우리라고 생각한다.    \n문제는 함께 해결하고, 고민은 함께 나눈다.    \n찬성 의견이든 반대 의견이든 누구나 의견이 있다면 말할 수 있고, 함께 의논할 수 있다.     \n내가 원했던 협업의 모습을 띠는 것 같아 뿌듯했다.    \n\n이번 협업에서 내가 가장 중요하게 생각했던 것은 소통이다.    \n다른 건 아니어도 좋으니, 편하게 의견을 낼 수 있는 팀이라면 좋겠다고 생각했다.     \n우리 팀에서 만족하는 부분은 바로 의견 제시가 자유롭고, 반대 의견도 함께 의논하는 분위기라는 것이다.     \n\n특히 내가 주류 의견이든, 반대 의견이든 의견을 많이 내는 편인데, 팀의 누구도 그런 쓸데 없는 고민을 왜 하느냐고 질책하지 않는다. 오히려 공감하고, 함께 고민해주어서 감사할 때가 많았다.\n\n사실 너무나도 많이 말한 이야기인 것 같지만 ㅋㅋㅋ 페르소나를 다시 재정의해야 했던 시간이 있었다.\n\n물론 모두가 반대 의견 내기를 즐기는(?) 것은 아니다.    \n사람들의 특성 때문이기도 하고, 일정을 맞추지 못할까 봐 넘어가는 사람들도 있을 것이다. 나는 그런 이유로 넘어가는 것은     \n그렇지만 반대 의견을 내는 것이 '상대방의 기분을 안 좋게 하기 때문에' 안 하는 사람들은 없어서 정말정말정말정말 다행이라고 생각한다. 더해서 반대 의견이 나왔다고 해서 기분이 안 좋아지는 팀원도 없어서 정말정말 다행이다.    \n\n레벨3에서 다행히도 좋은 팀을 만난 것 같아 감사하고, 팀과 함께 하는 시간이 즐겁다.     \n\n### 그리고 팀원들\n\n나는 내 의견이 있고, 시간의 압박 속에서 반대 의견도 잘 말할 수 있지만 의견 중 하나를 택 일 하는 것이 어렵다. 내 의견에 큰 미련이 없어 내 의견이 채택되지 않아도 괜찮다.      \n그래서 그런지 스플릿이 같은 파트라서 더 시너지가 난다고 생각한다.     \n스플릿은 의견도 확고하고, 자신만의 근거가 있다. 그리고 어떤 의견 하나를 확실하게 정하는 것을 잘한다. 특히 백엔드에서 회의를 할 때, 제시된 대안들 모두 좋은 경우가 많다. 그 중에서 하나를 확실하게 골라준다. 그 덕분인지 의견 결정 과정에서 의견 결정이 미뤄지지 않아 데드라인을 맞추는 것이 어렵지 않았다.    \n\n바론은 의견 정리를 잘한다. 여러 가지 의견이 나오다보면 의견이 섞이는 때가 많은데, 그럴 때마다 항상 의견 정리를 잘 해준다. 특히 나한테 도움되는 부분이라고 할 수 있다 ㅋㅋ 나는 의견이 섞이다 보면 무슨 이야기를 하고 있었는지, 어떤 거에 대해 의견을 내고 있었는지 까먹는데 바론이 의견 정리해줄 때마다 다시 회의 주제로 돌아갈 수 있다.    \n룰에 대해서도 자주 리마인드를 해주어서 초기에 정했던 규칙을 그나마 많이 지킬 수 있었다.    다른 사람들도 회의하면 시간 생각 없이 계속 하다가 지치는 편인데 바론의 회의 시간 리마인드가 굉장히 도움이 되었다. \n\n아코는 의견을 자주 내는 편은 아니지만, 고민을 많이 한 뒤에 의견을 내기 때문에 도출된 의견이 중요한 관점의 의견일 때가 많다. 가끔 아코가 반대 의견을 낼 때도 있는데, 하나의 의견에 매몰되지 않고 다양한 관점으로 문제를 바라볼 수 있는 시각을 제공해줘서 많은 도움이 되었다.\n\n우코는 이해력이 빠르다. 나는 내 의견을 말로 정리하기 힘들어서 일단 떠오르는 생각들을 말로 내뱉고 다른 사람들이 이해하기를 바라는 편인데 그럴 때마다 한 번에 이해해줘서 정말 고마울 때가 많다...ㅋㅋㅋ 특히 팀원의 주류와 다른 의견이 나왔을 때, 반대 의견에도 지속적으로 의견을 물어봐주어서 팀 내에서 소수의 의견이 묻히는 일이 없다!     \n\n코난은 다른 사람의 의견에 근거를 더해주는 역할을 잘한다. 다른 사람들이 의견을 냈을 때 어떤 부분에서 그 의견이 좋다고 느꼈는지, 이런 부분에서도 좋을 것이라 생각한다는 의견을 덧붙여준다. \n프론트엔드의 든든한 기둥이다. 집중력이 좋고, 작업 속도도 빨라서 어떤 기능이든 뚝딱 만들어낸다. 이번에 youtube iframe 도 금방 학습하고, 기능을 응용해서 우리 서비스에 맞는 기능을 빠르게 만들어주었다. \n\n도밥은 우리가 기획한 내용들이 실제 서비스에 어떻게 반영되어야 할 지 리마인드해준다. 이런 방향으로 페이지를 보여줄 수 있다, 이런 과정을 통해 기능을 제공할 수 있겠다는 말을 해주어서 서비스를 확실하게 구상할 수 있다. 특히 기획이 마무리 되고 대략적인 서비스 플로우를 생각할 때 도밥의 능력이 더 빛을 발한다.     \n하나의 목표가 정해지면, 정해진 목표에 완전히 몰입한다. 우리 팀 중에서 개발에 가장 시간을 많이 쏟는 팀원이라고 생각한다. \n\n### Emotion Meeting\n\n리사가 웃겨했던 우리 팀 감정회고 시간...ㅋㅋㅋ\n우리 팀은 금요일마다 저녁을 함께 먹는다. 데모데이 저녁에는 함께 회식을 하는 시간을 갖는다.     \n보통 캠퍼스로 음식을 배달시켜 먹는 편인데, 사실 밥 먹을 때는 그냥 우스갯소리하거나 조용히 밥을 먹는다 ㅋㅋㅋ 저녁밥을 어느정도 다 먹으면 Emotion Meeting이 시작된다.    \n\n보통 시작은 아코로 시작한다. 아코로 시작해서 하고 싶은 말이 있는 팀원들 순으로 말한다. \n\nto be continue... 시간 되면 써야지"},{"excerpt":"LOG 발을 삐었는지 몰라도 발목이 너무 아파서 파스를 붙였다. 배운 것 궁금한 것 느낀 것","fields":{"slug":"/2023-07-19/"},"frontmatter":{"date":"2023년 07월 19일 06:07","title":"2023년 07월 19일","tags":null},"rawMarkdownBody":"## LOG\n- 발을 삐었는지 몰라도 발목이 너무 아파서 파스를 붙였다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG 오늘은 아코, 코난이 과자를 사와서 맛있게 먹었다. 고마워~ 근데 아코가 사온 감자칩? 엄청 맛있었다. 내일은 내가 사가야지 배운 것  를 17로 설정하면 github action에서 17 JVM에서 호환되는 버전으로 컴파일 해준다. 설정 안 하면 가장 최신 LTS 버전으로 컴파일 하는 듯 하다.  에 아무런 내용도 없으면 예외가 발생한다. 사용하…","fields":{"slug":"/2023-07-18/"},"frontmatter":{"date":"2023년 07월 18일 03:07","title":"2023년 07월 18일","tags":null},"rawMarkdownBody":"\n## LOG\n- 오늘은 아코, 코난이 과자를 사와서 맛있게 먹었다. 고마워~ 근데 아코가 사온 감자칩? 엄청 맛있었다. 내일은 내가 사가야지\n\n## 배운 것\n- `targetCompatability` 를 17로 설정하면 github action에서 17 JVM에서 호환되는 버전으로 컴파일 해준다.\n\t- 설정 안 하면 가장 최신 LTS 버전으로 컴파일 하는 듯 하다.\n- `data.sql` 에 아무런 내용도 없으면 예외가 발생한다. 사용하지 않으면 삭제해두자.\n- 브랜치의 merge conflict는 현재 브랜치와 병합하려는 브랜치 모두에서 코드의 동일한 부분이 변경되는 경우, git이 사용할 버전을 결정할 수 없을 때 발생한다.\n- github action을 수동으로 동작할 수 있게 하는 코드 (이 코드가 없으면 브랜치마다 github action을 수동으로 동작할 수가 없다.)\n\n```yaml\non: \n\tworkflow_dispatch:\n```\n\n- Java의 HashSet은 내부적으로 HashMap을 통해 동작하고, add 할 때의 해시값을 key 로 갖는다. 그런데 영속화 전에 entity가 set에 삽입되면 그 당시의 해시값을 저장하는데, 영속화시에 id가 변경되며, 해시값이 바뀌어서 `contains()` 메서드가 제대로 작동하지 않는다. 특히 우리 프로젝트에서는 id 기반으로 `equals()`, `hashcode()` 를 적용해두어 더 그랬다... id가 변경되면 해시 값이 변경되기 때문에!\n\t- 이 문제를 해결하기 위해서는 동일성 메서드를 재정의 하지 않거나, 영속화 후에 연관 관계를 맺어야 한다. (아니면 Set을 안 쓰는 방법도.. `List` 를 쓸 수 있다면)\n\n## 궁금한 것\n\n## 느낀 것\n- 집중력의 한계가 느껴진다...... 오늘 4시간 회의 했는데 (50분 회의 10분 휴식) 3번째 회의부터는 집중이 잘 안 되는 게 느껴졌다. 휴식을 하려면 좀 길게 해야 할 거 같다. 휴식을 할 때도 어디에 집중하고 있지 말고 잡담을 하거나 가만히 있어보자."},{"excerpt":"LOG 스플릿, 바론, 아코와 함께 코드 리뷰를 했다. 굉장히 다들 꼼꼼하게 리뷰를 남겨주어서 (본인) 시간이 오래걸렸다;; 그렇지만 뿌듯했다. 방 청소했다. 화장실 청소, 싱크대 청소, 책상 청소, 침대 청소, 바닥 청소를 했다;;; 한 5시간 정도 걸린 거 같다... 사실 그러고도 좀 남았다 ㅋㅎ 배운 것 궁금한 것 느낀 것","fields":{"slug":"/2023-07-17/"},"frontmatter":{"date":"2023년 07월 17일 07:07","title":"2023년 07월 17일","tags":null},"rawMarkdownBody":"\n## LOG\n- 스플릿, 바론, 아코와 함께 코드 리뷰를 했다. 굉장히 다들 꼼꼼하게 리뷰를 남겨주어서 (본인) 시간이 오래걸렸다;; 그렇지만 뿌듯했다.\n- 방 청소했다. 화장실 청소, 싱크대 청소, 책상 청소, 침대 청소, 바닥 청소를 했다;;; 한 5시간 정도 걸린 거 같다... 사실 그러고도 좀 남았다 ㅋㅎ\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"브랜치에서 작업한 내용을 다른 브랜치에 병합할 수 있는 방법은 다양하다. 그 중 Merge commit, Squash and Merge, Rebase and Merge 에 대해 알아보자. Merge commit Github의 기본 merge 전략이다. 코드가 변경된 시기와 위치를 포함하여 코드의 전체 기록을 유지하려는 경우에 유용하다. 비파괴 작업으로, …","fields":{"slug":"/github-merge-strategy/"},"frontmatter":{"date":"2023년 07월 15일 04:07","title":"Github merge 전략","tags":["shook","레벨3","github","우테코"]},"rawMarkdownBody":"\n브랜치에서 작업한 내용을 다른 브랜치에 병합할 수 있는 방법은 다양하다.    \n그 중 Merge commit, Squash and Merge, Rebase and Merge 에 대해 알아보자. \n\n## Merge commit\n\nGithub의 기본 merge 전략이다.   \n코드가 변경된 시기와 위치를 포함하여 코드의 전체 기록을 유지하려는 경우에 유용하다.    \n비파괴 작업으로, 모든 커밋의 기록을 그대로 유지한다. merge 작업을 포함한 모든 변경 사항에 대한 기록을 남긴다.    \n\nCommit log는 커밋을 행한 순서대로 기록되고, Merge log는 merge가 된 순서대로 기록된다.    \n즉, commit log의 순서가 merge 순서와 다를 수 있다. \n\n### 예시\n\ncommit 시간 순서: A - B - AC - BD      \nA 브랜치 commit 순서: A - AC     \nB 브랜치 commit 순서: B - BD      \n\nB 브랜치가 A 브랜치보다 main에 merge가 먼저 된 경우, main의 commit log는 다음과 같다.\n\nA - B - AC - BD - B merge commit - A merge commit\n\n### 단점\n\n여러 분기가 자주 병합되는 경우, Git history 가 복잡해질 수 있다.    \n\n## Squash and Merge\n\n합쳐지는 브랜치의 모든 커밋이 merge 대상 브랜치 (main) 의 하나의 커밋으로 결합된다.    \n스쿼시된 커밋의 커밋 메시지는 기본적으로 스쿼시된 모든 커밋의 커밋 메시지 조합이 되지만, 수동으로 변경할 수 있다.    \n\n기능 당 하나의 커밋으로 main 의 commit log를 선형적이고 깨끗하게 유지하려는 경우 (히스토리 관리가 쉽다), feature 브랜치의 개별 커밋의 세부 정보가 유지 관리에 중요하지 않은 경우에 사용하면 좋다.    \n\n### 예시\n\ncommit 시간 순서: A - B - AC - BD   \nA 브랜치 commit 순서: A - AC   \nB 브랜치 commit 순서: B - BD    \n\nB 브랜치가 A 브랜치보다 main에 merge가 먼저 된 경우, main의 commit log는 다음과 같다.\n\n`<main>` \nB squashed commit(B-BD 커밋 메시지) - A squashed commit(A-AC 커밋 메시지)\n\n### 단점\n\n자세한 커밋 기록이 사라지게 된다.    \n개별 커밋을 보존하는 것이 프로젝트 기록에 중요한 경우 Squash and Merge가 올바른 선택이 아닐 수 있다.    \n\n또한 여러 작성자가 기능에 기여한 경우, 모든 커밋을 하나로 스쿼시하면 해당 정보가 손실된다.    \n\natomic commit level로 rollback 이 불가능하다.    \n\n## Rebase and Merge\n\ncommit 순서가 아닌, merge 순서대로 기록되므로 하나의 PR에 담긴 commit message 가 다른 PR의 commit message 와 섞이지 않는다.    \n\nrebase 를 사용하므로 merge 된 이후의 로그를 보았을 때, main에서 연속적으로 작업한 것과 같은 로그를 확인할 수 있다. 따라서 언제든지 atomic commit level 로 rollback 을 수행할 수 있다.    \n\n### 예시\n\ncommit 시간 순서: A - B - AC - BD      \nA 브랜치 commit 순서: A - AC     \nB 브랜치 commit 순서: B - BD     \n\nB 브랜치가 A 브랜치보다 main에 merge가 먼저 된 경우, main의 commit log는 다음과 같다.\n\n`<main>` \nB - BD - A - AC\n\n### 단점\n\nrebase 를 사용하면 특정 커밋의 부모 커밋을 바꿔서 커밋이 새로운 시점에서 시작된 것처럼 보이게 만든다.     \n\nfeature 브랜치에서 작업 중인 다른 개발자가 작업하는 경우에도 문제가 될 수 있다. feature의 로컬 복사본이 리베이스 후 원격 레포지토리와 동기화되지 않기 때문이다.    \n로컬 브랜치와 원격 브랜치가 동일한 시점에서 시작하지 않기 때문에, Git이 local의 push를 거부하게 된다. push를 위해서는 로컬 브랜치를 원격 브랜치와 동기화하거나, force push를 수행해야 할 수도 있다.    \n\nrebase를 시작하기 전에 원격 레포지토리와 제대로 동기화가 되지 않은 경우, 커밋이 손실될 수 있다.    \n그러므로 rebase는 개인 local의 브랜치의 정리를 위해 사용하거나, 작업을 main 브랜치 또는 다른 브랜치에 merge 하기 전에 사용하는 것을 권장된다.    \n\n### 결론?\n\n상황에 따라 사용해야 할 듯 하다.    \n우리는 Github Flow 로 진행하고 있기 때문에, main 에 커밋이 다 쌓이면 지저분할 것 같아서 Squash merge 전략을 사용하고 있다.     \n\n## Conflict 해결하기\n\n프로젝트를 진행하다보면 같은 파일을 수정하는 경우가 발생할 수 있다.    \n가장 베스트는 그런 일이 일어나지 않는 것이지만, 작업 분할이 항상 완벽하게 이루어지지는 않는다.    \n그런 경우에는 다른 작업자와의 conflict를 해결해야만 한다.    \n\n어떤 방법이 있을까?\n\n### 상황 가정\n\n(여기서부터는 존댓말로 작성합니다)\n\n**실제로 있었던 일임을 밝힙니다.**\n\n체모 크루, 주모 크루와 함께 작업을 했을 때의 일입니다. 애석하게도 일정의 압박으로 각자 기능을 시작할 수 밖에 없었기에 각자 다른 시점에 개발을 시작했습니다.    \n\n'체'는 A 기능을 만들고 있었고, '주'는 B 기능을 만들고 있었습니다.     \n저는 C 기능을 개발하던 중, A와 B의 기능이 필요하다는 것을 알게 되었습니다.    \n일단 개발한 기능을 원격에 push 한 후, 체와 주의 기능 merge를 기다렸습니다.    \n\n모든 기능이 merge되고 dev를 pull 하는 순간, 무수한 conflict와 무수한 파일 add 가 생성된 것을 보고 이것은 뭔가 잘못됐다고 느꼈습니다.    \n\n제 작업 브랜치가 원격 브랜치와 동기화되지 않아, pull을 하는 순간 git이 모두 새로운 파일이라 판단한 것입니다.\n\n저는 로컬 C 브랜치에 dev를 rebase 한 후, 원격 C 브랜치에 force push 하는 방식으로 해결했지만 다른 방법도 있습니다.    \n\n### Cherry Pick\n\nA와 B가 반영된 원격 dev 브랜치에서 새로운 new_dev 브랜치를 생성한 후, 체크아웃합니다.    \n그 후, C 브랜치에서 제가 작업했던 내용을 cherry pick 합니다. (rebase와 마찬가지로 conflict는 해결해야 합니다. )    \n\n이미 원격 저장소에는 C 브랜치가 존재하지만, new_dev 브랜치를 원격에 push한 후, 'new_dev'를 main에 머지합니다.     \n\nC 브랜치가 아니라는 점이 걸리기는 하지만, force push를 하지 않는다는 점에서 장점을 갖고 있습니다.    \n\nGPT의 답변은 다음과 같았습니다.    \n\n```text\n체리 피킹은 일반적으로 한 브랜치에서 다른 브랜치로 적은 수의 커밋을 통합하는 데 사용됩니다. 더 큰 선택성과 제어가 가능하지만 커밋이 많으면 번거로울 수 있습니다.\n\n반면 리베이스는 한 브랜치의 모든 변경 사항을 다른 브랜치로 통합하려는 경우에 자주 사용됩니다. 브랜치에 일련의 커밋이 있고 선형 방식으로 메인 브랜치에 통합하려는 상황에 더 적합합니다.\n```\n\n커밋이 적은 경우에만 Cherry Pick을 사용하고, 브랜치의 모든 변경 사항을 다른 브랜치로 통합하는 경우에는 rebase가 더 적합한 듯 합니다.     \n\n역시 상황에 따라 맞게 사용하는 것이 좋아보이네요.     \n\n## 참고\n- https://inmoonlight.github.io/2021/07/11/Git-merge-strategy/\n- https://chat.openai.com/share/d8d773a5-8ccc-4366-9735-cd8fdbb89b3b"},{"excerpt":"CODEOWNERS? 매번 PR을 올릴 때마다 리뷰어를 넣어주는 게 귀찮다. 그러니 리뷰어를 자동으로 등록해주는  를 사용해보자! 등록하기 ,  중 한 곳에  파일을 생성한 후, 리뷰어를 지정한다. 우리는  하위에 생성했다. 파일은 다음과 같다. shook 레포지토리는 frontend와 backend가 레포지토리를 공유하는 형태이다. 우리는 소속된 파트의…","fields":{"slug":"/github-codeowners/"},"frontmatter":{"date":"2023년 07월 15일 04:07","title":"Github CODEOWNERS로 PR 리뷰어 자동 할당하기","tags":["shook","github","우테코","레벨3"]},"rawMarkdownBody":"\n## CODEOWNERS?\n\n매번 PR을 올릴 때마다 리뷰어를 넣어주는 게 귀찮다.    \n그러니 리뷰어를 자동으로 등록해주는 `CODEOWNERS` 를 사용해보자!\n\n### 등록하기\n\n`docs/`, `.github/` 중 한 곳에 `CODEOWNER` 파일을 생성한 후, 리뷰어를 지정한다.    \n우리는 `.github/` 하위에 생성했다.    \n\n파일은 다음과 같다.\n\n```text\n# Frontend  \n/frontend/ @Creative-Lee @ukkodeveloper @cruelladevil  \n  \n# Backend  \n/backend/ @Cyma-s @splitCoding @somsom13 @seokhwan-an\n```\n\nshook 레포지토리는 frontend와 backend가 레포지토리를 공유하는 형태이다.    \n우리는 소속된 파트의 모두의 approve를 받아야 PR을 머지할 수 있다는 규칙을 정했다.     \n따라서 `/frontend/` 하위의 모든 파일들에 대해서는 프론트엔드 크루들을 지정하고, `/backend/` 하위의 모든 파일들에 대해서는 백엔드 크루들을 지정했다.    \n\n### 사용해 본 결과 ...\n\n각 파일 하위에 변경 사항이 추가되면 자동으로 코드 리뷰어가 추가 되어 훨씬 편하게 개발할 수 있었다. 추천합니다 👍"},{"excerpt":"배운 것  에도 빈 생성자가 필요하다.","fields":{"slug":"/2023-07-14/"},"frontmatter":{"date":"2023년 07월 14일 04:07","title":"2023년 07월 14일","tags":null},"rawMarkdownBody":"\n\n\n## 배운 것\n\n- `@Embeddable` 에도 빈 생성자가 필요하다."},{"excerpt":"LOG 배운 것 2차원 배열 누적합을 계산하는 방법 궁금한 것 느낀 것 알고리즘이 풀기 싫을 때도 있는데 그게 오늘~ 다른 날이라면 10분만에 풀었는데 !!!!! 많이 봐줬다 짜식","fields":{"slug":"/2023-07-13/"},"frontmatter":{"date":"2023년 07월 13일 15:07","title":"2023년 07월 13일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n- 2차원 배열 누적합을 계산하는 방법\n\n```python\nsum_arr = [[0] * (m+1) for _ in range(n+1)] \nfor i in range(1, n+1): \n\tfor j in range(1, m+1): \n\tsum_arr[i][j] = arr[i-1][j-1] + sum_arr[i-1][j] + sum_arr[i][j-1] - sum_arr[i-1][j-1]\n```\n\n## 궁금한 것\n\n## 느낀 것\n- 알고리즘이 풀기 싫을 때도 있는데 그게 오늘~ 다른 날이라면 10분만에 풀었는데 !!!!! 많이 봐줬다 짜식"},{"excerpt":"S-HOOK의 최우선 페르소나 문제점 데모데이 이후에 고려해봤었던 '일반인' 페르소나의 needs는 우리가 충족시켜줄 수 없다. need를 만족하기 위해서는 어떤 방법이든 곡 추천을 해야 한다. 그러나 우리가 추천을 해줄 수 있는 방법은 없다. 우리가 직접적으로 추천을 해주지 않는다고 하더라도, 우리의 '간접적인' 추천은 (킬링 파트의 투표를 보고 그 음…","fields":{"slug":"/shook-persona/"},"frontmatter":{"date":"2023년 07월 12일 12:07","title":"S-HOOK 페르소나","tags":["shook","기획","레벨3"]},"rawMarkdownBody":"\n## S-HOOK의 최우선 페르소나\n\n### 문제점\n\n- 데모데이 이후에 고려해봤었던 '일반인' 페르소나의 needs는 우리가 충족시켜줄 수 없다. \n\t- need를 만족하기 위해서는 어떤 방법이든 곡 추천을 해야 한다. 그러나 우리가 추천을 해줄 수 있는 방법은 없다.\n\t- 우리가 직접적으로 추천을 해주지 않는다고 하더라도, 우리의 '간접적인' 추천은 (킬링 파트의 투표를 보고 그 음악이 좋다고 생각하든지 안 하든지 간에) 일반인 페르소나에게 pain point가 되지 않는다.\n\t- 일반인의 pain point를 해결하는 서비스는 시중에 너무나도 많다. (꼭 새로운 서비스가 아니어도 되지만, 우리만의 특별한 기능을 특별하게 꼽기 어렵다)\n\t- 일반인을 위한 기능을 제공해주기 어렵다. 듣기와 좋은 음악을 찾기 원하는 페르소나이다 보니, 일반인이 최우선 페르소나가 되는 경우 추천과 듣기에 집중된 기능을 개발해야 한다. 그러나 현실적으로 듣기가 매우 어렵고, 듣는 방법을 유튜브 링크로 한정하는 경우도 마찬가지로 일반인의 pain point를 채워줄 수 없다.\n\t- 일반인이 최우선 페르소나가 된다면 '킬링파트 듣기'가 최우선 개발 기능이 되어야 할 것 같다.\n- 팬덤을 공략하는 방법\n\t- 우리의 주변에는 팬덤이 없기 때문에 실제로 팬덤이 어떤 니즈를 갖고 있는지 알 수 없다. 우리가 팬덤을 위해 어떤 것을 제공할 수 있는가? 팬덤이 원하는 것은 어떤 것인가?\n\t- 비교할 만한 표본이 없고, 다른 서비스에서 제공하는 것들 (1위를 하면 광고를 해준다던지) 을 제공하기는 어렵다. \n\t- 이용자 수를 늘리기 위해 팬덤 측에 마케팅을 시도하는 것 자체는 좋지만, 팬덤이 페르소나이자 메인 이용자가 되어서는 안 된다고 생각한다. 우리는 팬덤의 니즈를 해결하기 어렵다. (아직 니즈가 뭔지도 잘 모르기 때문에...)\n\n### 그래서...\n\n페르소나는 보편적일 필요는 없다. 그러나 우리 주변에서 볼 수 있거나, 어딘가에서 봤거나, 들어봤어야 한다.\n\n우리는 무슨 가치를 사용자에게 전달하고 싶나?\n우리의 애플리케이션을 통해 어떤 것을 얻어 가기를 원하는가?\n왜 사용자가 우리의 서비스를 사용할 수 밖에 없을까?\n\n서비스의 사용을 구걸하지 말고, 자연스럽게 사용할 수 있도록 해야 한다.\n\n### '킬링파트를 공유하는 것'이 우리의 사용자에게 어떤 가치를 전달할 수 있을까?\n\n=> 타인에게 인정받고자 하는 욕구, 내가 추천한 노래를 다른 사람들이 좋아했을 때 기쁨을 느낀다. 내가 추천한 킬링파트를 다른 사람들이 인정할 때 (투표가 많이 달렸을 때)\n=> 내가 음잘알이다. 내가 이렇게 힙한 노래를 많이 안다.\n=> 누구나 아는 명곡보다는 나만의 명곡을 공유하는 경우가 많다.\n=> 내가 음잘알인 것을 알리고 싶다.\n\n-> 내가 추천한 노래를 다른 사람들이 들어보고 좋아했는지를 알려준다면?\n-> 킬링파트 공유자의 인정욕/과시욕을 채워줄 수 있는 기능이 필요할 것 같다. \n\n### '킬링파트를 공유받는 것'이 우리의 사용자에게 어떤 가치를 전달할 수 있을까?\n\n=> 도입부부터 들었다면 별로였을 노래가 좋은 노래라는 걸 알 수도 있다.\n=> 처음 접하는 노래인 경우 좋은 노래인지 아닌지 다른 사람들의 보편적인 좋은 부분을 통해 바로 판단할 수 있다.\n=> 만약 이전에 들어본 노래인데 별로라고 생각했던 경우 굳이 검색해서 안 찾아볼 거 같다.\n=> 이전에 들어본 노래가 인기곡에 있다면 들어볼 듯. (인터뷰에 기반한 내용)\n-> 노래를 검색해서 킬링파트를 찾아보게 하는 건 별로 좋지 않은 것 같다. 킬링파트를 공유받는 사람의 경우 주로 이전에 들어보지 않은 새로운 노래의 킬링파트를 듣는 것을 선호하지 않을까?\n-> 인기곡으로 들어와서 다른 노래로 이어지게 하는 플로우는 어려울 수도 있다. 이 사람의 취향을 알지 못하면 그냥 아무 노래나 띄워줄 수밖에 없다.\n\n이 노래가 내 취향인지 아닌지를 빠르게 파악한다. => 추천이 필요가 없다.\n\n## 3차 데모데이 페르소나\n\n### 등록과 공유를 분리한 서비스\n\n등록의 만족감보다 공유의 만족감에 초점을 맞추자.    \n등록할 때는 딱히 뭐 없다.\n회원이 등록한 파트를 공유하면 지인들이 댓글을 달아준다던지, 공감을 할 수 있다.\n등록하지 않아도 조회를 할 수 있다. (회원, 비회원 모두)\n\n취향 아카이빙 쪽 서비스가 된다. 아카이빙된 킬링파트들을 보고 다른 사람들이 공감할 수 있는.\n\n우리 서비스에서 제공하는 가치가 희석될 수 있다. (공유면 공유, 등록이면 등록, 조회면 조회가 아니고, 모든 서비스를 약간씩 서빙하는 느낌?)\n\n### 노래 순위 맞추기 서비스\n\n등록하기 전에는 킬링파트를 볼 수 없다.\n등록하고 난 후, 킬링파트를 조회할 수 있다.\n다른 사람들이 좋아하는 파트인지에 대한 정보(등록한 파트의 순위)를 제공한다.\n\n내 순위를 높이는 데에만 목표를 둘 것 같다. 내가 좋아하는 부분이 아닌 대중적인 부분을 찾는 것을 목표로 하게 될 듯하다.\n'다른 사람에게 내가 등록한 파트를 공감받는다' 라는 가치를 버려야 한다.\n비회원에게 줄 수 있는 가치가 적다.\n\n### 빠르게 노래를 듣는 서비스 (메인이 아님 -> 부가가치)\n\n우리의 서비스로부터 얻을 수 있는 부가가치로 간주한다.\n\n### 공유란?\n\n초기 공유: 킬링파트가 어디인지 알리는 거\n'특정 대상에게 공유'가 나오면서 서비스 크기가 좀 커졌다. -> 만족감이라는 키워드가 나오면서 커졌다.\n만족감을 주기 위해서 공유를 택했는데, 공유가 들어오니 공유를 위한 기능들이 추가되고 있다.\n아카이빙도 공유를 위해 등장한 것.\n노래의 킬링파트를 알려주는 것 -> 내가 좋아하는 부분을 공유하는 것도 추가 됨\n다른 사람들이 좋아하는 파트 조회 -> 내가 좋아하는 파트를 조회하는 것도 추가 됨\n\n킬링파트 등록과 조회 / 내가 좋아하는 부분 공유 => 다 담으려고 하는 중\n-> 둘은 다른 서비스다.\n\n우선순위를 정하자. 두 개를 다 가져가려면 뭐를 먼저 할 지 우선순위가 필요하다. 동시 개발은 안 됨.\n\n킬링파트로 얻는 만족감과 내가 등록한 파트에서 얻는 만족감 => 연관 관계가 없다.\n\n킬링파트 등록과 조회는 어디까지 담는 서비스?\n-> 단순히 킬링파트를 등록하고, 사람들이 와서 킬링파트를 볼 수 있는 서비스 => 이번에 조회를 하게 되면 등록과 조회를 하면 이 부분은 충족이 된다.\n\n등록과 조회를 메인으로 생각한다면 왜 등록을 할까?\n등록 과정에서 가치(만족감)를 부여해주기 위해서 공유가 등장했는데, 커지는 느낌이다.\n-> 실제로 듣는 사람들이 만드는 킬링파트\n-> 기존의 공유는 파트를 공유한 게 아니라 내가 등록한 정보를 공유할 뿐이다.\n-> 데모만 봤을 때는 페이지가 아니라 플레이할 수 있는 url을 공유한 것 아닌가? => 우리가 이 파트를 들어보라고 했지, 이 파트에 대한 정보를 준 것이 아니다. 따라서 파트에 대한 정보를 갖고 있을 필요 없다. \n\n비회원이 다 조회를 할 수 있게 만들거면, 회원은 어떤 플로우를 가질 것인가.     \n회원이 조회가 가능하다면 만족감을 가질 수 있을 것인가?\n\n회원이 등록 전에 조회를 하면 만족감을 얻을 수 없다.\n\n---\n킬링파트는 내가 좋아하는 부분이 아니라, 사람들이 좋아하는 부분이다.\n\n내가 좋아하는 부분을 공유하고 싶은 사람\n사람들이 좋아하는 부분을 알고 싶은 사람\n"},{"excerpt":"LOG 비가 많이 왔다. 비 좀 그만 왔으면 좋겠다. 오늘은 다행히 덥지는 않았는데 약간 추웠다. 반바지 입고 와서 그랬던 걸지도... 애쉬, 비버, 포이와 매드 후라이 치킨에서 저녁을 먹었다. 선릉은 맛있는 곳만 있나 ㅋㅋ 어제 갔던 곳도 맛있었는데 오늘도 맛있어서 좋았다. 점심은 라면을 먹었다. 라면에 계란을 넣으려고 계란을 부쉈(?)는데 너무 박살나…","fields":{"slug":"/2023-07-11/"},"frontmatter":{"date":"2023년 07월 11일 01:07","title":"2023년 07월 11일","tags":null},"rawMarkdownBody":"## LOG\n- 비가 많이 왔다. 비 좀 그만 왔으면 좋겠다. 오늘은 다행히 덥지는 않았는데 약간 추웠다. 반바지 입고 와서 그랬던 걸지도...\n- 애쉬, 비버, 포이와 매드 후라이 치킨에서 저녁을 먹었다. 선릉은 맛있는 곳만 있나 ㅋㅋ 어제 갔던 곳도 맛있었는데 오늘도 맛있어서 좋았다.\n- 점심은 라면을 먹었다. 라면에 계란을 넣으려고 계란을 부쉈(?)는데 너무 박살나서 계란이 용기에 흘러 내렸다.. 용기가 타지 않게 하려고 busy waiting 하면서 라면을 제조할 수 밖에 없었다. 조금 아쉽. 계란은 완전히 분해돼서 먹을 수 없었다 ㅋㅋ\n- 스플릿, 아코, 바론과 함께 도메인 설계를 했다. 각자 구상해온 도메인 클래스를 취합하고, DB 스키마도 만들었다. 오랜만에 코드 관련 이야기 하니까 너무 재밌었다. \n\n## 배운 것\n- 맥북에서 날씨 앱을 왼쪽에 열어두고 오른쪽에 다른 창을 열고 포커스를 다른 창에 맞추면 날씨 앱에 비 오던게 천천히 멈춘다 ㄷㄷ\n- 일정 추정하기 \n\t- 팀 요구사항이 있고, 기한이 존재하기 때문에 이를 충족해야 한다.\n\t- 그러나 정확한 프로젝트 일정 추정은 사실상 불가능하기 때문에, 포기하기보다는 숙달하는 것이 중요하다.\n\t- 프로젝트를 더 작은 작업으로 분해하라. 긴 추정치에는 예상 밖의 문제가 숨어든다. 작업을 더 잘게 나눌수록 예상치 못한 하위 작업이 나타날 가능성이 줄어든다.\n\t- 추정은 최상의 시나리오가 아닌 확률 분포로 생각하자. 우리가 의존하는 정보는 불완전하므로 최상의 시나리오부터 최악의 시나리오를 아우르는 결과 범위에 대한 확률 분포라고 생각해야 한다.\n\t- 구체적인 목표와 측정 가능한 마일스톤을 정의하자. 목표를 잘 정의해두면 작업 목록에서 꼭 해야 할 일과 하면 좋은 일을 구분하는 중요한 필터가 된다. 목표를 구체적으로 정의하면 명확성과 공통의 이해가 형성된다. 측정 가능한 마일스톤은 목표를 향해 제대로 가고 있는지 주기적으로 확인하는데 도움이 된다.\n\t- 작은 작업 단위와 적당한 마일스톤 기간. 처음부터 잘 할 수 없기 때문에 작은 작업 단위와 적당한 마일스톤 기간은 빠르게 실패를 할 수 있게 도와준다. 앞 마일스톤에서 경험한 것을 바탕으로 다음 마일스톤 일정을 계획한다. \n- commit 에 `#이슈-번호` 를 붙이면 이슈에 commit 이 쌓인다 ㄷㄷ by 아코\n- `@Embbedded`, `@Embeddable`\n\t- `@Embeddable` 사용할 거면 안에 사용할 값에 `@Column` 을 달아줘야 한다.\n- `@ManyToOne` 의 `fetch` 의 기본 타입은 `FetchType.EAGER` 다.\n- `@OneToMany` 의 `fetch` 의 기본 타입은 `FetchType.LAZY` 이다.\n\n## 궁금한 것\n\n## 느낀 것\n- 독성 말투를 주의하자. 습관적으로 부정적인 말을 하는 것을 경계한다. 언제나 기분이 좋을 필요는 없지만 언제나 기분이 안 좋을 이유도 없다.\n- 노력하는 것에 익숙해지자."},{"excerpt":"미니멈 프로젝트가 성공하기 위해 반드시 일어나야 하는 최소한의 일. 성실하게 작업을 수행한다면 거의 90% 확실하게 일어날 수 있는 일들. 우리가 반드시 이 고통은 해결해야 한다. 목표를 잘 설정할 수 있게 도와주는 가이드를 기능적으로 제공한다. 매 데모데이때마다 이 기능은 동작해야함. 타겟이 있어야 함 이런 일이 일어나기를 바라는 것, 어렵지만 달성 가…","fields":{"slug":"/wooteco-ux/"},"frontmatter":{"date":"2023년 07월 10일 05:07","title":"UX 특강","tags":["우테코"]},"rawMarkdownBody":"## 미니멈\n- 프로젝트가 성공하기 위해 반드시 일어나야 하는 최소한의 일. 성실하게 작업을 수행한다면 거의 90% 확실하게 일어날 수 있는 일들. 우리가 반드시 이 고통은 해결해야 한다.\n- 목표를 잘 설정할 수 있게 도와주는 가이드를 기능적으로 제공한다. 매 데모데이때마다 이 기능은 동작해야함.\n\n## 타겟이 있어야 함\n- 이런 일이 일어나기를 바라는 것, 어렵지만 달성 가능한 목표여야 함. 부지런히 노력한다면 60%이상 실현 가능성\n- 목표를 더 잘 달성할 수 있게끔, 긴박감을 줄 수 있는 타이머와 중간 회고를 도와주는 기능이 동작한다.\n\n## 에픽\n\n상상을 뛰어넘는 성공의 모습입니다. 일반적으로 모든 사람이 처음에 스스로 검열하므로 이 목표를 두 번 채워 보세요. 부끄러워하지 마세요! 그리고 이 과정에서 자신이 정말 중요하게 생각하는 것을 상상해 보는 것도 좋습니다.\n\n- 스터디를 하고 싶어 하는 많은 사람들이 공부해 서비스에 참여해서 게임 대기처럼 참여하는 플랫폼으로 만든다.\n\n비타민이어도 되는데, 비타민이면 성공 확률이 확 낮아진다.\n\n## 세 줄 요약\n\n- 우리 서비스의 핵심 기능이 비타민인가? 진통제인가? 고민해본다.\n- 2차 데모데이 이후 UX 워크숍에서 예비 사용자를 설득하기 위한 서비스 소개 글을 작성할 예정이다.\n- 진통제 같은 기능, 핵심을 잘 드러내고 고민해보는데 목표를 3단계로 정리해보면 더 또렷하게 잘 보이더라.\n- 고통을 발견하는 것까지는 쉬운데, 진통제는 어떻게 발견하지? 고통을 발견하면 그 고통을 잘 해결하는 사람이 누가 있지?\n"},{"excerpt":"LOG 저녁에 망고, 토리, 주노, 포이와 같이 족발을 먹으러 갔다. 맛집 코드에서만 보던 뽕나무쟁이에 갔는데 진짜 맛있긴 했다. 근데 불족발 너무 매웠다 ㅋㅋㅋ 김치찌개도 맛있었어서 다음에도 가고 싶다. 배운 것 궁금한 것 느낀 것","fields":{"slug":"/2023-07-10/"},"frontmatter":{"date":"2023년 07월 10일 04:07","title":"2023년 07월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 저녁에 망고, 토리, 주노, 포이와 같이 족발을 먹으러 갔다. 맛집 코드에서만 보던 뽕나무쟁이에 갔는데 진짜 맛있긴 했다. 근데 불족발 너무 매웠다 ㅋㅋㅋ 김치찌개도 맛있었어서 다음에도 가고 싶다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG 드디어 못 풀어내던 LIS 알고리즘을 어느 정도 감을 잡은 것 같다. 바이토닉 수열 문제는 내 힘으로 못 풀었지만.. 그것보다 쉬운 전깃줄 문제는 5분 만에 풀어냈다! 얼마나 기억을 유지할 수 있을지... 이분탐색으로 LIS 푸는 거 이해했다고 생각했는데 또 그렇지도 않은 것 같아서 슬픔 ㅠ 배운 것 dp로 LIS 풀기 i번째보다 작은 값들을 돌면…","fields":{"slug":"/2023-07-09/"},"frontmatter":{"date":"2023년 07월 09일 10:07","title":"2023년 07월 09일","tags":null},"rawMarkdownBody":"\n## LOG\n- 드디어 못 풀어내던 LIS 알고리즘을 어느 정도 감을 잡은 것 같다. 바이토닉 수열 문제는 내 힘으로 못 풀었지만.. 그것보다 쉬운 전깃줄 문제는 5분 만에 풀어냈다! 얼마나 기억을 유지할 수 있을지... 이분탐색으로 LIS 푸는 거 이해했다고 생각했는데 또 그렇지도 않은 것 같아서 슬픔 ㅠ\n\n## 배운 것\n\n- dp로 LIS 풀기\n\n```python\ndp = [1 for _ in range(n)]  \nfor i in range(n):  \n    for j in range(i):  \n        if arr[i] > arr[j]:  \n            dp[i] = max(dp[i], dp[j] + 1)\n```\n\ni번째보다 작은 값들을 돌면서 현재 i 값보다 작은 경우 현재 dp 값, 이전 dp값 + 1 중 최댓값을 확인한 후 업데이트한다."},{"excerpt":"LOG 토스 코테를 봤다. 1,2,3,4를 건드려 봤는데 1,2번만 맞췄다. 3, 4번도 단순 구현 문제 같았는데 아직 알고리즘 능력치가 안 쌓여서 그런지 허둥댄 시간이 많았다. 내공을 길러서 허둥대지 않고 알고리즘 푸는 방법을 터득해야겠다. 밖에 있으면 끈적거려서 기분 나쁘고, 안에 오래 있으면 에어컨 때문에 너무 춥다.. 어디에 장단을 맞춰야 하는지 …","fields":{"slug":"/2023-07-08/"},"frontmatter":{"date":"2023년 07월 09일 10:07","title":"2023년 07월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 토스 코테를 봤다. 1,2,3,4를 건드려 봤는데 1,2번만 맞췄다. 3, 4번도 단순 구현 문제 같았는데 아직 알고리즘 능력치가 안 쌓여서 그런지 허둥댄 시간이 많았다. 내공을 길러서 허둥대지 않고 알고리즘 푸는 방법을 터득해야겠다.\n- 밖에 있으면 끈적거려서 기분 나쁘고, 안에 오래 있으면 에어컨 때문에 너무 춥다.. 어디에 장단을 맞춰야 하는지 모르겠다;;\n- 사시미 먹었는데 맛있었다. 나도 와사비를 먹을 수 있게 되었다. 엄마 보고 있나.."},{"excerpt":"LOG 점심으로 라면을 먹었다. 싸다김밥의 싸다는 cheap이 아니라 wrap이었다고 한다. by 바론 선호, 수민 언니, 세진과 뚝섬에서 파스타를 먹었다. 사실 그렇게 맛있진 않았다..ㅋㅋㅋ 토마토 파스타가 맛이 없기 쉽지 않은데 배운 것 repository flush를 하면 dirty checking을 확인할 수 있다.  은 '다' 쪽의 외래 키 관리…","fields":{"slug":"/2023-07-06/"},"frontmatter":{"date":"2023년 07월 06일 01:07","title":"2023년 07월 06일","tags":null},"rawMarkdownBody":"## LOG\n- 점심으로 라면을 먹었다. 싸다김밥의 싸다는 cheap이 아니라 wrap이었다고 한다. by 바론\n- 선호, 수민 언니, 세진과 뚝섬에서 파스타를 먹었다. 사실 그렇게 맛있진 않았다..ㅋㅋㅋ 토마토 파스타가 맛이 없기 쉽지 않은데\n\n## 배운 것\n\n- repository flush를 하면 dirty checking을 확인할 수 있다.\n\n- `@OneToMany(mappedBy = \"필드이름\")` 은 '다' 쪽의 외래 키 관리자를 명시해주는 것.\n- 연관 관계의 주인을 정한다는 것은 외래 키 관리자를 선택하는 것. 비즈니스 중요도로 접근하면 안 된다. 다대일, 일대다 관계에서는 항상 '다' 쪽이 외래 키를 가진다.\n- 연관 관계의 외래키 관리자가 아닌 경우, 읽기 권한만 갖는다. Station과 Line의 연관 관계를 맺고 싶은 경우, 다음과 같이 사용한다.\n\n다음은 예외가 발생하지 않는다. (Station 쓰기가 안 됨)\n\n```java\n@Test  \nvoid save() {  \n   final Line line = new Line(\"2호선\");  \n   line.addStation(new Station(\"신도림역\"));  \n   lines.save(line);  \n   lines.flush();  \n}\n```\n\n다음 방법은 스택 오버플로우가 발생할 위험이 있다.\n\n```java\n// Line.class\npublic void addStation(final Station station) {  \n   station.setLine(this);  \n   stations.add(station);  \n}\n\n// Station.class\npublic void setLine(final Line line) {  \n   this.line = line;  \n   line.getStations().add(this);  // 여기서 발생\n}\n\n// 다음처럼 바꾸면 된다.\npublic void setLine(final Line line) {\n\tthis.line = line;\n\tfinal List<Station> stations = line.getStations();\n\t\n\tif(!stations.contains(this)) {\n\t\tstations.add(this);\n\t}\n}\n```\n\n- 연관 관계 매핑을 안 하면 중간 테이블이 생긴다.\n\n```shell\nHibernate: \n    \ncreate table member_favorites (\n   member_id bigint not null,\n\tfavorites_id bigint not null\n)\n```\n\n연관 관계 매핑을 하면 '다' 쪽에 컬럼이 추가된다.\n\n```shell\ncreate table favorite (\n   id bigint generated by default as identity,\n\tmember_id bigint,\n\tprimary key (id)\n)\n\nHibernate: \n    \nalter table favorite \n   add constraint FK5w3q9ljpthkixo71hetx3ired \n   foreign key (member_id) \n   references member\n```\n\n연관 관계 공부하려면 `@JoinColumn` 파보면 좋을 듯 by 제이슨\n\n일대다 단방향 매핑보다는 다대일 양방향 매핑을 권장한다고 한다? (JPA 관점)\nbut 실무 관점에서는 일대다 단방향을 쓰는 경우도 있다.\n\n## 궁금한 점\n\n## 느낀 점\n- 아침을 먹고 가니까 좋다.\n- 로고 디자인 좀 더 깔끔하게 해봐야겠다."},{"excerpt":"LIS 길이 구하기 이분탐색 C++ Python LIS의 원소 구하기 이분탐색 참고 https://maramarathon.tistory.com/57","fields":{"slug":"/lis/"},"frontmatter":{"date":"2023년 07월 05일 13:07","title":"LIS - 가장 긴 증가하는 부분 수열","tags":["알고리즘","이분탐색","DP"]},"rawMarkdownBody":"\n## LIS 길이 구하기\n\n### 이분탐색\n\n#### C++\n\n```cpp\n#include <iostream> \n#include <vector>  \n#include <algorithm>\n\nint main() {\n\tint N = 6;   // 입력되는 수열의 길이\n\tint arr[6] = {1, 2, 4, 3, 5, 6}    // 입력되는 수열\n\tint dp[6];\n\n\tint max_length = 0;   // arr[i]가 들어갈 위치\n\n\tfor(int i = 0; i<N; i++) {\n\t\tint index = lower_bound(arr, arr + max_length, arr[i]) - arr;    // arr[i]를 넣을 수 있는 첫 번째로 나오는 크거나 같은 값의 인덱스\n\t\tdp[index] = arr[i];\n\n\t\tif(max_length == index) {  // LIS의 최대 길이가 업데이트되면 (최장 수열의 길이를 구하기 위한 배열인 dp에 값이 1개 있었는데 2개가 된 경우)\n\t\t\tmax_length++;   // 이제 다음 위치에 값이 들어가야 하므로 증가시킨다.\n\t\t}\n \t}\n \t\n\tcout << max_length;\n}\n```\n\n#### Python\n\n```python\nimport bisect\n\nx = int(input())\narr = list(map(int, input().split()))\n\ndp = [arr[0]]\n\nfor i in range(x):\n\tif arr[i] > dp[-1]:\n\t\tdp.append(arr[i])\n\t\tcontinue\n\tindex = bisect.bisect_left(dp, arr[i])\n\tdp[index] = arr[i]\n\nprint(len(dp))\n```\n\n## LIS의 원소 구하기\n\n### 이분탐색\n\n```cpp\n#include <iostream> \n#include <vector>  \n#include <algorithm>\n\nint N = 6;   // 입력되는 수열의 길이\nint arr[6] = {1, 2, 4, 3, 5, 6}    // 입력되는 수열\nint dp[6];  // LIS의 후보가 될 값들을 저장해두는 배열\nint dp_idx[6];   // dp_idx[i]: arr[i] 가 dp의 어디에 저장이 되었는지 저장한다.\n\n// dp_index: dp의 인덱스 값\n// dp_idx_index: 초기값은 길이의 최댓값, \nvoid print(int lis_index, int index) {\n\tif(lis_index < 0 || index < 0) return;\n\tif(dp_idx[index] == lis_index) { // dp에 담긴 값의 인덱스 값이 index와 같으면 출력\n\t\tprint(lis_index - 1, index - 1);\n\t\tcout << arr[index] << \" \";\n\t}\n\telse print(lis_index - 1, index);\n}\n\nint main() {\n\n\tint max_length = 0;   // arr[i]가 들어갈 위치\n\n\tfor(int i = 0; i<N; i++) {\n\t\tint index = lower_bound(arr, arr + max_length, arr[i]) - arr;    // arr[i]를 넣을 수 있는 첫 번째로 나오는 크거나 같은 값의 인덱스\n\t\tdp[index] = arr[i];\n\t\tdp_idx[i] = index;  // arr[i] 가 저장된 dp의 인덱스를 dp_idx[i]에 저장한다. \n\n\t\tif(max_length == index) {  // LIS의 최대 길이가 업데이트되면 (최장 수열의 길이를 구하기 위한 배열인 dp에 값이 1개 있었는데 2개가 된 경우)\n\t\t\tmax_length++;   // 이제 다음 위치에 값이 들어가야 하므로 증가시킨다.\n\t\t}\n \t}\n \t\n\tcout << max_length;\n\n\t// 출력은 여러 가지 방법이 있다.\n\tprint(N-1, max_length - 1);  // (1)\n\n\t// (2) -> 메모리를 많이 쓰고 시간도 더 들지만 인지 비용이 덜 든다.\n\tvector<int> result;  \n  \n\tfor (int i = N; i >= 1; i--) {  \n\t    if (dp_idx[i] == max_length - 1) {  \n\t        result.push_back(arr[i]);  \n\t        max_length--;  \n\t    }  \n\t}  \n\t  \n\tfor (int i = result.size() - 1; i >= 0; i--) {  \n\t    cout << result[i] << ' ';  \n\t}\n\n}\n```\n\n## 참고\n\n- https://maramarathon.tistory.com/57"},{"excerpt":"LOG PR 템플릿, 스프린트 기간 같은 세부 사항들을 정했다. 곧 기능 개발을 할 수 있을 것 같아서 좋다 🥹 얼른 개발하고 싶다 요즘 끝나고 프로젝트 관련해서 할 게 없다보니 알고리즘만 푸는 중이다. 배운 것  을 사용하면 매핑하는 필드의 타입에 따라 DB의 BLOB, CLOB과 매핑된다. , ,  : CLOB ,  : BLOB 테이블의 unique …","fields":{"slug":"/2023-07-05/"},"frontmatter":{"date":"2023년 07월 05일 07:07","title":"2023년 07월 05일","tags":null},"rawMarkdownBody":"\n## LOG\n- PR 템플릿, 스프린트 기간 같은 세부 사항들을 정했다. 곧 기능 개발을 할 수 있을 것 같아서 좋다 🥹 얼른 개발하고 싶다\n- 요즘 끝나고 프로젝트 관련해서 할 게 없다보니 알고리즘만 푸는 중이다.\n\n## 배운 것\n- `@Lob` 을 사용하면 매핑하는 필드의 타입에 따라 DB의 BLOB, CLOB과 매핑된다.\n\t- `String`, `char[]`, `java.sql.CLOB` : CLOB\n\t- `byte[]`, `java.sql.BLOB` : BLOB\n\n```java\n@Column(name = \"contents\")  \n@Lob  \nprivate String contents;\n```\n\n- 테이블의 unique 조건은 다음과 같이 정의한다.\n\n```java\n@Table(name = \"user\", uniqueConstraints = @UniqueConstraint(name = \"UK_a3imlf41l37utmxiquukk8ajc\", columnNames = \"user_id\"))\n@Entity  \npublic class User\n```\n\nUnique 조건의 이름을 지정하지 않으면 vendor가 생성한 값이 들어갈 수 있다.    \nJPA 2.0 부터 Unique 조건의 이름을 제공할 수 있다.     \n\n`uniqueConstraints` 속성은 배열로 여러 가지 `@UniqueConstraint` 를 가질 수 있다.    \n`columnNames` 속성은 여러 가지를 지정할 수 있다.    \n\n- 컬럼의 기본값을 설정하는 방법은 다음과 같다.\n\n```java\n@ColumnDefault(\"-1\")\nprivate int score;\n\n// 또는\n\n@Column(columnDefinition = \"integer default -1\")\nprivate int score;\n```\n\n- 준영속 상태는 다음과 같이 만들 수 있다. \n\n```java\nPerson person = new Person(\"vero\");\nPerson savedPerson = personRepository.save(person);\nentityManager.detach(savedPerson);\n```\n\n특정 엔티티만 준영속 상태로 전환한다. (준영속 상태가 되면 1차 캐시에서 빠진다)    \n준영속 엔티티는 영속성 컨텍스트가 더 이상 관리하지 않는 엔티티로, 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다.    \n\n**참고** : https://www.nowwatersblog.com/jpa/ch3/3-6\n\n- `@Id` 컬럼의 이름이 id가 아니더라도 JPA가 기본적으로 제공하는 `findById` 는 사용할 수 있다.\n- JPA의 `@Temporal` 어노테이션은 `LocalDateTime` 필드에 사용할 수 없다.\n- [[lis]] 푸는 법을 드디어.. 알아냈다.\n\n## 궁금한 것\n- jpa도 프록시를 쓰나? 엔티티가 빈 생성자를 제공해야 하는 것도 그렇고, 빈 생성자가 `private` 이면 컴파일 에러가 뜨는 것도 의심스러움\n\t- 하이버네이트가 프록시 객체를 통해 지연 로딩을 구현한다.\n\t- 따라서 JPA 엔티티는 final로 정의할 수 없고, 기본 생성자는 최소 `protected` 접근 제어자를 가져야 한다. \n\t- **참고** : https://tecoble.techcourse.co.kr/post/2022-10-17-jpa-hibernate-proxy/\n- JDK 17 의 sealed class 도 JPA 엔티티로 쓸 수 없을까?\n\n## 느낀 것\n- 알고리즘 어렵다. 근데 이제는 열심히 하면 잘할 수 있을 것 같다.\n- 스타벅스 추워."},{"excerpt":"Git Branch 전략 Git Flow 에서 release를 삭제한 전략을 사용하기로 했다.  main 배포 브랜치 develop 개발 총괄 브랜치 main 에서 파생되며, 하나의 완성된 기능 개발 후 main에 반영한다. feat/issue-number issue 단위의 기능 개발 브랜치 develop 에서 파생되며, 단위 기능 개발 후 develop…","fields":{"slug":"/shook-git-branch-strategy/"},"frontmatter":{"date":"2023년 07월 05일 02:07","title":"S-HOOK Git Branch 전략","tags":["shook"]},"rawMarkdownBody":"\n## Git Branch 전략\n\nGit Flow 에서 release를 삭제한 전략을 사용하기로 했다.\n\n![[shook-git-branch-strategy.png]]\n\n- main\n\t- 배포 브랜치\n- develop\n\t- 개발 총괄 브랜치\n\t- main 에서 파생되며, 하나의 완성된 기능 개발 후 main에 반영한다.\n- feat/issue-number\n\t- issue 단위의 기능 개발 브랜치\n\t- develop 에서 파생되며, 단위 기능 개발 후 develop에 반영한다.\n- fix/issue-number\n\t- issue 단위의 버그 수정 브랜치\n\t- develop 에서 파생되며, 버그 수정 후 develop에 반영한다.\n- hotfix\n\t- main에 반영된 내용 중에 급하게 수정되어야 할 버그 수정 브랜치\n\t- main 에서 파생되며, 버그 수정 후 main에 반영한다.\n\n### 현재 release를 사용하지 않는 이유\n\n현재 개발 서버가 존재하지 않는 상황에서 유의미한 QA가 불가능하다고 생각했습니다.    \n이후 개발 서버가 필요해지고, 세팅이 완료된 후에 release 브랜치를 고려해볼 예정입니다."},{"excerpt":"Spotify Spotify Web API 링크","fields":{"slug":"/shook-music-api/"},"frontmatter":{"date":"2023년 07월 04일 04:07","title":"S-HOOK 음악 API 자료 조사","tags":["shook"]},"rawMarkdownBody":"\n## Spotify\n\n[Spotify Web API 링크](https://developer.spotify.com/documentation/web-api)\n\n"},{"excerpt":"기획 shook-planning shook-planning-interview shook-persona shook-service-introduce shook-second-demoday 자료 조사 음악 API: shook-music-api 기술 Github github-merge-strategy github-codeowners github-self-hoste…","fields":{"slug":"/shook/"},"frontmatter":{"date":"2023년 07월 04일 04:07","title":"S-HOOK","tags":["shook","우테코","레벨3","레벨4"]},"rawMarkdownBody":"\n## 기획\n\n- [[shook-planning]]\n- [[shook-planning-interview]]\n- [[shook-persona]]\n- [[shook-service-introduce]]\n- [[shook-second-demoday]]\n\n### 자료 조사\n\n- 음악 API: [[shook-music-api]]\n\n## 기술\n\n### Github\n\n- [[github-merge-strategy]]\n- [[github-codeowners]]\n- [[github-self-hosted-runner]]\n- [[shook-git-branch-strategy]]\n\n### Spring\n\n- [[spring-profile-trouble-shooting]]\n- [[spring-xml-parsing]]\n- [[spring-external-api-call-method]]\n- [[shook-webclient-reason]]\n\n### 기타\n\n- [[shook-tech-stack]]\n- [[shook-maniadb]]\n\n## 발표\n\n- [[shook-five-minute-speech]]\n"},{"excerpt":"Dirty Checking 이란 Entity Manager가 변경이 발생한 엔티티를 자동 감지하여 DB에 반영하는 것이다. 이미 영속화된 엔티티들을 대상으로만 작동하여, 준영속상태이거나 비영속상태인 엔티티들은 Dirty Checking을 진행하지 않는다. 동작 방법 JPA가 엔티티를 조회할 때 해당 엔티티의 상태를 기반으로 하나의 스냅샷을 만든다. 그 후…","fields":{"slug":"/jpa-dirty-checking/"},"frontmatter":{"date":"2023년 07월 04일 02:07","title":"JPA Dirty Checking - 변경 감지","tags":["jpa"]},"rawMarkdownBody":"\n## Dirty Checking 이란\n\nEntity Manager가 변경이 발생한 엔티티를 자동 감지하여 DB에 반영하는 것이다.\n\n이미 영속화된 엔티티들을 대상으로만 작동하여, 준영속상태이거나 비영속상태인 엔티티들은 Dirty Checking을 진행하지 않는다.\n\n## 동작 방법\n\nJPA가 엔티티를 조회할 때 해당 엔티티의 상태를 기반으로 하나의 스냅샷을 만든다.    \n그 후, 트랜잭션이 종료되는 시점에 만든 스냅샷과 비교하여 변경을 감지한다.   \n변경이 감지되면 update 쿼리를 DB에 전달한다.\n\n즉, 영속화된 엔티티라면 별도로 save 메서드를 사용하지 않아도 JPA 에 의해 변경 사항이 자동으로 데이터베이스에 적용된다.\n\n### 변경된 부분만 업데이트하기\n\nDirty Checking이 이루어지는 update 쿼리는 기본적으로 모든 필드를 업데이트한다.\n\n생성되는 쿼리가 같아 부트 실행 시점에 미리 만들어 재사용 가능하고, DB 입장에서 쿼리 재사용이 가능하다.    \n그러나 필드가 많은 엔티티의 경우 모든 필드 업데이트는 부담스러울 수 있다. 데이터의 양이 많아질수록 그렇다.\n\n이런 경우에는 `@DynamicUpdate` 엔티티 최상단에 선언해주면 변경된 필드만 반영되도록 할 수 있다. \n\n```java\n@Entity\n@DynamicUpdate\npublic class Vero {\n\t...\n}\n```\n\n## 참고\n- https://jojoldu.tistory.com/415"},{"excerpt":"jpa-dirty-checking jpa-dto-projection","fields":{"slug":"/jpa/"},"frontmatter":{"date":"2023년 07월 04일 02:07","title":"JPA","tags":["jpa","spring"]},"rawMarkdownBody":"- [[jpa-dirty-checking]]\n- [[jpa-dto-projection]]\n"},{"excerpt":"LOG 베로위키 다시 영업합니다 구경 자주 오세요~ 어제, 그저께, 토요일까지 술을 너무 많이 마셨다 ㅋㅋ.. 술 자제해야 되는데 금요일에도 데모데이 회식이라 술 마시러 간다. 아무래도 자제하자... 백엔드 코드 스타일 컨벤션 회의를 했다. 오랜만에 코드를 보니까 좀 기뻤다 ㅋㅋㅋ 배운 것 JPA ddl-auto는 create-drop이 default 값…","fields":{"slug":"/2023-07-04/"},"frontmatter":{"date":"2023년 07월 04일 01:07","title":"2023년 07월 04일","tags":null},"rawMarkdownBody":"## LOG\n- 베로위키 다시 영업합니다 구경 자주 오세요~\n- 어제, 그저께, 토요일까지 술을 너무 많이 마셨다 ㅋㅋ.. 술 자제해야 되는데 금요일에도 데모데이 회식이라 술 마시러 간다. 아무래도 자제하자...\n- 백엔드 코드 스타일 컨벤션 회의를 했다. 오랜만에 코드를 보니까 좀 기뻤다 ㅋㅋㅋ\n\n## 배운 것\n- JPA ddl-auto는 create-drop이 default 값이다.\n- JPA Entity는 인자가 없는 생성자가 필요하다.\n- `logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE` 를 설정하면 ?에 뭐가 들어갔는지 알 수 있다. `2023-07-04 11:20:56.885 TRACE 58373 --- [    Test worker] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [잠실역]`\n- `@DataJpaTest` 에는 `@Transactional` 이 붙어 있어서 rollback이 된다.\n```shell\n2023-07-04 11:24:10.786  INFO 58396 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test context [DefaultTestContext@1dd81a80 testClass = StationRepositoryTest, testInstance = subway.StationRepositoryTest@1de344a0, ...\n\nhibernate log\n\n2023-07-04 11:24:10.938  INFO 58396 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Rolled back transaction\n```\n\n- 영속성 컨텍스트: 엔티티를 영구 저장하는 환경. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 저장한다.\n\n- 영속성 컨텍스트는 동등성을 보장해준다.\n```java\n@Test  \nvoid identity() {  \n    Station station1 = stations.save(new Station(\"잠실역\"));  \n    Station station2 = stations.findById(station1.getId()).get();  \n    assertThat(station1 == station2).isTrue();  \n}\n```\n\n- 영속성 컨텍스트는 `ConcurrentHashMap` 으로 구현되어 있다.\n- 영속성 컨텍스트는 id 조회 시에 DB를 바로 조회하지 않고, 먼저 1차 캐시를 확인한 후 있으면 그대로 리턴해준다. 1차 캐시에 없는 값은 DB에서 select 후, 1차 캐시에 저장한다.\n- 엔티티의 생명 주기\n\t- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태\n\t- 영속 : 영속성 컨텍스트에 저장된 상태\n\t- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태\n\t- 삭제 : 삭제된 상태\n- `@Transactional` 에서 트랜잭션을 커밋하는 순간, 영속성 컨텍스트를 DB에 반영한다.\n- 이 경우, update query가 날아간다. 조회하기 전에 변경 사항이 있으면 update 한다. \n\n```java\n@Test  \nvoid update() {  \n\tStation station1 = stations.save(new Station(\"잠실역\"));  \n\tstation1.changeName(\"선릉역\");  \n\tStation station2 = stations.findByName(\"선릉역\");  \n\tassertThat(station2).isNotNull();\n}\n```\n\n```shell\nupdate\n\tstation \nset\n\tname=? \nwhere\n\tid=?\n```\n\n- 이 경우는 update query가 날아가지 않는다.\n\n```java\n@Test  \nvoid update() {  \n\tStation station1 = stations.save(new Station(\"잠실역\"));  \n\tstation1.changeName(\"선릉역\");  \n//        Station station2 = stations.findByName(\"선릉역\");  \n//        assertThat(station2).isNotNull();  \n}\n```\n\n- flush 는 영속성 컨텍스트가 관리하는 객체의 변화를 DB에 반영하겠다는 것. commit은 트랜잭션의 관점. \n- 해보니까 이슈, discussion 삭제 됩니다 ㅋㅋ by 주노\n\t- 원래는 권한이 없어서 안 됐던 거 같기도 하고 아니면 내가 연 이슈가 아니어서 그런 거 같기도 하고 검증 필요\n\n## 궁금한 것\n- 내 안경은 왜 계속 휘어질까\n\n## 느낀 것\n- 비가 너무 많이 와서 찝찝했다. 내일까지는 비가 올텐데 진짜 싫다;; 언제까지 여름이야...\n- 회의가 많으니까 시간은 잘 가는데 에너지 소모가 심하다.\n- 바론이 빅파이를 사와서 맛있게 먹었다. 간식 가져와 준 바론 고마워 😄"},{"excerpt":"2023-07-04 2023-07-05 2023-07-06 2023-07-08 2023-07-09 2023-07-10 2023-07-11 2023-07-13 2023-07-14 2023-07-17 2023-07-18 2023-07-19 2023-07-20 2023-07-22 2023-07-24 2023-07-25 2023-07-26 2023-07-27","fields":{"slug":"/2023-07/"},"frontmatter":{"date":"2023년 07월 04일 01:07","title":"2023년 07월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-07-04]]\n- [[2023-07-05]]\n- [[2023-07-06]]\n- [[2023-07-08]]\n- [[2023-07-09]]\n- [[2023-07-10]]\n- [[2023-07-11]]\n- [[2023-07-13]]\n- [[2023-07-14]]\n- [[2023-07-17]]\n- [[2023-07-18]]\n- [[2023-07-19]]\n- [[2023-07-20]]\n- [[2023-07-22]]\n- [[2023-07-24]]\n- [[2023-07-25]]\n- [[2023-07-26]]\n- [[2023-07-27]]\n"},{"excerpt":"LOG 배운 것 github discussion, issue는 삭제가 불가능하다...","fields":{"slug":"/2023-06-30/"},"frontmatter":{"date":"2023년 06월 30일 07:06","title":"2023년 06월 30일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n- github discussion, issue는 삭제가 불가능하다..."},{"excerpt":"LOG 27일 TIL을 안 써서.. ㅋㅋ 여기다가 같이 적어야겠다. 우리 팀 이름은 슉(shook)이 되었다. share-hook이라는 이름으로, 강렬한 킬링 파트를 다른 사람들과 함께 공유한다는 의미이다. 그런데 스플릿이 팀 이름 정할 때 뿌직 이라는 의견을 냈는데 모두 그 이름을 웃겨해서 ㅋㅋㅋ 비공식적 팀 이름은 뿌직이 되었다... 그렇지만 공식적인…","fields":{"slug":"/2023-06-28/"},"frontmatter":{"date":"2023년 06월 28일 12:06","title":"2023년 06월 28일","tags":null},"rawMarkdownBody":"## LOG\n27일 TIL을 안 써서.. ㅋㅋ 여기다가 같이 적어야겠다.\n- 우리 팀 이름은 슉(shook)이 되었다. share-hook이라는 이름으로, 강렬한 킬링 파트를 다른 사람들과 함께 공유한다는 의미이다. 그런데 스플릿이 팀 이름 정할 때 뿌직 이라는 의견을 냈는데 모두 그 이름을 웃겨해서 ㅋㅋㅋ 비공식적 팀 이름은 뿌직이 되었다... 그렇지만 공식적인 서비스 이름은 슉 입니다 ^_^\n- 어제 밥을 먹으면서 팀원 모두와 말을 놓았다. 도밥은 처음에 말을 놓기 힘들어했지만 금방 적응했다 ㅋㅋ 말을 놓고 나니 좀 더 대화하기 편해진 것 같아 좋았다. 2달간 거의 모든 시간을 팀원들과 함께 하게 될 것 같은데, 다들 좋은 사람들이라 좋은 팀 활동을 할 수 있을 것 같다.\n- 리사, 토미와도 커피챗을 했다. 어제 밥 먹고 나서 커피챗을 했는데, 우리 팀이 모두 초면인데도 불구하고 (나는 스플릿과 도밥은 알고 있었지만 다른 분들은 모두 초면이었다) 원래 알고 지내던 사람들 같다는 말을 들어서 기분이 좋았다.\n- 오늘은 페르소나에 대한 강의를 들어서, 인터뷰 질문들을 정하는 시간을 가졌다. 인터뷰에 응해준 하마드, 주노, 그레이 고마워~ 큰 도움이 되었습니다 😄\n- 오늘은 팀 문화를 정하는 시간도 가졌다. 도밥이 예비군을 가고, 코난, 스플릿도 근로가 있어서 큰 뼈대는 아코, 우코, 바론과 함께 정하게 되었다. 어제 오늘 회의하면서 느끼는 거지만 다들 둥글둥글하고 배려하는 말하기를 잘해서 의견 수렴이 더 잘 되는 듯한 기분이 든다.\n- FUGA 커피 드디어 마셔봤다. 맛있긴 한데, 어떤 부분에서 맛있냐고 물어보면 모르겠다 ㅋㅋㅋ\n- 나 사용설명서를 공유하는 시간을 가졌다. 예비군 간 도밥도 허들로 참여해서 모두 잘 참여할 수 있어 감사하다. 의외로 나와 비슷한 성격을 가진 팀원들이 많아서 신기했다. \n\n## 배운 것\n- 스프링 부트 3.0을 사용하려면 Java 17부터 쓸 수 있다.\n\n## 궁금한 것\n\n## 느낀 것\n- '~라고 생각하면 어떡하지?' 라고 지레짐작하지 말고, 내 의도를 충분히 설명한 다음에 말하는 게 오해가 덜하다.\n- 나 꽤나 눈을 못 마주치는 사람이었을지도... 특히 여자 크루들과 대화하면서 눈을 마주치는 게 쉽지 않다. 천천히 연습해보자(?)\n- 자세의 중요성. 바른 자세를 유지하기 위해 노력하자.\n- 데블스캠프 자료 얼른 준비해야겠다. 이번 주 토요일인데 이제 30% 만들었음..ㅋ\n"},{"excerpt":"인터뷰 주제 주노 하루에 노래를 얼마나 들으세요 ? 3시간 이상 노래를 언제 들으시나요 ? 출퇴근 시간, 개인 공부할 때 유투브로도 음악을 들으시나요 ? 유튜브 뮤직, 유튜브로만 듣는다. 유투브에 있는 플레이리스트들을 이용해 보셨나요? 예. 뭐 듣죠? 시끄러운 플레이리스트 아니면 4세대 여자 아이돌 플레이리스트 본인만의 플레이리스트가 있나요? 없다. 노래…","fields":{"slug":"/shook-planning-interview/"},"frontmatter":{"date":"2023년 06월 28일 09:06","title":"슉 인터뷰","tags":["shook","레벨3"]},"rawMarkdownBody":"\n## 인터뷰 주제\n\n### 주노\n  \n- 하루에 노래를 얼마나 들으세요 ?\n\t- 3시간 이상\n- 노래를 언제 들으시나요 ?  \n\t- 출퇴근 시간, 개인 공부할 때\n- 유투브로도 음악을 들으시나요 ?  \n\t- 유튜브 뮤직, 유튜브로만 듣는다.\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 예. \n\t- 뭐 듣죠? 시끄러운 플레이리스트 아니면 4세대 여자 아이돌 플레이리스트\n- 본인만의 플레이리스트가 있나요?  \n\t- 없다. 노래 취향이 명확하지 않다. 노래에 관심이 없다....\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 다양한 노래를 듣는다.\n\t- 유튜브 추천 알고리즘에 뜨는 거 그냥 듣는다...\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- FT 아일랜드\n\t- 옛날 한국 노래\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 멜로디, 비트\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 지루한 노래. 잔잔한 노래\n\t- 클래식은 취향이 아니다.\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 안 좋아한다. 명확하게 듣는게 없어서 탑 100 좋아한다.\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 듣는다. 취향에 민감하지 않아서\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 네. 1절까지만 듣는다. 한 절반정도\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- 예 뭐.. 언제든지.\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 유튜브 뮤직 알고리즘\n\t- 우플리 채널 -> 아 뭐.. 의향 있습니다.\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 도입부부터 1절까지. \n\n### 그레이\n\n- 하루에 노래를 얼마나 들으세요 ?  \n\t- 하루 두 시간 이상\n- 노래를 언제 들으시나요 ?  \n\t- 출퇴근할 때, 걸을 때, 공부할 때, 대화할 때 빼고\n- 유투브로도 음악을 들으시나요 ?  \n\t- 아 네. 매우 좋아한다.\n\t- 유튜브 프리미엄 사용한다. 나머지는 이제 안 쓴다.\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 물론이다.\n\t- 유튜브에서 알고리즘 추천해주는 거 듣는다.\n- 본인만의 플레이리스트가 있나요?  \n\t- 요즘은 있다.\n\t- 가수에 빠지면 가수 플리를 듣는다.\n\t- 장르는 보통 발라드, 인디 뮤직 듣는다.\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 다양한 노래를 듣는 편.\n\t- 플레이리스트 만들어 둔 거는 일정 기간 지나면 질려서 안 듣는다.\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- 발라드, 인디 뮤직\n\t- 하현상, MC the MAX, 볼빨간 사춘기\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 멜로디\n\t- 직관적으로 들었을 때 끌리는 거\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 단조로운 음율 안 좋아한다.\n\t- 시끄러운 거 안 좋아한다.\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 막 좋아하지 않는다.\n\t- 큰 이유는 없는데, 굳이 싶어서\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 무조건 100%\n\t- 사람들이 좋아 하는 노래는 이유가 있다. 한 번 들었을 때 좋은 노래보다 여러 번 들었을 때 좋은 게 많다.\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 웬만하면 듣는다. 한 곡 다 듣는다.\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- 이미 겪은 장르면 안 듣는다.\n\t- 최근에 클래식 추천 받았는데 괜찮더라.\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 지인 추천이 많다.\n\t- 유튜브 알고리즘이 추천해준다. 별로면 넘기고\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 무조건 처음부터 끝까지\n- 처음부터 끝까지 들어서 별로였던 노래가 있는데 다시 처음부터 들었을 때 괜찮았던 경우?\n\t- 있다. 한 5번은 들어야 괜찮더라.\n\n### 하마드\n\n- 하루에 노래를 얼마나 들으세요 ?  \n\t- 하루에 10곡 내외\n\t- 한 30-40분\n- 노래를 언제 들으시나요 ?  \n\t- 아침에 일어나서 머리감을 때\n\t- 출퇴근\n\t- 가끔 혼자 코딩할 때 \n- 유투브로도 음악을 들으시나요 ?  \n\t- 유튜브로만 듣는다.\n\t- 사운드클라우드도 가끔\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 웬만하면 안 한다.\n\t- 내 기호에 맞추는 걸 좋아한다.\n- 본인만의 플레이리스트가 있나요?  \n\t- 멜론 시절에는 있었는데 \n\t- 유튜브 알고리즘이 비슷한 거 찾아줘서 안 만든다.\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 웬만하면 익숙한 것\n\t- 우연한 경우에는 그거 들어보는 경우\n\t- 웬만하면 추가 잘 안 됨\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- 장르 안 가림\n\t- 힙합, 외국 R&B, 걸그룹, 외국 락 밴드\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 제일 중요한 거 멜로디\n\t- 팝송은 그래서 안 듣는다.\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 가사가 개구리면 정 떨어진다.\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 굉장히 좋아한다.\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 브아걸 아브라카다브라\n\t- 개쓰레기라고 생각했는데 전국적으로 유행해서 다시 들어보니까 괜찮았다.\n\t- 아무리 많이 들어도 설득이 안 되면 안 좋다.\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 일단 처음부터 30초 들어본다.\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- 거부감은 없지만, 좋아하는 노래가 되는 데는 장벽이 좀 높다.\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 웬만하면 유튜브 알고리즘 맨 앞에 있는 거\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 무조건 처음부터 30초\n\n### 박스터\n\n- 하루에 노래를 얼마나 들으세요 ?  \n\t- 6시간\n- 노래를 언제 들으시나요 ?  \n\t- 이동할 때, 코딩할 때\n- 유투브로도 음악을 들으시나요 ?  \n\t- 스포티파이\n\t- 컴퓨터는 유튜브\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 내가 만든 거 쓴다.\n- 본인만의 플레이리스트가 있나요?  \n\t- 1개\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 다양한 노래\n\t- 장르를 여러 개 들어서 다양한 노래\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- 장르: 락, 힙합, 클래식\n\t- 가수: 라디오헤드, 다이나믹 듀오, 라흐마니노프\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 한국 노래면 가사\n\t- 외국 노래는 멜로디, 목소리\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 발라드는 쓰레기\n\t- 여자 보컬 별로 안 좋아함 (아이유 제외 - 목소리 좋아서)\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 아주 좋아한다.\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 의향 있다.\n\t- 뉴진스 듣다보니 좋아짐.\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 웬만하면 듣는다.\n\t- 우플리 몇 명이 올리는 거 빼고 들음.\n\t- 그래도 발라드는 거름\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- why not\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 우플리\n\t- 지인 추천\n\t- 스포티파이 신곡 추천 올라오면 들음\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 처음부터 싫을 때까지"},{"excerpt":"개발 컨벤션 좋아보이는 거 모음 Issue 템플릿 버그 이슈 템플릿 피쳐 이슈 템플릿 PR 템플릿 RCA 룰 by 주노 각각의 코멘트의 접두에 R, C, A를 붙이면서 리뷰를 진행하는 방식이다.  : 적극적으로 반영을 고려해주세요  : 웬만하면 반영해주세요  : 반영해도 좋고, 넘어가도 좋습니다. 사소한 의견입니다. reviewer가 1명 이상 appro…","fields":{"slug":"/shook-planning/"},"frontmatter":{"date":"2023년 06월 27일 11:06","title":"슉 기획","tags":["shook","우테코","레벨3"]},"rawMarkdownBody":"\n## 개발 컨벤션 좋아보이는 거 모음\n\n### Issue 템플릿\n\n- 버그 이슈 템플릿\n\n```markdown\n## 🤷 버그 내용\n\n## ⚠ 버그 재현 방법\n1.\n2.\n3.\n\n## 📸 스크린샷\n\n## 👄 참고 사항\n\nby dallog\n```\n\n```markdown\n## 버그 기능\n- 페이지나 기능을 적습니다.\n\n### 버그 상황 재연\n- 어떤 상황에서 버그가 발생하는지 적습니다.\n\n### 기대 동작\n- 원래 기대하던 정상 동작에 대해 작성합니다.\n\n### 현재 동작\n- 기대하던 동작에 반해 지금 문제가 되는 동작을 작성합니다.\n\nby zzimkkong\n```\n\n```markdown\n### QA 환경 : \n\n### 현상: \n\n### 재현 과정 : \n\n### 예상되는 원인: \n\n### 스크린샷:\n\nby jujeol-jujeol\n```\n\n- 피쳐 이슈 템플릿\n\n```markdown\n## 🤷 구현할 기능\n\n## 🔨 상세 작업 내용\n\n- [ ] To-do 1\n- [ ] To-do 2\n- [ ] To-do 3\n\n## 📄 참고 사항\n\n## ⏰ 예상 소요 기간\n\nby dallog\n```\n\n```markdown\n[FE | BE] 명사형으로 작성\n### 설명\n\n### 진행상황\n- [ ] 진행사항1\n- [ ] 진행사항2\n\n### 주의사항\n\nby jujeol-jujeol\n```\n\n### PR 템플릿\n\n```markdown\n## 작업 내용\n\n## 스크린샷\n\n## 주의사항\n\nCloses #{이슈 번호}\n\nby dallog\n```\n\n```markdown\n## 구현 기능\n- 구현한 기능을 적습니다.\n\n## 논의하고 싶은 내용\n- 논의할 내용을 적습니다.\n\n## 공유하고 싶은 내용\n- 학습한 내용, 공유할 내용 등을 적습니다.\n- 위키에 작성했다면 링크 첨부, 없는 경우 삭제\n\n## 기타\n- 기타 추가할 내용이 있다면 추가합니다.\n- 없는 경우 삭제\n\nClose #이슈번호\n\nby zzimkkong\n```\n\n```markdown\n## resolve #issue number\n\n### 설명\n- 프론트의 경우 화면 작업일 때 캡쳐본 포함하기\n\n### 기타\n\nby jujeol-jujeol\n```\n\n```markdown\n[ALL/FE/BE] 작업 진행 내용 간단명료하게\n\n## 📌 관련 이슈\n<!-- 이슈 번호를 적어주세요\nclosed #issue_number를 적어주세요-->\n\n## ✨ 작업 내용\n<!-- 어떤 작업을 했는지 설명해주세요 -->\n\n## 📷 스크린샷 (선택)\n<!-- 스크린샷 필요하면 첨부해주세요 --> \n\n## 🔍 참고 사항\n<!-- PR을 리뷰할 때 참고할 사항이 있으면 적어주세요 -->\n```\n\n- RCA 룰 by 주노\n\t- 각각의 코멘트의 접두에 R, C, A를 붙이면서 리뷰를 진행하는 방식이다.\n\t- `R (Request Changes)` : 적극적으로 반영을 고려해주세요\n\t- `C (Comment)` : 웬만하면 반영해주세요\n\t- `A (Approve)` : 반영해도 좋고, 넘어가도 좋습니다. 사소한 의견입니다.\n\n- reviewer가 1명 이상 approve 하지 않았을 경우에는 merge block 하기\n\n### 코드 컨벤션\n\n- zzimkkong BE 코드 컨벤션 : https://xrabcde.notion.site/5cd0851364254f1db103607efa414a8d\n\n## Git Branch 전략\n\n- main\n\t- 실제 프로젝트 사용자들이 볼 배포 브랜치\n- develop\n\t- 개발 총괄 브랜치\n\t- main 에서 파생, 기능 개발 후 main에 반영\n\t- feat/issue-number\n\t\t- issue 단위의 기능 개발 브랜치\n\t\t- develop 에서 파생, 기능 개발 후 develop에 반영\n\t- fix/issue-number\n\t\t- issue 단위의 버그 수정 브랜치\n\t\t- develop 에서 파생, 버그 수정 후 develop에 반영\n- hotfix\n\t- main 에서 파생, 버그 수정 후 main에 반영\n\n## Commit 컨벤션\n\n- feat: 기능 개발\n- docs: 문서 관련 작업\n- refactor: 기능 변경 없이 전반적 코드 구조 변경 (Ex. 필드 이름 변경 등)\n- chore: 파일 내부가 아닌 파일 자체에 대한 변경 (Ex. 폴더 이동 / 변경, 파일 이름 변경, 파일 삭제)\n- style: 코드 컨벤션 관련 작업\n- test: 테스트 코드 관련 작업\n- fix: 버그 수정\n- design: 마크업 관련 수정\n- config: 외부 라이브러리 관련 추가 및 설정"},{"excerpt":"로컬 환경에서 로컬 프로필이 적용되지 않는 문제 로컬에서는 로컬 프로필이 적용되어야 하는데 submodule 로 지정해준 prod 프로필이 적용되는 문제가 발생했다.  PR 링크 기존에는 prod 파일에도 이런 설정이 있었다.  파일은 다음과 같았다. 이대로 실행하면, 실행되는 프로필은 prod 였다. 문제의 원인은  가 여러 개 존재하기 때문이다. ap…","fields":{"slug":"/spring-multi-profile-issue/"},"frontmatter":{"date":"2023년 06월 26일 12:06","title":"Spring의 Profile은 어떤 순서로 읽힐까?","tags":["spring","개발","matzip","trouble-shooting"]},"rawMarkdownBody":"\n## 로컬 환경에서 로컬 프로필이 적용되지 않는 문제\n\n로컬에서는 로컬 프로필이 적용되어야 하는데 submodule 로 지정해준 prod 프로필이 적용되는 문제가 발생했다.  [PR 링크](https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/158)\n\n기존에는 prod 파일에도 이런 설정이 있었다.\n\n```yaml\n# prod/application.yml\nspring:  \n  profiles:  \n    active:  \n      - prod  \n    group:  \n      prod:  \n        - web-prod  \n        - db-prod\n---\n...\n```\n\n`application.yml` 파일은 다음과 같았다.\n\n```yaml\nspring:  \n  profiles:  \n    active:  \n      - local  \n    group:  \n      local:  \n        - web-local  \n        - db-local  \n      prod:  \n        - web-prod  \n        - db-prod  \n  config:  \n    import: classpath:prod/application.yml\n---\n...\n```\n\n이대로 실행하면, 실행되는 프로필은 prod 였다.\n\n```bash\n2023-06-22 18:20:00.952  INFO 12487 --- [           main] c.woowacourse.MatzipExternalApplication  : The following 3 profiles are active: \"prod\", \"web-prod\", \"db-prod\"\n```\n\n문제의 원인은 **`active` 가 여러 개 존재하기 때문이다.**     \napplication-prod에도 `active` 설정을 해주었기 때문에 `active` 설정이 덮어 씌워진 것이다.\n\n따라서 문제 해결을 위해서는 prod의 `application.yml` 을 다음처럼 바꾸면 된다.\n\n```yaml\nspring:  \n  profiles:  \n    group:  \n      prod:  \n        - web-prod  \n        - db-prod\n---\n```\n\n### prod의 application.yml이 local의 application.yml 보다 늦게 읽히는 걸까?\n\n여기까지 문제는 해결됐는데, 왜 prod가 local보다 늦게 실행되는지 궁금했다.     \n스프링이 local을 먼저 읽고, prod를 읽기 때문에 덮어 씌워지는 건가? 해서 테스트를 해보았다.     \n\nprod가 나중에 읽혀진다면, 스프링이 실행되고 나서 정해진 설정은 prod의 필드 값이어야 한다.     \n그러나 확인해보니 local 의 필드 값이 저장되어 있었다.    \n대체 어떻게 된 일일까?\n\n결론적으로는 `spring.config.import` 를 할 때 파일을 가져오는 방식 때문에 그렇다.     \n`spring.config.import` 를 하게 되면 해당 경로에 있는 yml 파일을 아래에 추가한다.     \n주의해야 하는 것은 맨 위의 디폴트 설정값 이후에 바로 추가된다는 것이다.     \n즉, 다음과 같다.\n\n```yaml\nspring:  \n  profiles:  \n    active:  \n      - local  \n    group:  \n      local:  \n        - web-local  \n        - db-local  \n      prod:  \n        - web-prod  \n        - db-prod  \n  config:  \n    import: classpath:prod/application.yml\n---\nspring:  \n  profiles:  \n    active:  \n      - prod  \n    group:  \n      prod:  \n        - web-prod  \n        - db-prod\n---\n...\n```\n\n이런 식으로 값이 추가 되기 때문에, 처음의 문제 상황에서는 `active` 만 덮어씌워지고, 나머지 설정들은 local 값이 된 것이다.     \nyaml 파일은 위에서부터 아래로 읽기 때문에, 똑같은 설정 값을 갖는 필드는 그냥 값이 덮어 씌워지게 된다.    \n\n### 결론\n\n`spring.config.import` 는 파일 맨 끝에 내용을 추가하는 게 아니라는 것을 알게 되었다.\n\n### 참고\n- https://bbbicb.tistory.com/53\n- https://jaime-note.tistory.com/371"},{"excerpt":"LOG 동생이 입대했다. 전날에 같이 술 마신 것 때문에 조금 속이 안 좋았다..ㅋㅋ 점심은 동생이 먹고 싶어했던 육회 비빔밥을 먹으러 익산에 갔다. 비빔밥 집인데 사람이 굉장히 많길래 뭘까 했는데 백종원의 3대천왕에 나왔던 곳이었다. 꽤나 맛있었다. 훈련소에 들어가기 전에는 엄청 심란해했다. 하필 비가 많이 와서 불쾌한 기분으로 ㅋㅋㅋ 논산에 갔다. 입…","fields":{"slug":"/2023-06-26/"},"frontmatter":{"date":"2023년 06월 26일 07:06","title":"2023년 06월 26일","tags":null},"rawMarkdownBody":"\n## LOG\n- 동생이 입대했다. 전날에 같이 술 마신 것 때문에 조금 속이 안 좋았다..ㅋㅋ 점심은 동생이 먹고 싶어했던 육회 비빔밥을 먹으러 익산에 갔다. 비빔밥 집인데 사람이 굉장히 많길래 뭘까 했는데 백종원의 3대천왕에 나왔던 곳이었다. 꽤나 맛있었다. 훈련소에 들어가기 전에는 엄청 심란해했다. 하필 비가 많이 와서 불쾌한 기분으로 ㅋㅋㅋ 논산에 갔다. 입소식은 20분 만에 끝나서 논산역에 40분이나 빠르게 도착했다.\n- 집에 가면 과일을 많이 먹는다. 블루베리, 복숭아, 자두, 살구, 수박... 뭔가 많이 먹고 왔다.\n- Matzip 피쳐 개발을 완료했다. 이번 방학은 내내 맛집만 한 것 같다.\n- 방학 때 원래는 운영체제 공부를 하려고 했는데, 운영체제 공부보다는 알고리즘을 더 많이 했다. 많이 안 한 것 같으면서도, 많이 한 것 같기도 하다.\n\n## 배운 것\n- `git push --force-with-lease` : force push의 대상이 되는 브랜치에 지금까지 변화가 있었는지 확인하고, 변화가 있다면 강제 푸시를 못하도록 거부한다. 즉, 다른 사람이 해당 브랜치를 변경했다면 강제 푸시를 할 수 없고, 다른 사람이 브랜치를 변경하지 않은 경우에만 강제 푸시가 가능하게 한다.\n\t- 참고 : https://velog.io/@rawoon/-force-%EB%8A%94-%EC%9C%84%ED%97%98%ED%95%98%EB%8B%88-git%EC%9D%98-force-with-lease-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90\n- github PR 내용에 `close #{이슈번호}`  라고 치면 PR 닫힐 때 이슈도 같이 닫힌다. by 체인저\n\n## 궁금한 것\n\n## 느낀 것\n- 동생까지 군대에 갔으니 엄마가 외로워하실 것 같다. 사실 다른 건 크게 걱정되지 않았는데 그게 걱정됐다. 집에 붙어 있는 사람이 없어졌으니 고양이와 더 열심히 지내시지 않을까...\n- 내가 보기엔 걱정되는 일을 별 것 아닌 것처럼 말하는 것보다, 솔직하게 걱정하는 게 더 보기 좋다.\n- 어제 동생과 같이 이야기하기를 잘했다. 평소에 생각하고 있던 말을 솔직하게 하는 것도 기분이 좋았고, 최근에는 알지 못했던 근황과 이전의 사건에서 느꼈던 점을 물어볼 수 있어서 좋았다. 앞으로도 하고 싶은 걸 생각만 하지 말고 실천하는 연습을 해야겠다.\n- 아무리 생각해도 감정에 솔직한 건 좋다. 좋은 건 좋다고, 싫은 건 싫다고, 걱정되는 건 걱정된다고. 그렇지만 아직 싫은 걸 싫다고 말하는 건 조금 어렵다.\n- 내일은 잠실에 간다. 망고를 제외한 온보딩 조원들을 2달간 ㅠㅠ 못 본다는 사실이 슬프다. 어째서 다들 선릉인거야 😭 2월부터 대부분의 시간을 함께 했던 친한 사람들과도 헤어지게 되어 눈물 한 바가지... 그렇지만 새롭게 만나는 사람들과도 즐겁게 지내보자 🥺"},{"excerpt":"첫 회의 때 의논하면 좋아 보이는 것들 기능 어느 정도 구체화 원활한 소통을 위해 말 놓기 제안 코드 컨벤션 같은 거 통일? -> 근데 이건 첫 회의 때 안 해도 될 것 같음 프로젝트 개발 지향점 꼭 해보고 싶은 거라든지 지양했으면 하는 것이라든지 고도화 초점 vs 기능을 여러 개 만드는 것에 초점 프로젝트 기획 지향점 각자 지켜줬으면 하는 규칙들? 사용…","fields":{"slug":"/level3-project/"},"frontmatter":{"date":"2023년 06월 25일 07:06","title":"레벨 3 프로젝트","tags":["우테코","레벨3","프로젝트"]},"rawMarkdownBody":"\n## 첫 회의 때 의논하면 좋아 보이는 것들\n\n- 기능 어느 정도 구체화\n- 원활한 소통을 위해 말 놓기 제안\n- 코드 컨벤션 같은 거 통일? -> 근데 이건 첫 회의 때 안 해도 될 것 같음\n- 프로젝트 개발 지향점\n\t- 꼭 해보고 싶은 거라든지\n\t- 지양했으면 하는 것이라든지\n\t- 고도화 초점 vs 기능을 여러 개 만드는 것에 초점\n- 프로젝트 기획 지향점\n- 각자 지켜줬으면 하는 규칙들?\n- 사용할 tool 정리하기\n\t- 깃허브 프로젝트\n\t- 노션\n\t- 지라\n\t- 슬랙\n- 팀이 중점으로 둘 가치? (팀 문화 형성할 때 해도 될 거 같기도 하고)\n- 데일리 미팅 언제\n- 팀 명 / 서비스 명\n- 기술 스택\n\n## 첫 회의\n\n- 음악에도 썸네일을 붙여준다.\n- 제일 유명한 부분을 먼저 들어보고, 별로면 안 들어보고.\n- 주된 목적\n\t- 유저가 다 들어보기에는 피곤하니까 사람들이 좋다고 하는 부분을 먼저 들어보자.\n\t- 내 취향에 맞는 노래를 빠르게 선택하고 싶다.\n- 궁금증\n\t- 아이돌 음악은 유튜브에 킬링 파트가 많이 올라와 있다.\n\t- 영상이 아닌 음악에 한해서만 하는 걸로\n\t- 구간은 애매할 수 있다. -> 여기부터 들어봐 느낌?\n\t- 가장 많이 투표했던 노래들을 노출시킨다. \n\t- 좋은 부분의 시작 지점을 선택해서 여기서부터 들어라.\n\t- 음원은 가지고 있을 필요 없지만, 노래 리스트는 필요하다.\n\t\t- 노래 리스트 선정 방법도 중요할 듯\n\t\t- 유튜브 영상 링크로 연결되는 느낌으로\n"},{"excerpt":"어떤 이미지 링크는 다운로드가 된다 동일한 S3 버킷으로 연결되는 cloudfront 링크로 이미지를 조회했을 때, 어떤 이미지 링크는 브라우저의 창으로 이미지가 보여지는 반면 어떤 이미지는 이미지 창이 열리지 않고 다운로드가 됐다. 어떤 차이였을까? MIME 이란? MIME (Multipurpose Internet Mail Extensions) 유형은 …","fields":{"slug":"/mime/"},"frontmatter":{"date":"2023년 06월 22일 07:06","title":"MIME Type 알아보기 - 이미지 링크로 들어갔을 때 다운로드가 된다면?","tags":["matzip","개발","aws","trouble-shooting"]},"rawMarkdownBody":"\n## 어떤 이미지 링크는 다운로드가 된다\n\n동일한 S3 버킷으로 연결되는 cloudfront 링크로 이미지를 조회했을 때, 어떤 이미지 링크는 브라우저의 창으로 이미지가 보여지는 반면 어떤 이미지는 이미지 창이 열리지 않고 다운로드가 됐다.\n\n어떤 차이였을까?\n\n## MIME 이란?\n\n> MIME (Multipurpose Internet Mail Extensions) 유형은 인터넷에서 데이터를 전송하고 식별하기 위해 사용되는 표준화된 방법입니다. - GPT 선생\n\nMIME(마임이라고 읽는다)은 일종의 인코딩 방식이다. 이메일 시스템에서 파일 첨부를 위해 개발되었으나, 웹을 통해 여러 형태의 파일을 전달하는데 널리 사용되고 있다.\n\nMIME으로 인코딩한 파일은 'content-type' 정보를 파일의 앞 부분에 담고 있다. \n\nMIME 유형은 두 부분으로 구성된다.    \n첫 번째 부분은 주 유형 (Primary Type) 이다. Ex. `text`, `image`, `application` 등     \n두 번째 부분은 부 유형 (Subtype) 이다. Ex. `plain`, `jpeg`, `pdf` 등    \n두 부분은 `/` 로 구분된다.\n\n다음은 몇 가지 예시이다.\n\n`text/plain`    \n`image/jpeg`     \n`application/pdf`     \n\n파이썬으로 MIME 으로 인코딩한 파일의 바이너리 코드를 열어보면 파일의 시작 부분에 확장자가 명시되어 있다.    \n\n```text\nb'\\x89PNG\\r\\n\\x1a ...\n```\n\n이처럼 PNG 이미지 파일의 바이너리 코드에는 파일의 매직 넘버인 PNG가 들어있다.     \n\n```python\nwith open('image.png', 'rb') as file:  \n    byte_code = file.read()  \n  \nprint(byte_code)\n```\n\n바이너리 코드는 위의 파이썬 코드로 확인할 수 있다.\n\n## S3의 어떤 설정 때문이었을까?\n\n확인해보니, 업로드된 이미지의 `Content-Type` 이  `application/octet-stream` 으로 설정되어 있었다.\n\n(업로드된 파일의 메타데이터 편집에 들어가면 `Content-Type` 을 확인할 수 있다)\n\n![[octet-mime-type.png]]\n\n`application/octet-stream` 은 이진 파일을 위한 기본값이다.     \n8-bit 바이너리 배열을 의미하며, http나 email 상에서 application 이 지정되지 않았거나 형식을 모를 때 사용한다.     \n즉, 브라우저는 `octet-stream` 으로 MIME 유형이 지정된 경우, 바이너리 데이터로만 다운로드가 가능하다.   \n\n기존에 잘 열렸던 이미지의 `Content-Type` 을 확인해보자.    \n\n![[image-mime-type.png]]\n\n`Content-Type` 이 `image/png` 로 잘 설정되어 있는 것을 볼 수 있다.    \n\n## 브라우저에서 이미지 열기로 바꿔보자\n\n```java\n@Transactional\npublic ImageUploadResponse uploadImage(final MultipartFile file) {\n\tString extension = validateExtension(file);\n\tPutObjectRequest request = createRequest(file, extension);\n\ttry {\n\t\ts3Client.putObject(request, RequestBody.fromBytes(file.getBytes()));\n\t} catch (IOException e) {\n\t\tthrow new UploadFailedException();\n\t}\n\treturn new ImageUploadResponse(\"aaa\");\n}\n\nprivate PutObjectRequest createRequest(final MultipartFile file, final String extension) {\n\tString uuid = UUID.randomUUID().toString();\n\tString key = uuid + EXTENSION_DELIMITER + extension;\n\treturn PutObjectRequest.builder()\n\t\t\t.bucket(bucketName)\n\t\t\t.key(key)\n\t\t\t.contentLength(file.getSize())\n\t\t\t.build();\n}\n```\n\n기존 코드는 다음과 같다. \n\n`contentType` 을 지정해주지 않았기 때문에 자동으로 `application/octet-stream` 으로 저장되었다.     \n따라서 `contentType` 을 설정해주면 된다.\n\n```java\nreturn PutObjectRequest.builder()\n\t\t\t.bucket(bucketName)\n\t\t\t.key(key)\n\t\t\t.contentLength(file.getSize())\n\t\t\t.contentType(file.getContentType())\n\t\t\t.build();\n```\n\n이렇게 바꿔주면 `application/octet-stream` 이 아닌 파일의 `Content-Type` 으로 설정되기 때문에 브라우저가 이미지로 인식한다.     \n\n"},{"excerpt":"개요 Matzip 다른 팀원들이 AWS Management Console에 접근하게 하기 위해 관리 계정과는 다른 사용자가 필요했다. 지금은 읽기 권한만 가능하도록! 원래는 IAM 사용자를 생성하려 했는데, 이번에 IAM 자격 증명 센터가 생겼다고 해서 (권장하는 방법이래서) 한 번 사용해봤다. IAM 자격 증명 센터는 하나의 리전에만 구성할 수 있으니,…","fields":{"slug":"/matzip-aws-iam/"},"frontmatter":{"date":"2023년 06월 17일 05:06","title":"AWS IAM Identity Center 사용하기","tags":["aws","matzip"]},"rawMarkdownBody":"\n## 개요\n\nMatzip 다른 팀원들이 AWS Management Console에 접근하게 하기 위해 관리 계정과는 다른 사용자가 필요했다. 지금은 읽기 권한만 가능하도록!\n\n원래는 IAM 사용자를 생성하려 했는데, 이번에 IAM 자격 증명 센터가 생겼다고 해서 (권장하는 방법이래서) 한 번 사용해봤다.\n\nIAM 자격 증명 센터는 하나의 리전에만 구성할 수 있으니, 원래 사용하는 리전인 Asia Pacific Seoul에 구성해주었다.\n\n## 그룹 생성하기\n\n관리자 그룹과 개발자 그룹으로 분리했다. (admin, dev)\n\n그룹은 아무 조건 없이 그냥 만들 수 있다. 그룹 이름은 변경할 수 없다.\n\n## 사용자 생성하기\n\n사용자 이름, 이메일 주소, 이름, 성, 표시 이름을 입력한다.\n\n사용자 이름은 **반드시 그룹 이름과 달라야 한다**. 그룹 이름과 같으면 에러가 발생한다.\n모든 정보를 입력했다면 그룹에 할당해준다.\n\n이 과정까지 마치면 단 한 번 볼 수 있는 AWS 액세스 포털 URL, 사용자 이름, 암호가 나온다. 복사해주자.\n\n## 권한 세트 생성\n\n여기까지 수행하면 아무런 권한이 설정되어 있지 않기 때문에 AWS 액세스 포털 링크에 들어가도 아무것도 할 수 없다. 그러므로 권한 세트를 생성한 후, 그룹에 등록해주어야 한다.\n\n관리자는 모든 권한, 개발자는 읽기 권한만 줄 것이라 `사전 정의된 권한 세트` 를 사용했다.    \n잘 읽어보면 이것저것 있으니 원하는 권한을 선택하자.    \n더 자세하게 하고 싶으면 사용자 지정 권한 세트를 만들면 된다.\n\n## 권한 세트 할당\n\n사용자 및 그룹 할당에서 계정을 선택해준다.\n\n권한을 설정하고 싶은 그룹을 선택하고, 주고 싶은 권한 세트를 선택하면 된다.\n\n이 과정까지 하면 사용자 추가가 완료된다.\n개발 계정으로 로그인 하면 다음과 같은 화면이 나오는데, Management console로 들어가면 AWS를 사용할 수 있다.\n\n![[aws-iam-management-console.png]]"},{"excerpt":"S3 버킷 생성 설정 모든 퍼블릭 액세스 차단 버킷 정책은 다음과 같이 설정했다. 버전 관리 설정 X CloudFront 생성 원본 도메인에 연결하고자 하는 S3를 선택한다. 원본 액세스는 원본 액세스 제어 설정을 선택한다. (OAC) 많이 소개하는 OAI는 레거시가 되어 사용하지 않는 것을 권장한다고 한다. 제어 설정을 생성하여  을 선택하고, 원본 유…","fields":{"slug":"/matzip-aws-s3-cloudfront/"},"frontmatter":{"date":"2023년 06월 17일 05:06","title":"S3와 CloudFront 연동하기","tags":["aws","matzip"]},"rawMarkdownBody":"\n## S3 버킷 생성\n\n### 설정\n\n- 모든 퍼블릭 액세스 차단\n\n버킷 정책은 다음과 같이 설정했다.\n\n```json\n{\n    \"Version\": \"2008-10-17\",\n    \"Id\": \"PolicyForCloudFrontPrivateContent\",\n    \"Statement\": [\n        {\n            \"Sid\": \"AllowCloudFrontServicePrincipal\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": \"cloudfront.amazonaws.com\"\n            },\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::{버킷 이름}/*\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"AWS:SourceArn\": \"arn:aws:cloudfront::{숫자로 된 계정 id}:distribution/{cloudfront id}\"\n                }\n            }\n        }\n    ]\n}\n```\n\n- 버전 관리 설정 X\n\n## CloudFront 생성\n\n원본 도메인에 연결하고자 하는 S3를 선택한다.\n\n원본 액세스는 원본 액세스 제어 설정을 선택한다. (OAC)     \n많이 소개하는 OAI는 레거시가 되어 사용하지 않는 것을 권장한다고 한다.    \n제어 설정을 생성하여 `서명 요청 (권장)` 을 선택하고, 원본 유형은 S3를 선택한다.     \n이 설정 후에는 S3의 버킷 정책을 업데이트해야 한다. 복사할 수 있는 버튼이 생기니 복사해서 그대로 갖다 붙이면 된다. \n\n웹 애플리케이션 방화벽은 비활성화했다.\n설정에서는 `모든 엣지 로케이션에서 사용` 을 선택한다.    \n\n만약 커스텀 도메인이 존재한다면 Route53에 등록된 도메인을 등록하면 된다."},{"excerpt":"VPC 생성 + NAT EC2로 구축하기 + Bastion 세팅하기\nS3와 Cloudfront 연동하기\nIdentity Center로 IAM 사용자 생성하기","fields":{"slug":"/matzip-aws/"},"frontmatter":{"date":"2023년 06월 17일 05:06","title":"matzip aws 설정기","tags":["matzip","aws","네트워크"]},"rawMarkdownBody":"\n[[matzip-vpc-setting|VPC 생성 + NAT EC2로 구축하기 + Bastion 세팅하기]]\n[[matzip-aws-s3-cloudfront|S3와 Cloudfront 연동하기]]\n[[matzip-aws-iam|Identity Center로 IAM 사용자 생성하기]]"},{"excerpt":"NAT이란? IP 패킷의 TCP / UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다. 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위해 사용된다. IPv4의 주소 부족 문제를 해결하기 위한 방법으로써 고려되었다. 인터넷이 연동되는 기…","fields":{"slug":"/nat/"},"frontmatter":{"date":"2023년 06월 12일 06:06","title":"Network Address Translation","tags":["네트워크"]},"rawMarkdownBody":"\n## NAT이란?\n\nIP 패킷의 TCP / UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다.\n\n사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위해 사용된다.    \nIPv4의 주소 부족 문제를 해결하기 위한 방법으로써 고려되었다.    \n인터넷이 연동되는 기기가 많아지면서 IP 주소가 전세계적으로 유일하게 할당 되는 것은 불가능해졌다.   \n\n주로 사설 네트워크 주소를 사용하는 망에서 외부의 공인망과의 통신을 위해 네트워크 주소를 반환하는 것이다.   \n즉, 내부 망에서는 사설 IP 주소를 사용하여 통신을 하고, 외부망과 통신 시에는 NAT 을 거쳐 공인 IP 주소로 자동 변환합니다.\n\n### 장단점\n\n#### 장점\n1. 인터넷의 공인 IP 주소를 절약할 수 있다.\n\t- NAT을 사용하면 사설 IP 주소를 공유하면서 이를 공인 IP 주소와 상호 변환할 수 있도록 하여 공인 IP 주소를 다수가 함께 사용할 수 있게 한다.\n2. 인터넷이란 공공망과 연결되는 사용자들의 고유한 사설망을 침입자들로부터 보호할 수 있다.\n\t- 인터넷과 사설망 사이에 방화벽을 설치하여 외부 공격으로부터 사용자의 통신망을 보호하는 기본 수단으로 활용할 수 있다.\n\t- 인터넷 망과 연결하는 장비인 라우터에 NAT을 설정하는 경우, 라우터는 자신에게 할당된 공인 IP 주소만 외부로 알려지게 하고, 내부에서는 사설 IP 주소만 사용하도록 하여 필요 할 때 이를 서로 변환시켜 준다. 따라서 외부 침입자가 공격하기 위해서는 사설망의 내부 사설 IP 주소를 알아야 하므로 공격이 불가능하다.\n\n#### 단점\n- end-to-end 추적이 어렵다. 여러 개의 NAT 라우터에 의해 multiple NAT가 적용되었을 경우, 경로 추적이 더욱 어렵다. 이는 해커가 대상 경로를 추적하기 어렵게 만들어서 좀 더 보안성 있는 연결을 할 수 있게 한다는 관점에서도 볼 수 있다.\n- NAT 라우터를 거치는 모든 패킷을 스캔하므로 switching path delay가 커지게 된다.\n\n### 참고\n- https://jwprogramming.tistory.com/30\n- https://5kyc1ad.tistory.com/254\n"},{"excerpt":"CIDR란 클래스 없는 도메인 간 라우팅 기법 (Classless Inter-Domain Routing) 각 네트워크 대역을 구분 짓고, 구분된 네트워크간 통신을 위한 주소 체계이다.\n서브넷팅 뿐만 아니라 서브넷을 합치는 슈퍼네팅 역시 CIDR의 일환이다. IPv4 주소는 4개의 옥텟으로 이루어져 있고, 하나의 옥텟은 8비트로 이루어져 있다.\n즉, 사이더…","fields":{"slug":"/cidr/"},"frontmatter":{"date":"2023년 06월 12일 05:06","title":"CIDR","tags":["네트워크"]},"rawMarkdownBody":"\n## CIDR란\n\n클래스 없는 도메인 간 라우팅 기법 (Classless Inter-Domain Routing)\n\n각 네트워크 대역을 구분 짓고, 구분된 네트워크간 통신을 위한 주소 체계이다.\n서브넷팅 뿐만 아니라 서브넷을 합치는 슈퍼네팅 역시 CIDR의 일환이다.\n\nIPv4 주소는 4개의 옥텟으로 이루어져 있고, 하나의 옥텟은 8비트로 이루어져 있다. \n즉, 사이더는 0~32까지 총 32비트까지 사용가능하다.\n\n`143.7.65.203/16` 인 경우, `143.7.0.0` ~ `143.7.255.255` 를 사용할 수 있게 된다.\n\n### 장점\n- IP의 범위를 한 줄로 표기할 수 있다.\n- CIDR 숫자를 필요에 따라 더 쓰거나, 적게 사용해서 IP를 적절하게 할당할 수 있다.\n\n## AWS의 서브넷팅\nAWS에서는 자체 클라우드에서 설정해서 사용하고 있는 IP가 있기 때문에 총 5개를 제외해야 한다.\n\n`10.0.0.0` : 네트워크 주소\n`10.0.0.1` : AWS에서 VPC 라우터 용으로 예약 (Default Gateway)\n`10.0.0.2` : DNS 서버 주소\n`10.0.0.3` : AWS에서 앞으로 사용하려고 예약한 주소\n`10.0.0.255` : 네트워크 브로드캐스트 주소\n\n즉, AWS에 `192.168.0.0/24` 에서 총 사용가능한 호스트 개수는 256 - 5 = 251 이다.\n\n\n"},{"excerpt":"방학 때 진행할 피쳐 기획 가장 많은 투표를 받았던 기능 기능 추가:  -> 1 순위 기능 개선:  -> 조금씩만 기능 추가하는 식으로 사용자 별 평균 별점 표시 -> 최대한 빨리 구현 홈페이지 개선 애슐리의 피그마 디자인 적용하기 slack 에 디자인 반영해도 되는지 여쭤보기 마이페이지 추가","fields":{"slug":"/matzip-summer-vacation-meeting/"},"frontmatter":{"date":"2023년 06월 12일 02:06","title":"matzip 여름 방학 기획","tags":["matzip"]},"rawMarkdownBody":"\n## 방학 때 진행할 피쳐 기획\n\n- 가장 많은 투표를 받았던 기능  \n\t- 기능 추가: `마이페이지 추가` -> 1 순위\n\t- 기능 개선: `홈페이지 개선` -> 조금씩만 기능 추가하는 식으로\n\n- 사용자 별 평균 별점 표시 -> 최대한 빨리 구현\n\n## 홈페이지 개선\n- 애슐리의 피그마 디자인 적용하기\n\t- slack 에 디자인 반영해도 되는지 여쭤보기\n\n## 마이페이지 추가\n"},{"excerpt":"VPC란 Virtual Private Cloud : 가상 프라이빗 클라우드 (논리적 네트워크) 클라우드 컴퓨팅 환경에서 네트워킹을 구성하는 데 사용되는 가상 네트워크이다. 사용자가 정의한 IP 주소 범위에서 작동하며, 사용자는 서브넷, 라우팅 테이블, 네트워크 게이트웨이 등의 구성 요소를 사용하여 VPC를 세부적으로 관리할 수 있다. 장점 다른 VPC와 …","fields":{"slug":"/vpc/"},"frontmatter":{"date":"2023년 06월 11일 08:06","title":"VPC","tags":["네트워크","aws"]},"rawMarkdownBody":"\n## VPC란\n\nVirtual Private Cloud : 가상 프라이빗 클라우드 (논리적 네트워크)\n\n클라우드 컴퓨팅 환경에서 네트워킹을 구성하는 데 사용되는 가상 네트워크이다.   \n사용자가 정의한 IP 주소 범위에서 작동하며, 사용자는 서브넷, 라우팅 테이블, 네트워크 게이트웨이 등의 구성 요소를 사용하여 VPC를 세부적으로 관리할 수 있다. \n\n### 장점\n\n1. 다른 VPC와 완전히 분리된 환경을 제공하여 보안과 개인정보 보호를 강화할 수 있다.\n2. 사용자는 VPC 내에서 사용할 IP 주소 범위를 정의할 수 있다. 네트워크 주소 공간을 효율적으로 관리할 수 있다.\n3. VPC 내에서 서브넷을 생성하여 리소스를 그룹화하고, 라우팅 테이블을 사용하여 트래픽을 관리할 수 있다. 네트워크 트래픽을 효율적으로 분배하고 제어할 수 있다.\n\n\n### 참조\n- https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/what-is-amazon-vpc.html"},{"excerpt":"관련 글: ori-06-08 공부한 내용 VPC CIDR NAT 진행 사항 private 서브넷 2개, public 서브넷 2개 NAT 설정 X 가용성을 위해 가용영역 A, C에 저장  NAT 게이트 웨이 설정 public subnet에 NAT 게이트웨이 설정을 해줬다. private subnet의 라우팅 테이블에  을 nat에 연결해주었다. 실험해보지는…","fields":{"slug":"/matzip-vpc-setting/"},"frontmatter":{"date":"2023년 06월 11일 08:06","title":"matzip vpc setting","tags":["matzip","인프라","aws","네트워크"]},"rawMarkdownBody":"\n관련 글: [[ori-06-08]]\n\n## 공부한 내용\n- [[vpc|VPC]]\n- [[cidr|CIDR]]\n- [[nat|NAT]]\n\n## 진행 사항\n\n- private 서브넷 2개, public 서브넷 2개\n- NAT 설정 X\n- 가용성을 위해 가용영역 A, C에 저장\n\n![[vpc-setting.png]]\n\n### NAT 게이트 웨이 설정\n\npublic subnet에 NAT 게이트웨이 설정을 해줬다.     \n\nprivate subnet의 라우팅 테이블에 `0.0.0.0/0` 을 nat에 연결해주었다.     \n실험해보지는 않았지만 아마도 이렇게 하면 외부 인터넷 연결이 NAT으로 연결되지 않을까 싶다.    \nNAT에 연결되면 라우터를 통해 사설 IP 주소로 값이 변경되어서 내부 사설망으로 연결 된다.\n\n-> 근데 NAT 게이트 웨이는 너무 값이 비싸서 쓸 수 없다... 그래서 EC2로 NAT 게이트 웨이를 직접 만들게 되었다. \n\n### EC2 게이트 웨이 설정\n\n[이 글](https://cloudest.oopy.io/posting/007) 을 참고했다.\n\n`matzip-nat-gateway-c-prod` 으로 이름을 설정했다.\n\nNAT 이미지는 다음의 이미지를 사용했다. 꽤 최신이라.. 잘 찾아보니 6월 것도 있었다.\n\n![[nat-image.png]]\n\n인스턴스 유형은 t2.micro로 설정했다. \n\n키 페어는 새로 생성했다. `nat-gatewat-keypair.pem`\n\n네트워크 설정에서 vpc는 새롭게 만든 vpc를 설정해주고, 서브넷은 해당 가용 영역(여기서는 c)의 public subnet을 적용해주었다.   \n보안 그룹 설정에서 새로운 보안 그룹을 만들어 주었다.   \nssh 연결은 기본 설정대로 두고, 모든 트래픽으로 private subnet 의 ip를 설정해주었다.    \n퍼블릭 IP 자동 할당도 필요하다.    \n\n스토리지 볼륨에서 볼륨 유형을 `gp2` 로, 암호화됨으로 변경해주었다.    \nKMS 키는 기본값을 사용했다.\n\n고급 세부 정보에서는 최대 절전 중지 방식을 `활성화` 로 설정했다.    \n추가로 종료 방지는 `활성화` 해주었다.    \n용량 예약은 `열기` 로 변경했다.      \n\n다 설정해주고 나서 `네트워킹 -> 소스 / 대상 확인 변경` 을 중지한다.    \n\n![[source-object-check-change.png]]\n\n생성된 NAT 모두에 탄력적 IP를 설정해 주었다.    \n\nNAT을 설정한 후에는 private subnet으로 가서 라우팅 테이블을 수정해주어야 한다.    \n`0.0.0.0/0` 에서 만든 NAT 인스턴스로 연결되게 해주면 완료.    \n\n### Bastion 설정\n일반 EC2처럼 만들되, 아까 만들어 둔 VPC와 public subnet (가용영역 A) 에서 생성한다.\n퍼블릭 아이피는 할당한다. 외부에서 접근할 수 있어야 하기 때문에? (SSH 연결 가능하게)\n\n> 가용 영역 별로 Bastion을 만드는 방식이 맞을까요?\n\n굳이 가용 영역 별로 Bastion을 만들 필요는 없다.    \n가용성은 서비스가 동작할 때의 안정성을 뜻하는 것이고, 접속과는 관련 없다.\n\nprivate subnet 보안 그룹에서 bastion 보안 그룹을 SSH 22로 열어두면 private subnet의 인스턴스에 bastion으로 접근 가능하다.\n\n- 참고: https://err-bzz.oopy.io/f5616e26-79ca-4167-b2eb-140de69b9b54"},{"excerpt":"인프라 matzip-aws PR 링크 백엔드 PR 링크 submodule 적용기 로컬용 yml 파일 추가: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/142 submodule 적용: https://github.com/The-Fellowship-of-the-matzip/mat.zip…","fields":{"slug":"/matzip-feature-develop/"},"frontmatter":{"date":"2023년 06월 11일 08:06","title":"matzip 피쳐 개발","tags":["matzip","우테코"]},"rawMarkdownBody":"## 인프라\n- [[matzip-aws]]\n\n### PR 링크\n\n\n## 백엔드\n\n### PR 링크\n- submodule 적용기\n\t- 로컬용 yml 파일 추가: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/142\n\t- submodule 적용: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/154\n\t- 로컬에서 local 프로필이 적용되지 않는 이슈 해결: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/158\n- 내 리뷰 조회 + 내 정보 조회 API 개발: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/173\n"},{"excerpt":"우테코 미션 2레벨, 3레벨, 4레벨 ec2를 그냥 제공해준다. 클라우드 환경을 구축하는 일이 없다. ec2를 구축하는 일이 없다. vpc도 그냥 시키는 대로... ec2를 사용하는 것은 쓴다고 하기 좀 애매하다. vpc를 실제로 세팅하고, 내부 인스턴스들을 관리를 직접 해보는 것이 중요하다. 네트워크를 학습하는데 도움이 된다. (vpc, subnet m…","fields":{"slug":"/ori-06-08/"},"frontmatter":{"date":"2023년 06월 08일 11:06","title":"오리와 페어 6/8","tags":["matzip","우테코"]},"rawMarkdownBody":"\n## 우테코 미션\n- 2레벨, 3레벨, 4레벨\n\t- ec2를 그냥 제공해준다.\n\t- 클라우드 환경을 구축하는 일이 없다. ec2를 구축하는 일이 없다. vpc도 그냥 시키는 대로...\n\t- ec2를 사용하는 것은 쓴다고 하기 좀 애매하다.\n\t- vpc를 실제로 세팅하고, 내부 인스턴스들을 관리를 직접 해보는 것이 중요하다.\n\t- 네트워크를 학습하는데 도움이 된다. (vpc, subnet mask, bastin, ...)\n\t- 그러니 그냥 제공받는 거 쓰지 말고 vpc 세팅을 한 번 해보자!\n- 물론 데브옵스를 할 건 아니지만 vpc endpoint는 직접 구축해 보는 게 좋다.\n\n- 참고 링크 : https://tech.cloud.nongshim.co.kr/2023/03/16/%ec%86%8c%ea%b0%9c-vpc-endpoint%eb%9e%80/\n## matzip 환경\n- 환경은 총 3개가 될 것이다. (또는 운영+모니터링, 베타 2개)\n\t- 운영이 실제 띄워지는 환경\n\t- 베타가 띄워지는 환경\n\t\t- develop, staging 환경\n\t\t- 우테코에서 미션할 때는 로컬에서 개발하고 테스트 한 후에 운영에 배포한다. 그러나 운영이나 로컬이나 비슷한 환경을 맞춰도 100% 된다는 보장이 없다.\n\t\t- 최대한 운영에 비슷한 환경 -> 베타에 먼저 배포하고 QA를 실행하고 운영에 배포하는 경우가 많다.\n\t- 모니터링 환경: 그라파나 (모니터링 데이터를 UI로 가시화 하는 것) -> 운영으로 합쳐질 수도 있다.\n\t\t- CPU, Memory 수치를 보면서 ec2에 과부하가 오는지 아닌지를 파악하기 위함. \n\t\t- 요청수를 보면서 트래픽이 얼마나 들어오는지를 파악하기 위함.\n\n### 해야 할 것\n- VPC 세팅 `CIDER: 10.0.0.0/16` (관습적으로 이렇게 쓴다는데 이유도 알아보자 -> reserved ip 피해서?)\n- public subnet, private subent을 구성해야 한다. subnet은 2개로 구성해야 한다. (public도 가용영역마다 2개씩 - 2a, 2c에 하나씩 이런 식으로)\n\t- 운영 환경에 대한 라우팅 테이블(rt) 을 구축한다(지정한다).\n\t\t- 하나의 vpc 환경이 있을 때 subnet mask를 운영 환경으로 잡고 여기에 대한 라우팅 테이블을 설정한다.\n\t- (후순위) 베타 환경에 대한 라우팅 테이블(rt) 을 구축한다(지정한다).\n- ec2, s3, rds의 주소는 모두 private으로 한다.\n\t- db를 private으로 막는 이유는 직접 접근을 못하게 하기 위함.\n\t- application도 직접 접근을 막아야 한다.\n\t- 외부의 요청을 받아야 한다. -> Internet Gateway (IGW)를 사용할 것\n\t- IGW(public) -> Routing table(public) -> ec2(private)\n- 운영과 베타의 vpc를 다르게 둘 것인가에 대한 고민\n\t- 베타는 막쓰는 서버이고, 운영은 중요한 정보가 있기 때문에 베타에서 운영을 접근할 수 있게 해서는 안 된다.\n\t- 같이 두면 편하다. -> 모니터링 환경이 있는데, peering을 해야 한다.\n\t- 모니터링 환경도 vpc를 다르게 둔다고 했을 때, 모니터링(vpc3)이 운영(vpc1)과 베타(vpc2)에 접근하려면 vpc peering을 해야 한다.\n\t- 귀찮을 수도 있으니, 이점을 고려하여 다르게 둘지 같게 둘지를 판단해서 작업하자.\n\t- 물론 우테코는 하나의 vpc 안에서 작업한다.\n- subnet의 고민? subnet을 분리할 지에 대한 고민?\n=> 일단은 운영 vpc만 세팅을 하고 -> 다 하고 시간이 남으면 베타를 vpc 세팅을 똑같이 해보자. (해본 사람과 안 해본 사람이랑 페어하면서 서로 도우면서~)\n\n### 리전\n나라에 세워져 있는 AWS 큰 그림?\n서울 리전을 사용할 것.\n\n### 가용 영역\n리전 안에 여러 개가 존재한다. 서울은 4개\n데이터 센터라고 보면 된다. 실제로 데이터가 저장되는 곳은 실물로 있어야 한다.\n기본 서브넷에 가용 영역이 주어져 있다.\n\naws 데이터 센터가 아마 a-b, c-d가 같은 데이터 센터에 있을 거라서 a, c 이런 식으로 만드는 게 국룰이라고 한다. (추가로 알아보자)\n\n### vpc 워크플로\n\n- 오리가 줌에서 보여주신 사진\n\n![[vpc-workflow.png]]\n\n### 요약\n- vpc 세팅\n\t- 가용 영역은 2개를 사용한다. (a, c)\n\t- a, c가 서로 다른 데이터 센터에 위치할 듯 (검색해보기)\n- subnet 세팅 (가용 영역 - a: public1 + private1 + private 2 / 가용 영역 - b: public1 + private1 + private 2)\n\t- private 서브넷 개수?\n- rt 세팅\n- IGW 세팅\n- NAT 세팅 (일단 NAT가 뭔지부터 알아보자)\n\t- aws 에서 제공해주는 것 말고 NAT 인스턴스를 하나를 만드는 것 고려. vpc에서 인스턴스 하나 만들어서 해보기.\n\t- 너무 빡세면 ㅌㅌ\n\t- private을 다 막을 건데 private 인스턴스들이 java를 다운 받아야 하는데 막혀있어서 다운을 못한다. 그래서 NAT가 필요하다.\n- ec2 세팅 (안 해도 된다)\n\n++ '초보자를 위한 AWS 웹구축' 참고해 보기~\n\n**다음 공유 시간: 13일까지. 운영 vpc 세팅 완료 목표 !!**"},{"excerpt":"운영체제 구조 답할 수 있어야 하는 것들 운영체제에서 제공하는 서비스 시스템 콜을 사용하는 방법 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략 비교 / 대조 운영체제 부팅 프로세스 운영체제 성능 모니터링 도구 운영체제 서비스 사용자에게 도움을 주는 사용자 인터페이스 UI GUI 터치 스크린 인터페이스 CLI (명령어 라인 인터페이스) 프로그…","fields":{"slug":"/os-ch2/"},"frontmatter":{"date":"2023년 06월 08일 08:06","title":"운영체제 2장","tags":["운영체제","공룡책"]},"rawMarkdownBody":"\n# 운영체제 구조\n\n## 답할 수 있어야 하는 것들\n\n- 운영체제에서 제공하는 서비스\n- 시스템 콜을 사용하는 방법\n- 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략 비교 / 대조\n- 운영체제 부팅 프로세스\n- 운영체제 성능 모니터링 도구\n\n## 운영체제 서비스\n\n### 사용자에게 도움을 주는\n\n- 사용자 인터페이스\n\t- UI\n\t\t- GUI\n\t\t- 터치 스크린 인터페이스\n\t- CLI (명령어 라인 인터페이스)\n- 프로그램 수행 : 시스템은 프로그램을 메모리에 적재해 실행하 ㄹ수 있고, 끝낼 수 있어야 한다.\n- 입출력 연산 : 수행되는 프로그램은 입출력을 요구할 수 있다. 입출력 수행의 수단을 제공해야 한다.\n- 파일 시스템 조작 : 개인의 선택 / 특정 특성 / 성능을 제공하기 위해 다양한 파일 시스템을 제공해야 한다.\n- 통신 : 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있다. 통신은 공유 메모리 / 메시지 전달 기법을 사용하여 구현될 수 있다.\n- 오류 탐지 : 모든 가능한 오류를 항상 의식하고 있어야 한다. 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조처를 해야 한다.\n\n### 시스템 자체의 효율적인 동작을 보장하기 위한\n\n- 자원 할당 : 다수의 프로세스나 다수의 작업이 동시에 실행 될 때, 각각에 자원을 할당해 주어야 한다.\n- 기록 작성 (logging) : 어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지를 추적할 수 있다.\n- 보호 (protection) 와 보안 (security) : 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 한다. 보안은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록한다.\n\n## 사용자와 운영체제 인터페이스\n\n**사용자가 운영체제와 접촉하는 방식**\n\n- 명령 인터프리터를 통해 운영체제와 접촉하는 것\n- 그래픽 기반 사용자 인터페이스를 통해 운영체제와 접촉하는 것\n\n### 명령 인터프리터\n\n가장 중요한 기능은 사용자가 지정한 명령을 가져와서 수행하는 것이다.   \n\n명령어들이 구현되는 방식은 두 가지 일반적인 방법이 있다.\n\n1. 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우 : 제공될 수 있는 명령의 수가 명령 인터프리터의 크기를 결정한다.\n2. 시스템 프로그램에 의해 대부분의 명령을 구현하는 경우 : 명령 인터프리터는 전혀 명령을 알지 못하고, 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다.\n\t- 프로그래머가 적합한 프로그램 로직을 가진 새로운 파일을 생성하여 새로운 명령을 쉽게 추가할 수 있다.\n\t- 명령 인터프리터 프로그램이 아주 작아질 수 있고, 명령을 추가하기 위해 변경될 필요가 없다.\n\n### 그래픽 기반 사용자 인터페이스\n\n사용자가 직접 명령어를 입력하는 것이 아닌, 데스크톱이라고 특정지어지는 마우스를 기반으로 한 윈도 메뉴 시스템을 사용한다.\n\n### 터치스크린 인터페이스\n\n터치스크린에서 손가락을 누르거나 스와이프 하는 등의 제스처로 상호 작용한다.\n\n## 시스템 콜\n\n운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.   \n이러한 호출은 일반적으로 C와 C++ 언어로 작성된 함수 형태로 제공된다.\n\n### 응용 프로그래밍 인터페이스\n\n대부분의 응용 개발자들은 응용 프로그래밍 인터페이스 (API) 에 따라 프로그램을 설계한다.\n\nAPI는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.\n\n#### 응용 프로그래머가 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍하는 것은 선호하는 이유\n\n먼저 프로그램 호환성과 관련이 있다.    \nAPI 를 사용하는 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일 되고 실행된다는 것을 기대할 수 있다.     \n\n또한 실제 시스템 콜은 좀 더 자세한 명세가 필요하고 프로그램 상에서 작업하기가 API보다 더 어렵다.\n\n그럼에도 API를 호출하는 것과 시스템 콜을 호출하는 것은 강한 상관 관계가 존재한다.    \n대부분의 POSIX, Windows API 는 운영체제가 제공하는 고유의 시스템 콜과 유사하다.\n\n#### 실행 시간 환경 (RTE)\n\n컴파일러 또는 인터프리터를 포함한 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트 웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어이다.    \n\n운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 `시스템 콜 인터페이스` 를 제공한다.    \nAPI 함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부른다.    \n\n호출자는 시스템 콜의 구현과 실행 중 어떤 작업을 하는지 알 필요가 없다.    \n단지 API를 준수하고 결과로 운영체제가 어떤 행동을 할 것인지만 이해하면 된다.     \n\n---\n\n시스템 콜은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다.    \n필요한 정보의 유형과 양은 특정 운영체제와 호출에 따라 다양하다.     \n\n#### 운영체제에 매개변수를 전달하기 위한 방법\n\n1. 매개변수를 레지스터 내에 전달하는 것\n\t- 레지스터보다 더 많은 매개변수가 존재할 수도 있다 -> 매개변수를 테이블, 블록에 저장하기\n2. 매개변수가 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달되는 것\n\t- 리눅스에서는 5개 이하의 매개변수가 있으면 레지스터가 사용되고, 매개변수 개수가 5개를 넘으면 블록 방법을 사용한다.\n\t- 매개변수는 프로그램에 의해 스택에 넣어질 수 있고, 운영체제에 의해 꺼내진다.\n\n### 시스템 콜의 유형\n\n- 프로세스 제어\n- 파일 조작\n- 장치 조작\n- 정보 유지 보수\n- 통신 / 보호\n\n#### 프로세스 제어\n\n실행 중인 프로그램은 수행을 정상적으로 `end()` / 비정상적으로 `abort()` 멈출 수 있어야 한다.    \n정상이거나 비정상인 상황에서, 운영체제는 명령 인터프리터로 제어를 전달해야 한다.    \n\n---\n\n한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재 `load()` 하고 실행 `execute()` 하기를 원할 수도 있다.     \n해당 기능은 명령 인터프리터가 사용자 명령 또는 마우스 클릭을 통해 지시된 프로그램을 실행하는 것을 허용한다.\n\n그렇다면 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 줄까?     \n기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 것인지 하는 문제와 관련이 있다.     \n\n새로운 프로그램이 종료될 때 제어가 기존 프로그램으로 돌아간다면, 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다.    \n즉, 실질적으로 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이다. 이를 위한 시스템 콜이 존재한다. (`create_process()`)\n\n새로운 잡(job)이나 프로세스, 혹은 잡들이나 프로세스들의 집합을 생성한다면, 실행을 제어할 수 있어야 한다.    \n잡의 우선순위, 최대 허용 실행 시간 등을 포함하여 잡 혹은 프로세스의 속성들을 결정하고 재설정 (reset) 할 수 있는 능력이 필요하다. (`get_process_attributes()`, `set_process_attributes()`)\n또한 새로 생성한 잡이나 프로세스가 잘못되었거나 더 이상 필요 없다면 종료하기를 원할 수 있다. (`terminate_process()`)\n\n새로운 프로세스를 생성한 후에는, 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다.\n- `wait_time()` : 일정 시간만큼 기다리기 \n- `wait_event()` : 특정 이벤트가 일어날 때까지 기다리기\n\t- `signal_event()` : 프로세스들은 이벤트가 일어나면 신호를 보내야 한다.\n\n---\n둘 이상의 프로세스들은 빈번하게 데이터를 공유하기 때문에, 공유 데이터를 잠글 수 있는 시스템 콜을 제공한다.   \n그러면 잠금이 해제될 때까지 어느 프로세스도 데이터에 접근할 수 없게 된다.    \n`acquire_lock()`, `release_lock()` 시스템 콜을 제공한다.\n\n---\n**단일 태스킹 시스템 - Arduino**\n\n표준 Arduino 플랫폼은 운영체제를 제공하지 않고, 부트 로더라 불리는 작은 소프트웨어가 프로그램을 Arduino의 특정 영역으로 적재한다.    \n한순간에 하나의 프로그램만 메모리에 존재할 수 있으므로, 단일 태스킹 시스템으로 간주된다. 즉, 다른 프로그램이 적재되면 기존 프로그램을 대체하게 된다.    \n\n**다중 태스킹 시스템 -FreeBSD**\n\n사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램으 수행한다.\n\n새로운 프로세스를 시작하기 위해 셸은 `fork()` 시스템 콜을 실행한다.    \n선택된 프로그램이 `exec()` 시스템 콜을 통해 메모리에 적재되고, 프로그램이 수행된다.     \n\n셸은 프로세스가 종료하기를 기다리거나 '백그라운드' 에서 프로세스를 수행한다.    \n백그라운드에서 프로세스를 수행하는 경우, 셸은 바로 다음 명령이 입력되기를 기다린다.    \n백그라운드에서 프로세스가 수행될 때, 프로세스는 셸이 사용하고 있는 자원인 키보드로부터 직접 입력을 받을 수 없다.     \n그러나 사용자는 셸에게 입력을 제외한 다른 요청은 자유롭게 할 수 있다.    \n\n프로세스가 종료되면 `exit()` 시스템 콜을 수행하며, 0이나 오류 코드를 돌려준다.     \n\n#### 파일 관리\n\n파일을 생성 `create()` 하고 삭제 `delete()` 할 수 있어야 한다. 파일의 이름이나 파일 속성의 일부가 필요하다.    \n파일이 생성되면 그것을 열고 `open()` 사용해야 한다.    \n또한 읽고 `read()` , 쓰고 `write()`, 위치 변경 `reposition()` (되감기 `rewind()` 나 파일 끝으로 건너뛰기) 할 수 있다.    \n마지막으로 파일을 더 이상 사용하지 않음을 나타내는 파일 닫기 `close()` 가 필요하다. \n\n파일이나 디렉터리에 대해 여러 속성의 값을 결정할 수 있어야 하고, 재설정 `reset()` 할 수 있어야 한다.    \n파일 속성은 파일 이름, 파일 유형, 보호 코드, 회계 정보 등을 포함한다.    \n이를 위해서는 최소한 파일 속성 획득 `get_file_attribute()` 과 파일 속성 설정 `set_file_attribute()` 의 두 시스템 콜이 필요하다.    \n몇몇 운영체제는 파일 이동 `move()` 와 복사 `copy()` 같은 더 많은 시스템 콜을 제공한다.    \n\n#### 장치 관리 \n\n프로세스는 작업을 계속 수행하기 위해 추가 자원(주 기억장치, 디스크 드라이브, 파일에의 접근)이 필요할 수 있다.    \n자원들을 사용할 수 있다면, 자원이 주어지고 제어가 사용자 프로그램으로 복귀될 수 있다.    \n그렇지 않으면, 프로그램은 충분한 자원이 사용 가능하게 될 때까지 기다려야 한다.    \n\n다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 장치를 요청 `request()` 하는 것을 요구한다.    \n장치의 사용이 끝나면 반드시 방출 `release()` 해야 한다.     \n이런 기능은 파일의 열기, 닫기 시스템 콜과 비슷하다.     \n\n다른 운영체제들은 장치에 대해 통제되지 않은 접근을 허용하기도 한다.    \n\n일단 장치를 요청하고 할당받게 되면, 파일과 마찬가지로 `read()` , `write()` , `reposition()` 할 수 있다.    \n입출력 장치와 파일 간에는 유사성이 매우 많기 때문에, 많은 운영체제가 이 둘을 통합된 파일 - 장치 구조로 결합하였다. \n\n#### 정보 유지 관리\n\n많은 시스템이 메모리를 `dump()` 하기 위한 시스템 콜을 제공한다. 이는 디버깅에 유용하다. \n\n많은 운영체제는 프로그램의 time profㅌ을 제공한다.    \ntime profile은 프로그램이 특정 위치, 혹은 위치의 집합에서 수행한 시간의 양을 나타낸다.    \n\n운영체제는 현재 운영되고 있는 모든 프로세스에 관한 정보를 가지고 있으며, 이런 정보에 접근하기 위한 시스템 콜도 있다.    \n일반적으로, 그 프로세스 정보를 획득하고 설정하기 위한 `get_process_attributes()` 와 `set_process_attributes()` 가 있다.    \n\n#### 통신\n\n통신 모델에는 메시지 전달과 공유 메모리의 두 가지 일반적인 모델이 있다.    \n\n- 메시지 전달 모델\n통신하는 두 프로세스가 정보를 교환하기 위해 서로 메시지를 주고 받는다.    \n메시지는 두 프로세스 사이에 직접 교환되거나 우편함을 통해 간접적으로 교환될 수 있다.     \n통신이 이루어지기 전에 연결이 반드시 열려야 한다.    \n\n상대 통신자가 동일한 CPU에 있는 프로세스이든지 통신 네트워크에 의해 연결된 다른 컴퓨터에 있는 프로세스이든지 간에 그 이름을 반드시 알고 있어야 한다.    \n\n네트워크의 각 컴퓨터는 호스트 이름을 가지며, 각 컴퓨터는 이들 이름으로 일반적으로 알려져 있다.    \n각 프로세스는 프로세스 이름을 가지고 있으며, 이 이름은 운영체제에 의해 동등한 식별자로 변환되고, 식별자는 운영체제가 그 프로세스를 가리키는 데 사용할 수 있다.    \n\n호스트 이름과 프로세스 이름은 각각 `get_hostid()` 와 `get_processid()` 시스템 콜이 변환을 수행한다.    \n이 식별자는 시스템의 통신 모델에 따라 파일 시스템의 open, close 호출에 전달되거나, 특정 `open_connection()` 과 `close_connection()` 시스템 콜에 전달된다.    \n\n수신 프로세스는 통상 통신이 일어날 수 있도록 `accept_connection()` 호출에 permission을 제공한다.     \n연결을 받아들일 프로세스들의 대부분은 특수 목적의 daemon 이다.     \n`wait_for_connection()` 호출을 수행하고, 연결이 이루어질 때 깨어난다.     \n클라이언트로 알려진 통신의 출발지와 서버로 알려진 수신 daemon은 `read_message()` 와 `write_message()` 시스템 콜에 의해 메시지들을 교환한다.    \n\n`close_connection()` 호출은 통신을 종료한다.    \n\n- 공유 메모리 모델\n프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 `shared_memory_create()` 와 `shared_memory_attach()` 시스템 콜을 사용한다.    \n이때 프로세스는 동일한 위치에 동시에 쓰지 않도록 보장할 책임을 진다.    \n\n또한 프로세스 모델의 변형으로 디폴트로 메모리를 공유하는 스레드도 있다.    \n\n---\n두 방법은 운영체제에서 보편적이며, 시스템 대부분은 둘 다 구현한다.    \n\n메시지 전달은 피해야 할 충돌이 없기 때문에 소량의 데이터 교환 시에 유용하다. 또한 컴퓨터 간의 통신을 위해 메모리 공유보다 구현하기 쉽다.    \n\n공유 메모리는 한 컴퓨터 안에서는 메모리 전송 속도로 수행할 수 있으므로, 최대 속도와 편리한 통신을 허용한다.    \n그러나 보호와 동기화 부분에서 여러 문제점을 가지고 있다.   \n\n#### 보호\n\n컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원한다.     \n- `set_permision()` 과 `get_permission()` : 파일, 디스크와 같은 자원의 허가 권한을 설정하는 데 이용된다. \n- `allow_user()` 와 `deny_user()` : 특정 사용자가 지정된 자원에 대해 접근이 허가 / 불허되었는지를 명시한다.   \n\n## 시스템 서비스\n\n시스템 서비스는 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.    \n몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스이며, 나머지는 훨씬 더 복잡하다.\n\n다음과 같은 범주로 분류할 수 있다.    \n\n- 파일 관리 : 파일과 디렉터리를 생성 / 삭제 / 복사 / 이름 변경 / 인쇄 / 열거 / 조작 한다. \n- 상태 정보\n- 파일 변경 : 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 text editor를 사용할 수 있다. \n- 프로그래밍 언어 지원\n- 프로그램 적재와 수행 : 프로그램이 어셈블되거나 컴파일된 후, 수행되려면 반드시 메모리에 적재(load) 되어야 한다. absolute loader, relocatable loader, linkage editor, overlay loader 등을 제공할 수 있고, 고급어나 기계어를 위한 디버깅 시스템도 필요하다. \n- 통신 : 프로세스, 사용자, 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공한다.\n- 백그라운드 시스템 : 부트할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 갖는다. 항상 실행되는 시스템 프로그램 프로세서는 서비스, 서브시스템, 또는 daemon으로 알려져 있다. \n\n## 링커와 로더\n\n일반적으로 프로그램은 디스크에 이진 실행 파일로 존재한다. `.out` ,`.exe` 등    \nCPU에서 실행하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야 한다.    \n\n- `재배치 가능 오브젝트 파일` : 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일. 소스파일이 컴파일 되면 재배치 가능 오브젝트 파일이 된다. \n- `링커` : 재배치 가능 오브젝트 파일을 하나의 이진 실행 파일로 결합한다. 다른 오브젝트 파일 또는 라이브러리가 포함될 수 있다. \n- `로더` : 이진 실행 파일을 메모리에 적재한다. 이 과정까지 지나면 CPU 코어에서 실행할 수 있는 상태가 된다. \n- `재배치` : 링크 및 로드와 관련된 활동이다. 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조장하여 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다. \n\n## 응용 프로그램이 운영체제마다 다른 이유\n\n각 운영체제는 고유한 시스템 콜 집합을 제공한다.    \n시스템 콜은 어느 정도 같더라도 다른 장벽으로 인해 응용 프로그램을 다른 운영체제에서 실행하기 어렵다.    \n\n### 응용 프로그램이 여러 운영체제에서 실행할 수 있게 하는 방법\n\n1. 응용 프로그램은 운영체제마다 인터프리터가 제공되는 인터프리터 언어로 작성될 수 있다. 단, 인터프리터는 기계어 코드로 구성된 프로그램에 비해 성능이 떨어지고, 각 운영체제 기능의 일부만 제공하므로 관련 응용 프로그램의 기능도 제한될 수 있다.  (Python, Ruby)\n2. 응용 프로그램은 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있다. (Java) 인터프리터 시스템과 유사한 단점을 가진다.\n3. 응용 프로그램 개발자는 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API 를 사용할 수 있다. 이식은 많은 시간이 소요될 수 있고, 많은 시험과 디버깅을 거쳐서 응용 프로그램의 새 버전마다 수행되어야 한다.\n\n일반적으로 응용 프로그램의 이동성이 부족한 데에는 여러 원인이 있기 때문에 여전히 크로스 플랫폼 응용 프로그램을 개발하는 것이 어렵다. \n\n그 추가 원인\n- 각 운영체제는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식이 있다.\n- CPU 는 다양한 명령어 집합을 가지며 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있다.\n- 운영체제는 응용 프로그램이 파일 생성과 네트워크 연결 열기와 같은 다양한 활동을 요청할 수 있는 시스템 콜을 제공한다.\n\n### ABI\n\n아키텍처 수준에서 이진 코드의 여러 구성요소가 주어진 아키텍처에서 특정 운영체제와 상호 작용할 수 있는 방법을 정의하는 데 ABI (application binary interface) 가 사용된다. \n\n주소 길이, 시스템 콜에 매개변수를 전달하는 방법, 런타임 스택 구성, 시스템 라이브러리의 이진 형식 및 데이터 유형의 크기 등 하위 수준의 세부 정보를 명시한다.\n\n일반적으로 ABI 는 특정 아키텍처에 대해 명시되므로, 아키텍처 수준의 API 라고 할 수 있다.    \n특정 아키텍처에서 실행되는 특정 운영체제에 대해 ABI 가 정의되어 있기 때문에, 플랫폼 간 호환성을 거의 제공하지 않는다.\n\n## 운영체제 설계 및 구현\n\n### 설계 목표\n\n시스템을 설계할 때의 첫 번째 문제점은 시스템의 목표와 명세를 정의하는 일이다.      \n요구 조건들은 근본적으로 '사용자 목적' 과 '시스템 목적' 으로 나눌 수 있다. \n\n### 기법과 정책\n\n한 가지 중요한 원칙은 기법으로부터 정책을 분리하는 것이다.      \n\n기법은 어떤 일을 '어떻게' 할 것인가를 결정하는 것이다.     \n정책은 '무엇을' 할 것인가를 결정하는 것이다.     \n\n정책과 기법의 분리는 융통성을 위해 아주 중요하다.     \n여러 정책에서 사용되기에 충분한 융통성 있는 일반적인 기법이 바람직한 경우가 많다.     \n\n### 구현\n\n운영체제는 많은 사람에 의해 오랫동안 개발된 많은 프로그램의 집합체이므로, 구현 방법에 대해 일반적으로 말하는 것은 어렵다.     \n대부분의 운영체제는 C, C++ 같은 고급 언어로 작성되며, 극히 일부의 시스템만이 어셈블리 언어로 작성된다.     \n\n## 운영체제 구조\n\n### 모놀리식 구조\n\n운영체제를 구성하는 가장 간단한 구조는 구조가 아예 없는 것, 즉 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것이다.     \n\n최초의 UNIX 운영체제는 커널과 시스템 프로그램 두 부분으로 구성된다.    \n커널은 여러 인터페이스와 장치 드라이버로 다시 분리된다.     \n커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리, 다른 운영체제 기능을 제공한다.\n\n모놀리식 커널은 단순하지만, 구현과 확장이 어렵다.   \n그러나 성능 면에서는 뚜렷한 이점이 있다. 시스템 콜 인터페이스는 오버헤드가 거의 없고, 커널 안에서의 통신 속도가 빠르다.     \n\n### 계층적 접근\n\n모놀리식 접근법은 시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 줄 수 있으므로, 밀접하게 결합된 시스템이라고 불린다.     \n\n그 대안으로 느슨하게 결합된 시스템이 등장했다.     \n기능이 특정 기능 및 한정된 기능을 가진 개별적이고 작은 구성요소로 나뉜다.    \n한 구성요소의 변경이 해당 구성요소에만 영향을 미치고 다른 구성 요소에는 영향을 미치지 않아 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있다.     \n\n시스템은 다양한 방식으로 '모듈화' 될 수 있다.    \n그 중 계층적 접근 방식에서는 운영체제가 여러 layer로 나누어진다.     \n\n계층적 접근 방식의 장점은 구현과 디버깅이 간단하다는 것이다.     \nlayer 들은 자신의 하위층들의 서비스와 기능만을 사용하도록 요구된다.     \n\n계층화된 시스템은 컴퓨터 네트워크 (TCP / IP) 및 웹 응용 프로그램에서 성공적으로 사용됐다.     \n그럼에도 순수한 계층 접근 방식을 사용하는 운영체제는 비교적 적다.     \n\n각 계층의 기능을 적절히 정의해야 하는 문제, 여러 계층을 통과하는 오버헤드로 인한 전반적인 성능 문제가 원인이다.     \n\n### 마이크로 커널\n\n마이크로 커널 접근 방식은 모든 중요치 않은 구성 요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다.     \n통상적으로 마이크로커널은 통신 설비 외에 추가적으로 최소한의 프로세스와 메모리 관리를 제공한다.     \n\n마이크로커널의 주 기능은 클라이언트 프로그램과 역시 사용자 공간에서 수행되는 다양한 서비스 간의 통신을 제공하는 것이다.    \n클라이언트 프로그램과 서비스는 결코 직접 상호작용하지 않고, 마이크로커널과 메시지를 교환함으로써 간접적으로 상호작용한다.    \n\n장점은 운영체제의 확장이 쉽다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되므로, 커널을 변경할 필요가 없다.     \n마이크로커널은 서비스 대부분이 커널이 아닌 사용자 프로세스로 수행되기 때문에 높은 보안성과 신뢰성을 제공한다. 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지 않는다.\n\nEx. macOS 및 iOS 운영체제의 커널 구성요소인 `Darwin`, `QNX`\n\n그러나 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다. 두 개의 사용자 수준 서비스가 통신해야 하는 경우, 별도의 주소 공간에 서비스가 존재하기 때문에 메시지가 복사되어야 한다.     \n또한 메시지를 교환하기 위해 한 프로세스에서 다른 프로세스로 전환되어야 할 수도 있다.     \n"},{"excerpt":"","fields":{"slug":"/operating-system-concepts/"},"frontmatter":{"date":"2023년 06월 08일 07:06","title":"운영체제","tags":["CS","운영체제","공룡책"]},"rawMarkdownBody":"\n"},{"excerpt":"LOG 레벨 인터뷰가 있었다. 이번에도 제이슨조~ 같은 조는 그레이, 제리, 제나, 로건, 코코닥, 제이미, 주디, 무민이었다. 이번에는 좀 더 범위가 넓은 질문이 나올 것 같아서 어려워했던 Filter, Interceptor, transactional, bean에 대해 중점적으로 공부했는데 정작 나온 질문은 레이어드 아키텍처였어서 ㅋㅋㅋ 조금 아쉽긴 했…","fields":{"slug":"/2023-06-07/"},"frontmatter":{"date":"2023년 06월 07일 13:06","title":"2023년 06월 07일","tags":null},"rawMarkdownBody":"## LOG\n- 레벨 인터뷰가 있었다. 이번에도 제이슨조~ 같은 조는 그레이, 제리, 제나, 로건, 코코닥, 제이미, 주디, 무민이었다. 이번에는 좀 더 범위가 넓은 질문이 나올 것 같아서 어려워했던 Filter, Interceptor, transactional, bean에 대해 중점적으로 공부했는데 정작 나온 질문은 레이어드 아키텍처였어서 ㅋㅋㅋ 조금 아쉽긴 했지만 재밌었다. 레벨 인터뷰하면서 나도 생각 정리가 어느 정도 된 것 같아 좋았다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"ApplicationContext 언제 실행되나? 장바구니 미션의  을 실행해보자.   의  이 실행된다. 계속 타고 들어가면  의  메서드가 실행된다. 곧 지울 내용 BootStrapContext 생성  내부로 들어가보자. 는 를 생성하기 전에 를 생성하는 메서드이다.  란 애플리케이션 컨텍스트가 준비될 때까지 환경 변수를 관리하는 Spring의 Env…","fields":{"slug":"/application-context/"},"frontmatter":{"date":"2023년 06월 06일 07:06","title":"ApplicationContext 찍먹하기","tags":["spring","개발","스터디","학습로그"]},"rawMarkdownBody":"\n## ApplicationContext\n\n### 언제 실행되나?\n\n```java\n@SpringBootApplication  \npublic class JwpCartApplication {  \n    public static void main(String[] args) {  \n        SpringApplication.run(JwpCartApplication.class, args);  \n    }   \n}\n```\n\n장바구니 미션의 `SpringApplication.run` 을 실행해보자.\n\n![[spring-application-context-run.png]]\n\n`SpringApplication` 의 `run` 이 실행된다.\n\n계속 타고 들어가면 `SpringApplication` 의 `run` 메서드가 실행된다.\n\n```java\npublic ConfigurableApplicationContext run(String... args) {  \n\n   long startTime = System.nanoTime();\n\n// BootStrapContext 생성\n   DefaultBootstrapContext bootstrapContext = createBootstrapContext();  \n   ConfigurableApplicationContext context = null;  \n\n// Java AWT Headless Property 설정\n   configureHeadlessProperty();  \n\n// 스프링 애플리케이션 리스너 조회 및 starting 처리\n   SpringApplicationRunListeners listeners = getRunListeners(args);  \n   listeners.starting(bootstrapContext, this.mainApplicationClass);  \n   \n   try {  \n\n\t// Arguments 래핑 및 Environment 준비\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);  \n      ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);  \n\n\t// IgnoreBeanInfo 설정\n      configureIgnoreBeanInfo(environment);  \n\n\t// 배너 출력\n      Banner printedBanner = printBanner(environment);  \n\n\t// **애플리케이션 컨텍스트 생성**\n      context = createApplicationContext();  \n      context.setApplicationStartup(this.applicationStartup);  \n\n\t// **Context 준비 단계**\n      prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  \n\n\t// Context Refresh 단계\n      refreshContext(context);  \n\n\t// Context Refresh 후처리 단계\n      afterRefresh(context, applicationArguments);  \n\n\t// 실행 시간 출력 및 리스너 started 처리\n      Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);  \n      if (this.logStartupInfo) {  \n         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);  \n      }  \n      listeners.started(context, timeTakenToStartup);  \n\n\t// Runners 실행\n      callRunners(context, applicationArguments);  \n   }  \n   catch (Throwable ex) {  \n      handleRunFailure(context, ex, listeners);  \n      throw new IllegalStateException(ex);  \n   }  \n   ...\n   return context;  \n}\n```\n\n## 곧 지울 내용\n---\n\n### BootStrapContext 생성\n\n`createBootstrapContext()` 내부로 들어가보자.\n\n`createBootstrapContext()`는 `ApplicationContext`를 생성하기 전에 `BootstrapContext`를 생성하는 메서드이다. `BootstrapContext` 란 애플리케이션 컨텍스트가 준비될 때까지 환경 변수를 관리하는 Spring의 Environment 객체를 후처리하기 위한 임시 컨텍스트이다. \n\nSpring Boot는 다양한 환경에서 애플리케이션을 실행할 수 있으므로, `createBootstrapContext()` 는 애플리케이션을 실행할 환경과 관련된 `BootstrapContext`를 생성한다. \n\n```java\nprivate DefaultBootstrapContext createBootstrapContext() {  \n   DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();  \n   this.bootstrapRegistryInitializers.forEach((initializer) -> initializer.initialize(bootstrapContext));  \n   return bootstrapContext;  \n}\n```\n\n`initializers` 리스트를 초기화하고, 해당 리스트의 요소들에 대해 `initialize()` 메서드를 호출하여 `BootstrapContext`를 초기화한다.\n\n### Java AWT Headless Property 설정\n\nJava AWT Headless Property란 디스플레이 장치가 없는 서버 환경에서 UI 클래스를 사용할 수 있도록 하는 옵션이다.\n`java.awt.headless` 를 true로 설정하거나, 서버 시작 스크립트의 `JAVA_OPTS` 환경 변수에 `-D java.awt.headless=true` 를 설정하는 방법 등이 있다.\n\n```java\nprivate void configureHeadlessProperty() {  \n   System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,  \n         System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));  \n}\n```\n\n이 부분은 (잘 모르겠으니) 자세히 다루지 않고 넘어가겠다.\n\n---\n\n### 애플리케이션 컨텍스트 생성\n\n`createApplicationContext` 는 내부적으로 `ApplicationContextInitializer` 객체들의 `initialize()` 메서드를 호출하여 `ApplicationContext` 의 초기화 작업을 수행한다. \n\n```java\nprotected ConfigurableApplicationContext createApplicationContext() {  \n   return this.applicationContextFactory.create(this.webApplicationType);  \n}\n```\n\n코드를 보면 `ApplicationContextFactory` 팩토리 클래스에게 생성을 위임하는 것을 볼 수 있다.\n애플리케이션 컨텍스트 생성 시에는 `webApplicationType` 이 사용된다.\n\n우리의 애플리케이션은 SERVLET 기반으로 실행되기 때문에, 환경 또한 `ApplicationServletEnvironment` 로 설정되어 있다.\n\n내부는 다음과 같다.\n\n![[spring-application-context-getFactories.png]]\n\n디버깅을 해보면 `create()`로 부터 생성되는 `ConfigurableApplicationContext`는 `AnnotationConfigServletWebServerApplicationContext`인 것을 확인할 수 있다.\n\nSpring이 제공하는 ApplicationContext 구현 클래스에는 여러 가지 종류가 있다.\nSpring Application은 사용자 대신 `ApplicationContext` 의 적절한 타입을 생성하게 된다.\n\n`WebApplicationType` 은 다음과 같이 정해진다.\n\n- Spring MVC가 존재 -> `AnnotaionConfigServletWebServerApplicationContext` 사용\n- Spring MVC가 존재하지 않고, Spring WebFlux가 존재하면 `AnnotationConfigReactiveWebServerApplicationContext` 사용\n- 그 외에는 `AnnotationConfigApplicationContext` 사용\n\n### 잠깐, AnnotationConfigServletWebServerApplicationContext는 뭘까\n\n> ServletWebServerApplicationContext that accepts annotated classes as input - in particular @Configuration -annotated classes, but also plain @Component classes and JSR-330 compliant classes using javax.inject annotations. Allows for registering classes one by one (specifying class names as config location) as well as for classpath scanning (specifying base packages as config location). \n> \n> Note: In case of multiple @Configuration classes, later @Bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions through an extra Configuration class.\n\n`AnnotationConfigServletWebServerApplicationContext` 는 우리가 Spring 애플리케이션을 사용할 때 실행되는 웹 `ApplicationContext` 중의 하나이다. \nJava Config를 사용하여 웹 애플리케이션을 설정하기 위해 사용된다.\n\n입력으로 `@Configuration` 어노테이션, `@Component` 어노테이션, javax.inject 어노테이션을 사용하는 JSR-330 compilant 클래스들을 받는다. 클래스 이름을 설정 위치로 특정하여 클래스들을 등록하고, base 패키지들을 설정 위치로 특정하여 classpath scanning을 한다.\n\n`@Configuration` 클래스들이 여러 개 있는 경우, 이후의 `@Bean` 정의들은 더 먼저 로드된 파일에서 정의된 bean을 오버라이딩 한다. 이는 특정 bean 정의를 추가 configuration 클래스를 통해 일부러 오버라이딩하기 위해 사용될 수 있다.\n\n`GenericWebApplicationContext` 의 서브 클래스이며, 서브 클래스 자체는 `GenericApplicationContext` 의 서브 클래스이다. \n웹 애플리케이션 중에서도 특히 서블릿 컨테이너 내부에서 실행되는 애플리케이션에 사용할 수 있는 Spring ApplicationContext를 생성하는데 사용된다.\n\n### Context 준비 단계\n\nContext가 생성된 후에 해주어야 하는 후처리 작업들과 bean을 등록하는 refresh 단계를 위한 전처리 작업을 수행한다.\n\n```java\nprivate void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,  \n      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,  \n      ApplicationArguments applicationArguments, Banner printedBanner) {  \n\t\n   // Environment를 애플리케이션 컨텍스트에 설정한다. \n   context.setEnvironment(environment);  \n   postProcessApplicationContext(context);  \n\n   // Initializer initialize 해주기\n   applyInitializers(context);  \n   listeners.contextPrepared(context);  \n   \n   // BootstrapContext 종료\n   bootstrapContext.close(context);  \n   if (this.logStartupInfo) {  \n      logStartupInfo(context.getParent() == null);  \n      logStartupProfileInfo(context);  \n   }  \n   \n   // Add boot specific singleton beans  \n   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();  \n   beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);  \n   if (printedBanner != null) {  \n      beanFactory.registerSingleton(\"springBootBanner\", printedBanner);  \n   }  \n   if (beanFactory instanceof AbstractAutowireCapableBeanFactory) {  \n      ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(this.allowCircularReferences);  \n      if (beanFactory instanceof DefaultListableBeanFactory) {  \n         ((DefaultListableBeanFactory) beanFactory)  \n            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);  \n      }  \n   }   if (this.lazyInitialization) {  \n      context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());  \n   }  \n   context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));  \n   \n   // Load the sources  \n   Set<Object> sources = getAllSources();  \n   Assert.notEmpty(sources, \"Sources must not be empty\");  \n   load(context, sources.toArray(new Object[0]));  \n   listeners.contextLoaded(context);  \n}\n```\n\n`applyInitializer` 에서는 SpringApplication에 등록된 `ApplicationContextInitializer` 를 가져온다. 가져온 `ApplicationContextInitializer` 리스트를 반복하여 각각의 `ApplicationContextInitializer` 의 `initialize()` 를 호출한다.\n\n사용자가 추가한 설정을 적용하여, `ApplicationContext` 가 정상적으로 구동될 수 있도록 한다.\n\n![[initializer.png]]\n\n애플리케이션 컨텍스트가 생성되고, initializer들의 initialize까지 진행되면 `BootstrapContext`가 불필요하므로 `BootstrapContext` 를 종료해준다.\n\n- `DefaultSingletonoBeanRegistry` 의  `registerSingleton()`\n\n```java\n@Override  \npublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {  \n   Assert.notNull(beanName, \"Bean name must not be null\");  \n   Assert.notNull(singletonObject, \"Singleton object must not be null\");  \n   synchronized (this.singletonObjects) {  \n      Object oldObject = this.singletonObjects.get(beanName);  \n      if (oldObject != null) {  \n         throw new IllegalStateException(\"Could not register object [\" + singletonObject +  \n               \"] under bean name '\" + beanName + \"': there is already object [\" + oldObject + \"] bound\");  \n      }  \n      addSingleton(beanName, singletonObject);  \n   }  \n}\n```\n\nbean의 이름과 인스턴스를 인자로 받아 bean의 이름으로 싱글톤 레지스트리에 bean의 인스턴스를 등록한다. \n\n동일한 이름의 bean이 이미 등록되어 있으면, 덮어쓰지 않고 예외를 발생시켜 bean의 중복 등록을 방지한다. \n(`SpringApplicationBuilder` 나 `properties` 를 통해 해당 옵션을 변경할 수는 있지만 가급적 기본값을 사용하는 것이 좋다. 중복된 bean이 등록되는 경우 IoC 컨테이너에서 어떤 bean을 사용해야 할 지 결정할 수 없어 예기치 못한 동작을 일으킬 수 있다.)\n\n### Context Refresh 단계\n\n싱글톤 빈으로 등록할 클래스들을 찾아서 생성하고, 후처리하는 단계이다.\n`refresh` 를 거치면 모든 객체들이 싱글톤으로 인스턴스화 되는데, 에러가 발생하면 모든 bean을 제거한다.\n\n즉, `refresh()` 를 거쳤을 때 싱글톤으로 모두 인스턴스화 되던지, 아예 인스턴스화 되지 않아야 한다.\n\n- `AbstractApplicationContext`: `refresh()` \n\n```java\n@Override  \npublic void refresh() throws BeansException, IllegalStateException {  \n   synchronized (this.startupShutdownMonitor) {  \n      StartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");  \n  \n      // Prepare this context for refreshing.  \n      // Refresh를 위해 context 준비하기 \n      prepareRefresh();  \n  \n      // Tell the subclass to refresh the internal bean factory.  \n      // 내부 Bean Factory 준비하기\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  \n  \n      // Prepare the bean factory for use in this context.  \n      // 해당 context에서 사용하기 위한 Bean Factory 준비하기\n      prepareBeanFactory(beanFactory);  \n  \n      try {  \n         // Allows post-processing of the bean factory in context subclasses.  \n         // Bean Factory의 후처리 진행\n         postProcessBeanFactory(beanFactory);  \n  \n         StartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\");  \n         \n         // Invoke factory processors registered as beans in the context.  \n         // Context에 bean으로 등록되는 Factory processor 실행 (BeanFactoryPostProcessor 실행)\n         invokeBeanFactoryPostProcessors(beanFactory);  \n  \n         // Register bean processors that intercept bean creation.  \n         // Bean 생성을 가로채는 Bean Processor 등록 (BeanPostProcessor 등록)\n         registerBeanPostProcessors(beanFactory);  \n         beanPostProcess.end();  \n  \n         // Initialize message source for this context.  \n         // messageSource 및 Event Multicaster 초기화\n         initMessageSource();  \n  \n         // Initialize event multicaster for this context.  \n         initApplicationEventMulticaster();  \n  \n         // Initialize other special beans in specific context subclasses.  \n         // 웹 서버 생성\n         onRefresh();  \n  \n         // Check for listener beans and register them.  \n         // listener 빈들을 조회 및 등록\n         registerListeners();  \n  \n         // Instantiate all remaining (non-lazy-init) singletons.  \n         // 빈 인스턴스화 및 후처리\n         finishBeanFactoryInitialization(beanFactory);  \n  \n         // Last step: publish corresponding event.  \n         finishRefresh();  \n      }  \n  \n      catch (BeansException ex) {  \n         if (logger.isWarnEnabled()) {  \n            logger.warn(\"Exception encountered during context initialization - \" +  \n                  \"cancelling refresh attempt: \" + ex);  \n         }  \n  \n         // Destroy already created singletons to avoid dangling resources.  \n         destroyBeans();  \n  \n         // Reset 'active' flag.  \n         cancelRefresh(ex);  \n  \n         // Propagate exception to caller.  \n         throw ex;  \n      }  \n  \n      finally {  \n         // Reset common introspection caches in Spring's core, since we  \n         // might not ever need metadata for singleton beans anymore...         resetCommonCaches();  \n         contextRefresh.end();  \n      }  \n   }}\n```\n\n`DefaultListableBeanFactory` bean 팩토리를 생성한다.\n\n`prepareBeanFactory()` 에서 의존성 주입을 무시할 인터페이스들을 등록한다.\n\n```java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {  \n   // Tell the internal bean factory to use the context's class loader etc.  \n   beanFactory.setBeanClassLoader(getClassLoader());  \n   if (!shouldIgnoreSpel) {  \n      beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));  \n   }  \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));  \n  \n   // Configure the bean factory with context callbacks.  \n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));  \n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);  \n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);  \n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);  \n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);  \n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);  \n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);  \n   beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);  \n  \n   // BeanFactory interface not registered as resolvable type in a plain factory.  \n   // MessageSource registered (and found for autowiring) as a bean.   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);  \n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);  \n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);  \n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);  \n  \n   // Register early post-processor for detecting inner beans as ApplicationListeners.  \n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));  \n  \n   // Detect a LoadTimeWeaver and prepare for weaving, if found.  \n   if (!NativeDetector.inNativeImage() && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {  \n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));  \n      // Set a temporary ClassLoader for type matching.  \n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));  \n   }  \n  \n   // Register default environment beans.  \n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {  \n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());  \n   }  \n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {  \n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());  \n   }  \n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {  \n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());  \n   }  \n   if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) {  \n      beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());  \n   }  \n}\n```\n\n`postProcessBeanFactory()` 에서 beanPostProcessor를 등록하고, bean 팩토리에 `WebApplicationContext`와 관련된 스코프를 등록한다. \n\n```java\n@Override  \nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {  \n   beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));  \n   beanFactory.ignoreDependencyInterface(ServletContextAware.class);  \n   registerWebApplicationScopes();  \n}\n```\n\n`invokeBeanFactoryPostProcessors()`는 ConfigClass의 bean 정의와 기타 bean 정의를 로딩한다.\n\n`registerBeanPostProcessors()` 는 bean 생성을 가로채는 bean 프로세서들을 등록한다.\n\n`initMessageSource()`, `initApplicationEventMulticaster()`에서 message source와 multicaster의 bean을 등록한다.\n\n`onRefresh()` 에서는 `WebServerFactory`를 통해 `Tomcat Server` 객체를 만들고 설정 값들을 세팅한다.\n\n`registerListeners()` 는 `EventMultiCaster` 에 리스너를 등록한다.\n\n`finishBeanFactoryInitialization()` 에서는 bean 팩토리의 설정과 정의들을 프리징하고, 남은 싱글톤 빈들을 모두 인스턴스로 등록한다.\n\n마지막으로 `finishRefresh()` 는 마지막 이벤트를 발행하고, 등록되어 있는 이벤트 리스너를 별도 스레드로 실행한다. 이후 Tomcat Server를 시작한다.\n\nrefresh의 자세한 동작 과정은 다음 포스팅을 기대해주세요~\n\n## 정리\n애플리케이션에 대한 Configuration을 제공하는 인터페이스이다. Bean Factory를 상속받아 확장되었다.\n`@Configuration` 이 붙은 클래스들을 설정 정보로 등록해두고, `@Bean` 이 붙은 메서드의 이름으로 bean 목록을 생성한다.\n클라이언트가 해당 bean을 요청하면 bean 목록에서 요청한 이름이 있는지 찾고, 있으면 해당 bean 생성 메서드를 호출하여 객체를 생성하고 돌려준다.\n\n## 추가할 내용\n- bean 후처리\n- BeanDefinition이 어디서 초기화 되는가? -> [[bean]] 에 추가했습니다.\n- getBean 알아보기\n\n## 참고 자료\n- https://www.baeldung.com/spring-beanfactory-vs-applicationcontext\n- [망규형 블로그 - Application Run](https://mangkyu.tistory.com/213)\n- [망규형 블로그 - refresh](https://mangkyu.tistory.com/214)\n- https://pplenty.tistory.com/6"},{"excerpt":"Prototype Bean과 Singleton Bean을 섞어서 사용하는 경우 Prototype Bean 내부에서 Singleton Bean을 참조하는 경우 프로토타입 빈에서 싱글톤 빈을 사용하는 경우는 아무런 문제가 발생하지 않는다.\n프로토타입 빈 인스턴스는 계속해서 생성되지만, 주입받는 싱글톤 빈은 계속 동일한 하나의 인스턴스이다. Singleton …","fields":{"slug":"/bean-scope/"},"frontmatter":{"date":"2023년 06월 06일 06:06","title":"Spring Bean Scope","tags":["Spring","개발"]},"rawMarkdownBody":"\n## Prototype Bean과 Singleton Bean을 섞어서 사용하는 경우\n\n### Prototype Bean 내부에서 Singleton Bean을 참조하는 경우 \n\n프로토타입 빈에서 싱글톤 빈을 사용하는 경우는 아무런 문제가 발생하지 않는다.\n프로토타입 빈 인스턴스는 계속해서 생성되지만, 주입받는 싱글톤 빈은 계속 동일한 하나의 인스턴스이다. \n\n### Singleton Bean 내부에서 Prototype Bean을 참조하는 경우\n\n싱글톤 빈 내부의 프로토타입 빈은 주입되고 나서 인스턴스가 새로 생성되지 않는다. (프로토타입 빈임에도 불구하고)\n\n#### 해결 방법\n\n1. ProxyMode 설정\n\n객체의 해시코드를 확인하기 위한 코드를 작성한다.\n\n```java\n@SpringBootApplication  \npublic class DemoApplication implements CommandLineRunner {  \n  \n    public static void main(String args[]) {  \n        SpringApplication.run(DemoApplication.class, args);  \n    }  \n  \n    @Autowired  \n    ApplicationContext applicationContext;  \n  \n    @Override  \n    public void run(String... strings) throws Exception {  \n        System.out.println(applicationContext.getBean(Single.class));  \n        System.out.println(applicationContext.getBean(Single.class));  \n        System.out.println(applicationContext.getBean(Single.class));  \n  \n        System.out.println();  \n  \n        System.out.println(applicationContext.getBean(Proto.class));  \n        System.out.println(applicationContext.getBean(Proto.class));  \n        System.out.println(applicationContext.getBean(Proto.class));  \n        System.out.println(applicationContext.getBean(Proto.class));  \n  \n        System.out.println();  \n  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n    }  \n}\n```\n\n프로토타입 빈에 proxymode를 설정한다.\n\n```java\n@Component  \n@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)  \npublic class Proto {  \n}\n```\n\n```java\n@Component  \npublic class Single {  \n    private final Proto proto;  \n  \n    public Single(final Proto proto) {  \n        this.proto = proto;  \n    }  \n  \n    public Proto getProto() {  \n        return proto;  \n    }  \n}\n```\n\n결과는 다음과 같다. 싱글톤 빈에서도 프로토타입 빈이 계속해서 생성되는 것을 볼 수 있다.\n\n```shell\nhello.Single@7a9ceddf\nhello.Single@7a9ceddf\nhello.Single@7a9ceddf\n\nhello.Proto@4c6a4ffd\nhello.Proto@3aed69dd\nhello.Proto@3f1a9a53\nhello.Proto@1ca3d25b\n\nhello.Proto@2287395\nhello.Proto@535a518c\nhello.Proto@38f981b6\nhello.Proto@3a4aadf8\nhello.Proto@7bbfc5ff\n```\n\n2. `ObjectProvider` 사용하기\n\n싱글톤 빈의 필드로  `ObjectProvider` 를 추가한다.\n\n```java\n@Component  \npublic class Single {  \n    @Autowired  \n    private ObjectProvider<Proto> objectProvider;  \n  \n    public Proto getProto() {  \n        return objectProvider.getIfAvailable();  \n    }  \n}\n```\n\n```shell\nhello.Single@1d98daa0\nhello.Single@1d98daa0\nhello.Single@1d98daa0\n\nhello.Proto@54336976\nhello.Proto@f25f48a\nhello.Proto@3b7c80c6\nhello.Proto@3b2e5c0d\n\nhello.Proto@79eeff87\nhello.Proto@8bd076a\nhello.Proto@1378eea2\nhello.Proto@66522ead\nhello.Proto@e91b4f4\n```\n\n동일한 동작을 하지만, 자바 객체가 POJO 스타일에서 벗어나게 된다.\n\n"},{"excerpt":"LOG 배운 것  Service를 지정하고,  어노테이션이 '인터페이스' 객체에 지정되어 있는 경우, 인터페이스 객체는 구현체가 아닌 인터페이스 객체가 생성되어 주입된다. 어차피 mock 객체이기 때문에 mockito에서 구현체를 사용하지 않고 인터페이스를 그대로 사용하는 듯 하다. 을 사용할 때, 비교하는 객체가 다른 클래스더라도 내부 필드 이름이 같으…","fields":{"slug":"/2023-06-06/"},"frontmatter":{"date":"2023년 06월 06일 05:06","title":"2023년 06월 06일","tags":null},"rawMarkdownBody":"## LOG\n\n## 배운 것\n- `@InjectMocks` Service를 지정하고, `@Mock` 어노테이션이 '인터페이스' 객체에 지정되어 있는 경우, 인터페이스 객체는 구현체가 아닌 인터페이스 객체가 생성되어 주입된다. 어차피 mock 객체이기 때문에 mockito에서 구현체를 사용하지 않고 인터페이스를 그대로 사용하는 듯 하다.\n- `usingRecursiveComparison()`을 사용할 때, 비교하는 객체가 다른 클래스더라도 내부 필드 이름이 같으면 그대로 비교가 된다 ㄷㄷ 필드 타입과 이름만 같으면 비교 가능하다.\n- mocking된 객체의 경우 따로 행동을 지정해주지 않으면 자동으로 기본값을 리턴한다. (void는 안 써줘도 무방)\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"Interceptor란? Controller의 Handler를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터 컨트롤러에 들어오는 요청  와 응답하는  를 가로채는 역할을 한다.\n 은 핸들러 매핑을 통해 적절한 컨트롤러를 찾도록 요청하고,  을 돌려준다. 왜 써야 할까? 기존 컨트롤러의 로직을 수정하지 않고 사전, 사후에 제어가 …","fields":{"slug":"/interceptor/"},"frontmatter":{"date":"2023년 06월 06일 02:06","title":"Interceptor","tags":null},"rawMarkdownBody":"\n## Interceptor란?\n\nController의 Handler를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터\n\n컨트롤러에 들어오는 요청 `HttpRequest` 와 응답하는 `HttpResponse` 를 가로채는 역할을 한다.\n`DispatcherServlet` 은 핸들러 매핑을 통해 적절한 컨트롤러를 찾도록 요청하고, `HandlerExecutionChain` 을 돌려준다.\n\n## 왜 써야 할까?\n\n기존 컨트롤러의 로직을 수정하지 않고 사전, 사후에 제어가 가능하다.\n\nEx. 세션 인증\n요청을 받아들이기 전에 세션에 로그인한 사용자가 있는지 확인해보고, 없다면 로그인 페이지로 리다이렉트할 수 있다. 인터셉터가 없다면 모든 컨트롤러마다 해당 로직이 필요하다.\n\n## Interceptor 메서드\n\n```java\npublic interface HandlerInterceptor { \n\tdefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { \n\t\treturn true; \n\t} \n\t\n\tdefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception \n\t{ } \n\t\n\tdefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { } \n}\n```\n\n- `preHandle` : 컨트롤러가 호출되기 전에 실행된다. 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가할 때 사용한다. 반환값이 true이면 다음 단계로 진행되고, false 라면 작업을 중단하여 이후의 인터셉터나 컨트롤러로 진행되지 않는다.\n- `postHandle` : 컨트롤러 호출 후에 실행된다. 컨트롤러 작업 이후에 처리해야 하는 후처리 작업이 있을 때 사용한다. 컨트롤러 하위 계층에서 작업을 진행하다가 중간에 예외 발생 시 호출되지 않는다.\n- `afterCompletion` : 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행된다. 요청 처리 중에 사용한 리소스를 반환할 때 사용하기 좋다. 컨트롤러 하위 계층에서 작업을 진행하다가 예외가 발생하더라도 반드시 호출된다.\n\n## Filter와의 비교\n\n더 자세한 내용은 [[filter]] 확인\n\n### 공통점\n\n특정 URI에 접근할 때 제어하는 용도로 사용된다.\n\n### 차이점\n\n**영역의 차이**\nFilter는 동일한 웹 애플리케이션의 영역 내에서 필요한 자원들을 활용한다. 웹 애플리케이션 내에서 동작하므로 스프링에 Context를 접근하기 어렵다고 하나, 요즘에는 필터에서도 스프링 설정 정보에 접근할 수 있다.\n\nInterceptor는 스프링에서 관리되어 스프링의 모든 객체에 접근이 가능하다.\n\n**스프링의 예외 처리 차이**\nFilter에서 예외가 던져지면 에러가 처리되지 않고 서블릿까지 전달된다. \nFilter는 주로 `doFilter()` 주변을 try-catch 로 감싸서 그 시점에서 발생한 예외를 바로 핸들링한다.\n\nInterceptor는 `@ControllerAdvice` 와 `@ExceptionHandler` 를 사용하여 예외 처리가 가능하다.\n\n**호출 시점의 차이**\nFilter는 `DispatcherServlet` 이 실행되기 전, Interceptor는 `DispatcherServlet` 이 실행되며 호출된다.\n\n**Request/Response 객체 조작 가능 여부**\nFilter가 다음 필터를 호출하기 위해서는 필터 체이닝을 해주어야 하는데, 이때 Request/Response 객체를 넘겨주므로 원하는 Request, Response 객체를 넘겨줄 수 있다.\n\nInterceptor는 boolean만 반환할 수 있으므로 다음 Interceptor로 Request/Response 객체를 넘겨줄 수 없다.\n\n## ArgumentResolver와의 비교\n\n### ArgumentResolver란?\n\n어떤 요청이 컨트롤러에 들어왔을 때, 요청에 들어온 값으로부터 원하는 객체를 생성하는 일을 `ArgumentResolver` 가 간접적으로 수행해줄 수 있다.\n\nEx. 사용자가 로그인되어 있을 때, 올바른 사용자인지 검증하는 경우\n유효한 인증 정보를 갖고 있는지 확인하고, Member로 만들어주는 작업이 필요한 경우를 생각해보자.\n검증 코드가 Controller 에 존재할 때는 모든 메서드에 같은 코드가 중복되고, Controller의 책임이 증가한다.\n\n### ArgumentResolver 사용\n\n`HandlerMethodArgumentResolver` 를 구현하여 사용할 수 있다.\n\n다음과 같은 메서드를 구현해야 한다.\n\n```java\nboolean supportsParameter(MethodParameter parameter);\n\n@Nullable\nObject resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;\n```\n\n- `supportsParameter` : 핸들러의 특정 파라미터를 지원하는지 여부를 판단하기 위한 메서드. 어떤 파라미터에 대해 작업을 수행할 것인지를 정의하는 곳\n- `resolveArgument` : 해당 파라미터에 대한 실질적인 로직을 처리하는 곳. parameter에 전달할 객체에 대한 조작을 진행한 후, 해당 객체를 리턴한다.\n\n구현한 `HandlerMethodArgumentResolver` 는 `WebMvcConfigurer` 를 구현한 `@Configuration` 클래스에 `addArgumentResolvers` 를 통해 등록해주어야 한다.\n\n### Interceptor와 차이점\n\nArgumentResolver는 Interceptor 이후에 동작하고, 어떤 요청이 컨트롤러에 들어왔을 때, 요청에 들어온 값으로부터 원하는 객체를 반환한다.\n\n그러나 인터셉터는 실제 컨트롤러가 실행되기 전에 요청을 가로채고, 특정 객체를 반환할 수 없다.\n\n## 용도\n클라이언트 요청과 관련된 전역적으로 처리해야 하는 작업을 처리할 수 있다.\n`HttpServletResponse`, `HttpServletRequest` 객체 자체를 바꿔치기 할 수는 없지만, 내부 값은 조작 가능하다.\n\n다음과 같은 경우에 사용하는 것을 권장한다.\n\n- 인증/인가와 같은 공통 작업 : 클라이언트 요청과 관련된 작업들을 컨트롤러로 넘어가기 전에 검사할 수 있다.\n- Controller로 넘겨주는 정보 가공: 전달받는 Request, Response 객체를 가공하여 컨트롤러에 전달할 수 있다. \n- API 호출에 대한 로깅: 클라이언트의 정보를 기록한다."},{"excerpt":"Filter란?  처리 전 후에 동작하여 사용자의 요청이나 응답의 최전방에 존재한다. Java Servlet에서 제공된다.\n요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 부가 작업을 처리할 수 있는 기능을 제공한다. 스프링 빈으로 등록될 수 있다. Filter의 메서드 Filter 인터페이스를 구현해야 필터를 추가할 수 있다.  : 필터가 웹 …","fields":{"slug":"/filter/"},"frontmatter":{"date":"2023년 06월 06일 02:06","title":"Filter","tags":null},"rawMarkdownBody":"\n## Filter란?\n\n`DispatcherServlet` 처리 전 후에 동작하여 사용자의 요청이나 응답의 최전방에 존재한다. Java Servlet에서 제공된다.\n요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 부가 작업을 처리할 수 있는 기능을 제공한다.\n\n스프링 빈으로 등록될 수 있다.\n\n## Filter의 메서드\n\nFilter 인터페이스를 구현해야 필터를 추가할 수 있다.\n\n```java\n public interface Filter {  \n  \n    public default void init(FilterConfig filterConfig) throws ServletException {}  \n  \n    public void doFilter(ServletRequest request, ServletResponse response,  \n            FilterChain chain) throws IOException, ServletException;  \n  \n    public default void destroy() {}  \n}\n```\n\n`init()` : 필터가 웹 컨테이너에 생성될 때 실행된다.\n`doFilter()` : Request, Response가 필터를 거칠 때 수행되는 메서드로, 체인을 따라 다음에 존재하는 필터로 이동한다. url 패턴에 맞는 모든 HTTP 요청이 `DispatcherServlet` 으로 전달되기 전에 웹 컨테이너에 의해 실행된다.\n`destroy()` : 필터가 소멸될 때 실행된다.\n\n## 용도\n요청 파라미터 자체의 검증 및 처리를 담당한다.\n\n- 보안 관련 공통 작업: 필터는 웹 컨테이너에서 동작하므로 보안 검사를 통해 올바른 요청이 아닌 경우 차단할 수 있다. 스프링 컨테이너까지 요청이 전달되지 않고 차단되므로 안정성을 높일 수 있다.\n- 모든 요청에 대한 로깅\n- 이미지 / 데이터 압축 및 문자열 인코딩: 웹 애플리케이션에서 전반적으로 사용되는 기능을 구현한다.\n\n## 참고\n- https://mangkyu.tistory.com/173\n- https://steady-coding.tistory.com/601"},{"excerpt":"","fields":{"slug":"/localdatetime-vs-timestamp/"},"frontmatter":{"date":"2023년 06월 04일 10:06","title":"LocalDateTime vs Timestamp","tags":["개발","학습로그","database","미완성"]},"rawMarkdownBody":"\n"},{"excerpt":"공부를 한다. 공부 왜 레벨3는 사실상 프로젝트 기간. 공부를 얼마나 많이 할 수 있을까?\n다른 공부를 레벨5 때 시작한다면? 나는 레벨 5 때 무슨 공부를 할까?\n바뀌지 않는 것: 나는 우테코를 수료하고 학교로 돌아가서 졸업을 한다. 우형 / 다른 회사에 취업했을 때 -> 4-1은 그냥 어떻게든 졸업한다.\n데이터베이스, 네트워크, 캡스톤 -> 9학점\n멀…","fields":{"slug":"/vacation-plan/"},"frontmatter":{"date":"2023년 06월 04일 05:06","title":"방학 계획","tags":null},"rawMarkdownBody":"\n공부를 한다.\n\n# 공부\n\n## 왜\n\n레벨3는 사실상 프로젝트 기간. 공부를 얼마나 많이 할 수 있을까?\n다른 공부를 레벨5 때 시작한다면? 나는 레벨 5 때 무슨 공부를 할까?\n바뀌지 않는 것: 나는 우테코를 수료하고 학교로 돌아가서 졸업을 한다.\n\n- 우형 / 다른 회사에 취업했을 때 -> 4-1은 그냥 어떻게든 졸업한다.\n\t데이터베이스, 네트워크, 캡스톤 -> 9학점\n\t멀티코어 컴퓨팅, 오픈소스SW프로젝트, 컴퓨터시스템및어셈블리언어, 무언가 하나 -> 21학점\n\n- 취업하지 못했을 때 -> 굳이 한 학기에 졸업할 필요 없다.\n\t- 1학기 \n\t\t- 데이터베이스, 네트워크, 캡스톤, 멀티코어 컴퓨팅, 오픈소스SW프로젝트, 컴퓨터시스템및어셈블리언어 -> 18학점\n\t- 2학기 \n\t\t- 설계패턴 -> 3학점\n\n**이론**\n취업을 위한 공부 -> 알고리즘, CS\n프로젝트를 위한 공부 -> 어느 정도의 CS, 네트워크, 데이터베이스\n\n=> 언젠가는 해야 하는 공부. 브라운이 CS는 슬슬 시작하라고 하기도 했음.\n알고리즘은 해두면 언제나 좋은. 단기간 연습이 필요하다. 그러나 우테코 수료하기 전의 프로젝트에서는 기본적인 것 빼고 필요 없다.\nCS는 기초 지식이기 때문에 예외를 만났을 때 왜 이런지 어느 정도 파악할 수 있는 지식이 된다. 취업에 중요한 공부 중에 하나. 그렇지만 프로젝트할 때 직접적으로 도움이 되지는 않는다.\n데이터베이스는 프로젝트 때 JPA 쓸 거라서 한다면 쿼리 공부보다는 좀 더 이론적인 공부에 치중할 듯. 가장 우선순위가 낮다.\n네트워크는 취업 공부할 때도 필요하다. 프로젝트에서도 좀 더 중요하게 다뤄질 것 같다. 인프라 쪽 문제 발생했을 때 해결하기 좋을 듯. 그러나 취업 공부에서는 상대적으로 CS나 알고리즘보다 우선순위가 낮다.\n\n**기술**\n기술 자체에 대한 공부 -> Spring, JPA(오찌가 깊게 파지는 말라고 했으니까 기능 습득 위주), Docker, Jenkins ...\n\n=> 프로젝트에 쓸 기술은 어떻게 공부하면 좋을까? 그냥 무작정 시작할 수도 있고, 책을 읽을 수도 있고\n무작정 시작하는 것은 별로 좋지는 않은 것 같다. 크게 기억에 남는 것도 없고, 제대로 배우기보다는 지식 겉핥기로 끝나는 경우가 많았다.\n기술을 먼저 생각하고 프로젝트를 진행하는 것은 옳은가? 부족한 상황에서 develop 해가는 것이 맞나?\n필요성을 느끼고 기술을 도입하는 것이 더 좋은 듯.\n기술은 도구일 뿐 기술을 위해 뭔가를 시작해서는 안 된다.\n\n## 무엇을\n- 알고리즘\n- CS\n\n## 언제\n\n### CS\n#### 학기 중\n- 평일 하루 2시간 -> 프로젝트 시작하고 정해보기\n- 일요일 2-6시\n\n#### 방학\n- 화 목 2시간씩 (오후 7-9시)\n- 일요일 2-6시\n\n###  알고리즘\n- 월수금에 알고리즘 풀이 (2-4시)\n- 일주일에 총 2문제\n\n## 어떻게\n\n### CS\n- 책으로 공부하기 -> 아마도 공룡책?\n\n### 알고리즘\n- 과외 진도를 따라가면서 관련 문제 풀이\n- 모르는 문제 유형 정리\n\n# matzip 피쳐 개발\n\n하고 싶은 것: matzip 서버 CD & 무중단 배포"},{"excerpt":"공부한 것 목록 transactional bean bean-scope bean-candidate interceptor ioc-container-and-di filter 질문 목록 이번 미션에서 사용자 인증을 ArgumentResolver에서 수행했는지, Interceptor를 사용했는지: 미션에서는 ArgumentResolver에서 수행했다. 그러나 나중…","fields":{"slug":"/level2-level-log/"},"frontmatter":{"date":"2023년 06월 04일 05:06","title":"레벨2 레벨로그","tags":["우테코","레벨2","레벨로그"]},"rawMarkdownBody":"## 공부한 것 목록\n- [[transactional]]\n- [[bean]]\n- [[bean-scope]]\n- [[bean-candidate]]\n- [[interceptor]]\n- [[ioc-container-and-di]]\n- [[filter]]\n\n## 질문 목록\n- **이번 미션에서 사용자 인증을 ArgumentResolver에서 수행했는지, Interceptor를 사용했는지**: 미션에서는 ArgumentResolver에서 수행했다. 그러나 나중에는 Interceptor에서 인증 로직을 수행할 것 같습니다.\n\t- **이유?** \n\t- ArgumentResolver의 경우: **ArgumentResolver는 단순하게 값을 받아서 객체로 만드는 역할만 수행해야 한다는 의견도 있는데, 이런 경우는 어떻게 생각하시나요?**\n\t- Interceptor의 경우: **Interceptor에서는 true, false만 리턴할 수 있고 Request 조작만 가능하기 때문에 한 번에 객체를 만들어 주기 위해서는 ArgumentResolver가 더 낫다는 의견도 있었는데 어떻게 생각하시나요?**\n- **DI의 장점과 단점에 대해 설명해주세요.**\n\t- 장점: 클래스 사이의 결합도를 낮추어서 테스트하기 용이하고 리팩토링이 쉽다. 구현체가 변경되는 상황에서 \n\t- 단점: 의존성 주입이 여기저기에 흩어져 있으면 연관 관계를 파악하기 어려울 수 있다는 단점. 따라서 작은 프로젝트에서는 의존성 주입을 사용하지 않아도 되지 않을까 싶다.\n- **`@Transactional(readOnly = true)` 를 사용해 보신 적 있나요?**\n\t- **왜 쓰셨죠?** : 동료 개발자의 가독성 측면, CUD에 사용하는 경우에 예외 처리를 위해 사용했다.\n\t- **아예 안 쓰는 것과 어떤 차이가 있나요? 가독성 제외하고** : DB가 Read lock을 지원하는 경우에는 데이터 스냅샷으로만 조회를 해오기 때문에 데이터 일관성이 유지되고, mysql의 경우 transaction id를 부여하지 않기 때문에 오버헤드가 사라진다는 장점이 있습니다.\n- **bean scope에 대해 설명해주세요.**\n\t- **singleton bean 내부에서 prototype bean을 참조하는 경우 발생하는 문제와 해결 방법**\n- **java bean에 대해 설명해주세요.**\n\t- 특정 형태를 만족하는 클래스를 의미한다. 디폴트 생성자가 있고, 모든 필드는 private으로 getter, setter가 있어야 한다.\n- **bean 등록 시에 `@Configuration` 과 `@Component` 설정 방식을 정하는 기준이 있는지?**\n\t- 외부 라이브러리를 사용하거나 특정 의존성을 주입해주어야 할 때는 `@Configuration` 을 사용하고, 그 외의 일반 bean 설정은 `@Component` 를 사용한다.\n- **bean lifecycle이란?** : bean이 생성되고 소멸되는 주기를 의미한다. 스프링 컨테이너가 생성되고, bean이 생성된 후, 의존관계가 주입된다. 그 후 초기화 콜백이 실행되고, bean이 사용된다. 이후 bean의 소멸 콜백이 호출되고, 스프링 컨테이너가 종료되는 방식의 라이프 사이클을 갖는다.\n- **의존 관계 주입 방법 세 가지와 어떤 것이 왜 좋은지?**\n- **컨트롤러 단위 테스트와 서비스 단위 테스트 작성 하시는지? 그 이유?** : 컨트롤러 단위 테스트는 진행하지 않고, 서비스 단위 테스트는 진행하는 편입니다. \n\t- **컨트롤러 단위 테스트 / 서비스 단위 테스트에서는 어떤 어노테이션을 사용하시는지?**\n\t- **컨트롤러 단위 테스트를 했는데 통합 테스트도 써야 할까요?**\n- **같은 타입의 bean이 여러 개 존재한다면 어떤 문제가 발생하나요?**\n\t- **해당 문제를 해결하는 방법**\n- **repository와 dao 분리하셨는지**\n\t- 분리했다면 어떤 이유로\n\t- 분리하지 않았다면 분리한 것에 비해 어떤 장점이 있었는지\n- **domain과 entity 분리했는지**\n- **repository 는 도메인 레이어인가, 영속성 레이어인가? 그렇게 생각하는 이유는?**\n- **쿼리를 여러 번 날리는 것과 조인을 여러 번 하는 것 중 어떤 것을 선호하는가? 이유는?**\n\t- **반대 방법의 장점은 어떤 것이 있을까요?**\n- **Spring 컨테이너에게 객체의 라이프 사이클을 맡기는 것의 장단점?**\n\t- 객체의 생성부터 소멸까지 Spring이 관리하게 함으로써 개발자가 비즈니스 부분에만 집중할 수 있다는 장점이 있다.\n\t- 상태를 갖는 객체의 경우에는 bean으로 등록하지 않는다고 했을 때: 상태를 가져도 bean으로 만들 수 있다면 bean으로 만드실 건가요? 실제로 prototype 빈은 싱글톤이 아니고 조회할 때마다 새로 생성되는 빈이라 상태를 가질 수 있습니다.\n- **mocking과 stubing의 차이점? 왜 쓰는지?**\n\t- **테스트 더블 중에서 어떤 것을 더 선호하는지? (상황별)**\n- **협업 미션에서 프론트엔드로 필요하지 않은 정보도 모두 내려주는 것 vs 필요한 정보만 선별해서 내려주는 것 중 어떤 것이 좋다고 생각하시나요?**\n- **숨겨야 하는 애플리케이션 속성은 어떻게 처리하셨나요? 서브 모듈 / external properties 도 있는데 어떤 장점 때문에 그 방법을 선택하셨는지**\n- **FK 는 필요할까요? 이유**\n\t- 결국은 필요하다고 생각한다. \n- **테이블 사이에 FK 가 걸려있어도 값을 검증해야 할까요?**\n\t- 해야 한다. 도메인 로직에서 값을 검증하는 부분이 보이지 않는다. 또한 DB의 예외가 위쪽 계층으로 침범한다고 생각해서 값을 미리 Repository 단에서 검증하는 것이 좋다고 생각한다.\n\t- 할 필요 없다: **FK가 걸려 있으면 존재하지 않는 데이터를 FK로 해서 DB에서 쿼리를 보낼 때 예외가 발생한다. 그래도 해야 하나?**\n\t- 할 필요가 있다: **계속 동일한 코드가 중복해서 들어가게 되어서 가독성 측면에서는 좋지 않은 것 같은데, 그 부분은 어떻게 생각하시나요?** -> 그 부분이 트레이드 오프라고 생각한다. 계속해서 동일한 로직이 실행되고 있지만, 꼭 필요한 로직이라면 중복해서 들어가 있어도 괜찮다고 생각한다.\n- **도메인에 ID가 있어도 될까요?**\n\t- 있으면 안 된다: 객체 내부의 필드 값을 모두 비교해야 같은 데이터가 될 수 있는 도메인이 있다고 했을 때, 아이디로 식별하게 되면 훨씬 동등성을 비교하기 쉬울 수 있다는 의견에 대해서는 어떻게 생각하시나요?\n\t- 있어도 된다: 어떤 이점이 있었는가?\n- **클라이언트에서 조회하고 싶은 id를 전송했는데, 서버에서 해당 id에 맞는 데이터가 없다고 가정할 때 어떤 HttpStatus 코드를 내려주시나요? 이유는?**\n\t- 404 코드를 내려주었다. 404 자체가 리소스가 존재하지 않는다는 의미이기 때문에, 서버에서 해당 자원을 찾을 수 없다는 식으로 해석했다. \n\t- 해당 id가 포맷에 맞기 때문에 (id=4인 경우 포맷은 맞으나 서버 내부에서 못 찾는 것) 서버로 전달이 된 것이라고 생각해서 401은 적합하지 않다고 생각했다.\n- **interceptor와 argumentresolver의 패키지 위치는 어디가 적합하다고 생각하시는지?**\n- **httpstatus 403과 401의 차이점이 뭐라고 생각하시나요?**\n\t- **403을 사용해보신 적 있으신지, 왜 사용하셨는지?**\n- **truncate.sql 사용하시나요?**\n\t- 사용하신다면: **DROP을 선호하시는지, TRUNCATE를 선호하시는지?**\n\t- **테스트 격리를 위해 어떤 방법을 사용하시나요?**\n\n### 주디 피드백\n- FK를 사용하면 어떤 부분에서 무결성이 보장되는가?\n- FK를 사용하지 않는다면 무결성은 어떻게 최대한 지킬 수 있을까요?\n\n#### 학습 측면\n- 많이 고민해보신 것 같은 부분이 좋았습니다. 적절한 학습 예시와 함께 말해주신 점이 좋았습니다.\n\n#### 말하기 측면\n- 눈을 마주치면서 답변하고, 제스처를 적절하게 사용하여 답변에 좀 더 몰입할 수 있었습니다.\n- 말의 속도가 차분하고 목소리도 떨리지 않아서 좋았습니다.\n- 경험을 말하다보니 조금 장황해지는 경향이 있는 것 같습니다.\n- 결론과 이전의 답변이 조금은 상반된 경우가 있는 것 같습니다.\n\n### 코코닥 피드백\n\n#### 학습 측면\n- 주장에 대한 반대 의견도 함께 이야기 해주는 것이 좋았습니다. 깊게 공부해본 것 같은 느낌을 주었습니다.\n- 주장에 대한 자기 주관이 드러나는 것이 좋았습니다.\n- 주장과 근거가 함께 주어지고, 제공되는 근거가 신뢰도 있었습니다.\n\n#### 말하기 측면\n- 안정감을 주는 목소리로 차분하게 말해서 좋았습니다.\n- 손을 만지거나 다른 쪽을 바라볼 때가 있어서 그 부분은 신경써주시면 좋을 것 같다.\n\n### 제이미 피드백\n\n#### 학습 측면\n- 답변에서 필요한 답변을 하면서도 답변과 연결되는 개념을 함께 말해주어서 제이미가 많이 공부했다는 느낌이 들었습니다.\n- 미션에서 느꼈던 점, 왜 그렇게 했는지를 미션과 연관지어 이야기해 주신 부분이 좋았습니다.\n- 이전 질문에서 답변이 이어지는 느낌이 좋았습니다.\n\n#### 말하기 측면\n- 이해가 안 되는 부분은 다시 한 번 물어보는 부분이 좋았습니다.\n- 어떤 질문을 해도 되게 쉽게 답변해 주셔서 대단했습니다.\n- 조금 말의 호흡이 길게 느껴지는 부분이 있었습니다. 중간에 말을 끊어주고 말하면 문장의 핵심을 더 잘 파악할 수 있을 것 같습니다.\n- 답변에서 비슷한 의미의 말이 반복되는 느낌이 들었습니다.\n\n### 무민 피드백\n- DI에 대한 내용\n- interceptor, filter?\n\n#### 학습 측면\n- 해결 방법에 대한 경험, 경험에서의 고민이 답변에서 드러나서 좋았습니다.\n- 주장에 대한 근거가 주관으로 드러나서 좋았습니다. \n\n#### 말하기 측면\n- 답변하기 어려운 질문에도 천천히 잘 답변했습니다.\n- 질문에 관한 답변이 아닌 다른 답변을 할 때가 있어서 조금 아쉬웠습니다.\n- 생각할 때는 무의식적으로 하늘을 보는 습관이 있는 것 같습니다. 시선 처리를 좀 더 신경 써주시면 답변에 집중하고 있다고 보일 거 같습니다."},{"excerpt":"LOG 날씨가 매우 좋았는데, 동시에 더웠다... 집에서 에어컨 틀고 누워있으니 기분이 진짜 좋았다. 오랜만에 집에서 김치찌개 해먹었는데 역시 맛있었다. 미루던 집안일도 해결한 오늘의 점수 :100: 배운 것 헤나가 말하기를 sql 버전에 따라 alias 문제가 발생할 수 있다고 한다. 궁금했던 bad sql grammar 문제가 대충 해결 된 것 같다.…","fields":{"slug":"/2023-06-03/"},"frontmatter":{"date":"2023년 06월 03일 14:06","title":"2023년 06월 03일","tags":null},"rawMarkdownBody":"## LOG\n- 날씨가 매우 좋았는데, 동시에 더웠다... 집에서 에어컨 틀고 누워있으니 기분이 진짜 좋았다. 오랜만에 집에서 김치찌개 해먹었는데 역시 맛있었다. 미루던 집안일도 해결한 오늘의 점수 :100:\n\n## 배운 것\n- 헤나가 말하기를 sql 버전에 따라 alias 문제가 발생할 수 있다고 한다. 궁금했던 bad sql grammar 문제가 대충 해결 된 것 같다...\n- swagger의 springfox와 springdoc 중에서 springdoc이 최근에 활발하게 업데이트도 되고 있고, 좀 더 사용하기 쉽다고 한다.\n- DB 유저의 비밀번호를 설정해두지 않아서 (근데 왜 안 돼 있지 ㅋㅋㅋ) 접근 에러가 떴었다. by 다즐\n- webflux는 논블록킹 \n\n## 궁금한 것\n\n## 느낀 것\n- 방학 때 무엇을 위해 공부해야 할까? 취업일까, 아니면 공부일까. CS, 알고리즘, 네트워크, 해야 할 건 많은데 시간은 한정되어 있다. 더 이상 늦기 전에 목표를 세워보는 게 좋을 것 같다.\n- 뭐든 할 때 컨텍스트 스위칭이 잦다. 방금 TIL 쓰다가도 PR 보러 갔다가 슬랙 봤다가 갑자기 계획 고민하다가 카톡 보다가 matzip 코드 봤다가 난리도 아니네 ㅋㅋㅋㅋ....... 좀 하나에 집중할 수 있는 방법은 없을까... 항상 양털 깎다가 진짜 뭐하고 있었는지 까먹는다.\n"},{"excerpt":"LOG 드디어 기능을 다 구현했다. 이제 배포만 하면 됐는데 어째서인지 아직도 mysql 이 연동이 안 돼서 해결을 못했다... 그런 줄 알았는데 즐선생님이 해결해주셨다 🙇‍♀️ 이유는 내일 듣기로 했으니 매우 궁금한 상태로 내일을 기다려 보자 길을 걷다가 커다란 바퀴벌레를 만났지만 놀라서 그런지 다행히도 밟지 않았다 ... 나에게도 그 친구에게도 다행인 일이…","fields":{"slug":"/2023-06-01/"},"frontmatter":{"date":"2023년 06월 01일 04:06","title":"2023년 06월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 드디어 기능을 다 구현했다. 이제 배포만 하면 됐는데 어째서인지 아직도 mysql 이 연동이 안 돼서 해결을 못했다... 그런 줄 알았는데 즐선생님이 해결해주셨다 🙇‍♀️ 이유는 내일 듣기로 했으니 매우 궁금한 상태로 내일을 기다려 보자\n- 길을 걷다가 커다란 바퀴벌레를 만났지만 놀라서 그런지 다행히도 밟지 않았다 ... 나에게도 그 친구에게도 다행인 일이다.\n- 내일은 선릉으로 이동해서 도밥, 아이크와 점심을 먹고 잠시 회의를 하다 회고를 할 예정이다. 선릉에 주말에만 가봤는데 평소의 선릉은 어떨지 좀 궁금하긴 하다.\n\n## 배운 것\n- table을 삭제할 때는 `DROP TABLE 테이블_이름` 을 쓴다.\n- `GRANT ALL PRIVILEGES ON *.* TO '유저이름'@'유저호스트주소' WITH GRANT OPTION`\n\t- 모든 데이터베이스의 권한을 부여하고, 다른 유저에게 권한을 수여할 수 있는 권한도 제공한다.\n- user를 삭제할 때에는 `DROP user '유저이름'@'유저호스트'` 를 사용한다.\n- user를 생성할 때에는 `CREATE user '유저이름'@'유저호스트주소' IDENTIFIED BY '비밀번호'` 를 사용한다.\n- 권한을 변경하고 나서는 `FLUSH PRIVILEGES` 로 변경 사항을 반영한다.\n- user의 권한을 확인할 때에는 `SHOW GRANTS FOR 유저이름@유저호스트` 를 사용한다.\n- `UPDATE user SET plugin='mysql_native_password' WHERE user='유저이름' and host='유저호스트주소'`\n\t- user의 plugin을 mysql_native_password로 변경한다.\n\n## 궁금한 것\n- root인데도 권한을 줄 수 없는 문제가 있었다. 왜일까?\n```shell\nERROR 1410 (42000): You are not allowed to create a user with GRANT\n```\n\n인터넷에서는 'root'@'%' 로 유저를 생성하고 다시 시도해 보라고 했는데, 나는 그것도 안 됐다... 뭘까\n\n## 느낀 것\n- 요즘 너무 더워서 바깥에 있을 때는 확실하게 생산성이 저하된다. 가끔 잠실 캠 바깥으로 안 나가고 싶다는 생각도 한다 ㅋㅋㅋ 온도.. 습도.... 완벽해\n- 도밥과 아이크가 궁금한 부분이나 잘 이해가 안 되는 부분이 슬랙을 하면서 느껴질 때 바로 허들/줌 요청하는 게 좋았다. 확실히 글로 전달하는 것보다는 말로 설명하는 게 더 좋은데, 말로 하면 내 비언어적 표현도 전달 되어서 그렇다. 내 의도도 잘 전해지고, 의미도 명확하다. 명확한 요청과 피드백이 확실히 중요하구나."},{"excerpt":"2023-06-01 2023-06-03 2023-06-06 2023-06-07 2023-06-26 2023-06-28 2023-06-30","fields":{"slug":"/2023-06/"},"frontmatter":{"date":"2023년 06월 01일 04:06","title":"2023년 06월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-06-01]]\n- [[2023-06-03]]\n- [[2023-06-06]]\n- [[2023-06-07]]\n- [[2023-06-26]]\n- [[2023-06-28]]\n- [[2023-06-30]]\n"},{"excerpt":"LOG 오늘은 포이와 토리가 선릉에 가고 망고도 프론트엔드 분들이랑 같이 먹는다고 해서 레벨3 망토포 없이 혼자 떨어진 베로 체험했다... ㅋㅋㅋㅋ 점심은 헙크 다즐이랑 먹었는데 갑자기 나온 MBTI 질문이 재밌었다. 갑자기 궁금한데 F들은 '오늘 힘들다' 라는 말을 들었을 때 '뭐가 힘들어?' 라는 말이 안 나오는건가...? 어째서 상대방이 뭐가 힘든지…","fields":{"slug":"/2023-05-30/"},"frontmatter":{"date":"2023년 05월 30일 15:05","title":"2023년 05월 30일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘은 포이와 토리가 선릉에 가고 망고도 프론트엔드 분들이랑 같이 먹는다고 해서 레벨3 망토포 없이 혼자 떨어진 베로 체험했다... ㅋㅋㅋㅋ 점심은 헙크 다즐이랑 먹었는데 갑자기 나온 MBTI 질문이 재밌었다. 갑자기 궁금한데 F들은 '오늘 힘들다' 라는 말을 들었을 때 '뭐가 힘들어?' 라는 말이 안 나오는건가...? 어째서 상대방이 뭐가 힘든지가 궁금하지 않은거야 서운하네요\n- 오찌, 주드와 페어 프로그래밍 했다. Jpa 사용해서 사용자가 단 리뷰에 지금까지 사용자가 달아온 리뷰 개수를 표시해주는 기능을 추가했다. 원래는 두 가지 구현하려고 했는데 구현한 기능이 머지되어야 추가할 수 있는 기능이라 오찌가 JPA 온보딩을 마저 진행해주셨다. 대충 알고 있던 N+1 문제에 대해 좀 더 자세히 알 수 있는 기회였다.\n- 오랜만에 노래방에 갔다 왔다. 그렇게 잘 불러지는 날은 아니었지만 신나는 노래를 부르니까 기분이 정말 좋았다. 요즘 루시 노래를 많이 듣는데 노래 부르니까 더 좋았다.\n\n## 배운 것\n- 오늘은 오찌, 주드와 페어를 했다 -> [[ohzzi-05-30|5월 30일 오찌와 페어]]\n\n## 궁금한 것\n\n## 느낀 것\n- 요즘 계속 반복되는 코드를 쓰다 보니 좀 귀찮은 때가 있는 것 같다. 오늘도 의욕이 별로 생기지 않아서 누누, 필립, 주노랑 이야기 했다. 남이 어떻게 코드 짰는지가 좀 더 궁금하다.\n- 오늘 생각해낸 아이디어 꽤나 괜찮아서 만약 주제 선택 안 되더라도 사이드 프로젝트로 진행해보고 싶은 주제다. \n![[service_proposal.png]]"},{"excerpt":"registerEvent() 이벤트를 발행한다 -> eventListener가 이벤트를 받아서 동작을 수행한다. 왜 이벤트를 썼는가? 락 관련해서 문제가 생길 수 있다. 관계 설명  은 다대일 관계를 나타낸다.\n즉, 리뷰가 N개고 멤버가 1개이다. 양방향으로 작성해줄 수도 있다. -> 양방향으로 작성하는 것이 필요한가? (상황에 따라 다르다. by 오찌)…","fields":{"slug":"/ohzzi-05-30/"},"frontmatter":{"date":"2023년 05월 30일 11:05","title":"5월 30일 오찌와 페어","tags":["matzip","페어"]},"rawMarkdownBody":"\n## `@Query`\n\n```java\n@Query(\n\tvalue = \"select count(r) from Review r where (r.member = :member)\"\n)\nLong countByMember(Member member) {\n\t\n}\n```\n\n## registerEvent()\n\n이벤트를 발행한다 -> eventListener가 이벤트를 받아서 동작을 수행한다.\n\n왜 이벤트를 썼는가? 락 관련해서 문제가 생길 수 있다.\n\n## 관계 설명\n\n`@ManyToOne` 은 다대일 관계를 나타낸다.\n즉, 리뷰가 N개고 멤버가 1개이다. \n\n양방향으로 작성해줄 수도 있다. -> 양방향으로 작성하는 것이 필요한가? (상황에 따라 다르다. by 오찌)\n\n양방향은 설정을 안 하면 기본적으로 LAZY로 설정된다 -> 쿼리가 엄청나게 많이 터진다.\nex. 10개의 리뷰 조회할 때 LAZY로 설정해두면 나중에 member를 get할 때 멤버 조회 쿼리가 10번 더 나간다. -> N+1 문제 발생 -> fetch join을 쓰거나 EntityGraph를 쓰자.\n\n확실하게 연관 관계를 사용하는 경우에는 FETCH를 사용하면 좋다.\n\n## Fetch\n\n`fetch = FetchType.LAZY` 로 작성하면 실제로 해당 객체를 가져올 때에는 연관관계를 갖는 객체가 들어있지 않고 가짜객체 (proxy) 가 존재한다. \n\n```java\n@JoinColumn(name = \"member_id\", nullable = false)\n@ManyToOne(fetch = FetchType.LAZY)\nprivate Member member;  // 가짜 객체가 존재.\n```\n\n```sql\nselect * from review r where id = 1;\nselect * from member m where m.id = r.member_id;\n```\n\nmember에 대한 접근이 생길 때만 실제로 쿼리를 가져온다.\n\n만약 review가 필요한데, member는 필요하지 않은 경우에는 낭비가 될 수 있다.\n또한 member 테이블 자체가 크면 조인할 때 비용이 많이 든다.\n\n> **LAZY를 기본으로 두고, 필요한 경우만 EAGER로 쓰는 것 추천**"},{"excerpt":"Spring Data JPA Entity 생성하기 보통은 도메인과 엔티티를 일치시키는 편이다.  어노테이션을 사용하여 도메인 객체를 엔티티로 만든다. 영속성 컨텍스트 엔티티를 영구히 저장할 수 있는 환경.\n 를 통해 관리되는데, 우리는 Spring Data JPA 를 사용하므로 를 직접 사용할 필요는 없고,  구현체 내부에서 자동으로 사용된다. 1차 캐시…","fields":{"slug":"/matzip-jpa/"},"frontmatter":{"date":"2023년 05월 30일 10:05","title":"matzip JPA","tags":["matzip","jpa"]},"rawMarkdownBody":"\n## Spring Data JPA\n\n```java\n// 그냥 JPA만 쓸 경우\npublic class MemberRepository {\n    @PersistenceContext\n    private final EntityManager em;\n\n    // 생성자\n    ...\n\n    public Member save(Member member) {\n        em.persist(member);\n    }\n}\n\n// Spring Data Jpa\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n    Member save(Member member);\n}\n```\n\n## Entity 생성하기\n\n보통은 도메인과 엔티티를 일치시키는 편이다.\n\n`@Entity` 어노테이션을 사용하여 도메인 객체를 엔티티로 만든다.\n\n\n## 영속성 컨텍스트\n\n엔티티를 영구히 저장할 수 있는 환경.\n`EntityManager` 를 통해 관리되는데, 우리는 Spring Data JPA 를 사용하므로 `EntityManager`를 직접 사용할 필요는 없고, `JpaRepository` 구현체 내부에서 자동으로 사용된다.\n\n### 1차 캐시\n`JpaRepository` 를 통해 엔티티를 `save` 하면 영속성 컨텍스트에 엔티티가 담기게 된다.\n엔티티를 조회할 때 영속성 컨텍스트를 통해 꺼내오게 되는데, 이때 객체의 `동일성` 을 보장해줄 수 있다.\n\n```java\nLong id = memberRepository.save(오찌).getId();\n\nMember 오찌1 = memberRepository.findById(id).get();\nMember 오찌2 = memberRepository.findById(id).get();\n\n오찌1 == 오찌2\n```\n\n영속성 컨텍스트는 조회 시 영속성 컨텍스트에 있는 데이터를 반환해주기 때문에 다른 변수에 담겨있지만 '주소값' 까지 동일한 객체이다.\n\n영속성 컨텍스트는 기본적으로 트랜잭션 범위에서 작동한다. 즉, 다른 트랜잭션에서 조회하게 되면 다른 객체가 된다.\n\n## JpaRepository\n\nsave, findById, findAll, delete, deleteById 메서드들을 기본으로 제공한다."},{"excerpt":"LOG 팀호완에서 인생 첫 딤섬을 먹었다. 맛있었는데 양이 많았다. 완탕 비빔면, 무슨바오?, 히가우, 또 뭐야 부채교 (데친 시금치와 새우가.. we were together~) 를 먹었다. 그 중에서는 무슨바오가 제일 맛있었던 거 같다. 북 앤 레스트에 가서 공부했다. 12시 반에 가서 7시 40분에 나왔는데 욕창 생길 거 같았다 ㅋㅋㅋㅋㅋ 역시 욕창…","fields":{"slug":"/2023-05-29/"},"frontmatter":{"date":"2023년 05월 29일 13:05","title":"2023년 05월 29일","tags":null},"rawMarkdownBody":"\n## LOG\n- 팀호완에서 인생 첫 딤섬을 먹었다. 맛있었는데 양이 많았다. 완탕 비빔면, 무슨바오?, 히가우, 또 뭐야 부채교 (데친 시금치와 새우가.. we were together~) 를 먹었다. 그 중에서는 무슨바오가 제일 맛있었던 거 같다. \n- 북 앤 레스트에 가서 공부했다. 12시 반에 가서 7시 40분에 나왔는데 욕창 생길 거 같았다 ㅋㅋㅋㅋㅋ 역시 욕창이 생기지 않으려면 뒤집기를 잘해야 한다. 신생아를 본받자 응애 ‼️ 리팩토링 좀 하다가 오늘따라 너무 재미없어서 회고 댓글도 쓰고 글도 좀 썼다. 굉장히 생산적인 하루였다. (요즘 굉장히라는 말을 굉장히 많이 쓴다.)\n- 순살치킨 떡볶이 + 오징어 튀김을 먹었다. 진짜 오랜만에 떡볶이를 먹었는데 맛있었다~ \n\n## 배운 것\n- bean에 대해 공부했다 + bean definition -> [[bean|Spring Bean]]\n\n## 궁금한 것\n- bad sql grammar 문제는 아직 해결되지 않았다... 리만 가설과 bad sql grammar 문제, 과연 어떤 문제가 명쾌한 해답으로 신속하게 해결될 수 있을지 기대 만발.\n\n## 느낀 것\n- 말하고 싶은 게 많은데 여백이 너무 좁아 여기에 쓰지 않는다. "},{"excerpt":"트랜잭션이란 DBMS에서 수행되는 논리적인 작업의 단위를 말한다.\n하나 이상의 데이터베이스 조작 (INSERT, UPDATE, DELETE 등)을 묶어 하나의 작업으로 처리한다. 트랜잭션의 특성 (ACID) 원자성: 트랜잭션의 모든 연산은 하나의 원자적 작업 단위로 간주된다. 모든 연산이 성공적으로 수행되면 트랜잭션은 커밋되어 영구적으로 적용되고, 하나라…","fields":{"slug":"/transactional/"},"frontmatter":{"date":"2023년 05월 29일 10:05","title":"Transactional","tags":["spring"]},"rawMarkdownBody":"\n## 트랜잭션이란\n\nDBMS에서 수행되는 논리적인 작업의 단위를 말한다. \n하나 이상의 데이터베이스 조작 (INSERT, UPDATE, DELETE 등)을 묶어 하나의 작업으로 처리한다.\n\n### 트랜잭션의 특성 (ACID)\n\n1. 원자성: 트랜잭션의 모든 연산은 하나의 원자적 작업 단위로 간주된다. 모든 연산이 성공적으로 수행되면 트랜잭션은 커밋되어 영구적으로 적용되고, 하나라도 실패하면 트랜잭션은 롤백되어 이전 상태로 복원된다. -> 트랜잭션의 연산은 전부 수행되거나 전혀 수행되지 않아야 한다.\n2. 일관성: 트랜잭션이 수행되기 전, 후의 데이터베이스 상태는 일관된 상태를 유지해야 한다. 즉, 데이터베이스에 저장된 데이터의 제약 조건, 규칙, 관계 등이 모두 만족되어야 한다. 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안 된다.\n3. 격리성: 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다. 각 트랜잭션은 시스템 내에서 독립적으로 실행되는 것처럼 보여야 한다.\n4. 지속성: 트랜잭션이 커밋된 후에는 해당 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장되어야 한다. 시스템 장애나 복구 작업 같은 예외 상황이 발생하더라도 트랜잭션이 커밋되었으면 결과는 영구적으로 보존되어야 한다.\n\n### 트랜잭션의 과정\n\n1. 트랜잭션 시작: 트랜잭션을 시작할 수 있는 레벨을 설정하고, 해당 레벨에서 동작하는 새로운 트랜잭션을 시작한다.\n2. 데이터베이스 조작: 새로 생성된 트랜잭션 내에서 데이터 조회, 입력, 수정, 삭제 등의 조작을 수행한다.\n3. 데이터 검증: 데이터 조작이 모두 성공적으로 처리되었다면, COMMIT을 수행한다. 그러나 데이터 조작 오류가 발생하면 ROLLBACK 명령을 실행하여 이전 상태로 되돌린다.\n4. 트랜잭션 종료: 트랜잭션을 완료하고, 해당 레벨의 트랜잭션을 종료한다. \n\n### 트랜잭션 레벨\n\n동시에 실행중인 여러 트랜잭션 간의 데이터 일관성과 격리 수준을 조절하는데 사용된다.\n\n### 트랜잭션 격리 수준\n\n#### Read Uncommitted (레벨 0)\n- 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.\n- SELECT 문장이 수행되는 동안 해당 데이터에 shared lock이 걸리지 않는다.\n- 데이터 부정합 문제가 발생할 확률이 높으나, 성능은 가장 빠르다.\n- DirtyRead, Non-Repeatable Read, Phantom Read 현상이 발생한다.\n- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많다. MySQL을 사용한다면 Read Committed 이상의 격리 수준을 사용하자.\n\n#### Read Committed (레벨 1)\n- 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용한다. \n- SELECT 문장이 수행되는 동안 해당 데이터에 shared lock이 걸린다. 따라서 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없고, 대기한다. 즉, data 10을 50으로 변경하는 동안 다른 사용자는 바뀐 데이터에 접근할 수 없다. (data 50에 접근할 수 없다.)\n- 실제 테이블 값을 가져오는 것이 아닌, Undo 영역에 백업된 레코드에서 값을 가져온다. Undo 영역은 트랜잭션의 롤백 대비를 위해, 트랜잭션의 격리 수준을 유지하며 높은 동시성을 제공하기 위해 사용된다.\n![[transacion-read-committed.png]]\n- Non-Repeatable Read, Phantom Read 문제가 발생한다.\n- 일반적인 웹 애플리케이션에서는 크게 문제가 되지 않지만, 입출금 같은 금전과 관련이 된다면 문제가 될 수 있다. \n\n#### Repeatable Read (레벨 2)\n- 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 같음을 보장한다. Undo 영역에 백업된 이전 데이터를 사용한다.\n- 실행되는 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 undo 영역의 데이터는 삭제할 수 없다.\n- 즉, 10번 트랜잭션에서 실행되는 모든 SELECT 쿼리는 10번보다 작은 트랜잭션 번호에서 변경한 내용만 보게 된다. 10번 트랜잭션이 실행되는 도중에 12번 트랜잭션이 UPDATE 쿼리를 수행해도 12번 트랜잭션의 변경 사항은 10번 트랜잭션 SELECT 쿼리에 영향을 줄 수 없다.\n- 하나의 레코드에 대해 백업이 하나 이상 존재할 수 있다. 따라서 한 사용자가 트랜잭션을 시작한 후 장기간 트랜잭션을 종료하지 않는 경우에는 Undo 영역이 계속해서 확장되고, 백업 레코드가 많아질수록 MySQL 서버의 처리 성능이 떨어질 수 있다.\n- Phantom Read 문제가 발생한다. (그러나 MySQL InnoDB는 MVCC 다중 버전 제어를 통해 Phantom Read 문제를 해결한다.)\n\n#### Serializable (레벨 3)\n- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 접근할 수 없다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.\n- 동시 처리 성능이 다른 트랜잭션 격리 수준에 비해 현저히 떨어진다.\n- `SERIALIZABLE` 격리 수준에서 \n\n#### MySQL InnoDB가 Phantom Read를 해결하는 방법 - MVCC 다중 버전 제어\n\nMVCC(Multi Version Concurrency Control) -> 잠금을 사용하지 않는 일관된 읽기를 제공한다.\n동시성 제어를 위한 기술로, 여러 개의 버전을 생성하여 트랜잭션간 충돌을 방지한다.\n\n각각의 트랜잭션은 일련번호를 할당받고, 트랜잭션의 시작 지점이 빠른 트랜잭션은 숫자가 작다.\n데이터베이스의 각 레코드는 변경 이력을 추적하기 위해 여러 버전으로 관리되는데, 이때 해당 레코드를 변경한 트랜잭션의 일련번호가 함께 저장된다.\n\n트랜잭션의 시작 시점에 따라서 해당 시점 이전에 커밋된 트랜잭션들의 변경 내역만을 볼 수 있도록 설정된다. \n즉, 10번 트랜잭션의 경우 10보다 작은 일련 번호를 갖는 트랜잭션이 변경한 내역들만 볼 수 있다. \n다른 트랜잭션이 트랜잭션 실행 중에 데이터를 변경하더라도 실행 중인 트랜잭션은 변경 내용을 알 수 없다.\n\n##### 트랜잭션 ID 할당 시점\n\nMySQL 의 InnoDB 스토리지 엔진에서 DB_TRX_ID 는 특정 레코드를 마지막으로 수정한 트랜잭션 ID를 나타낸다.      \n\n**트랜잭션이 시작되는 즉시 트랜잭션 ID 를 부여받는 것은 아니다.** InnoDB 가 경합을 줄이고 동시성을 향상시키기 위해서 lazy 한 방식으로 동작하기 때문이다.     \n\n트랜잭션이 데이터를 수정하려고 시도할 때만 트랜잭션 ID 가 할당된다.       \n트랜잭션에 의해 행이 수정되면 해당 행의 DB_TRX_ID 필드에 트랜잭션 ID 가 저장된다. 해당 ID는 InnoDB가 마지막으로 수정한 트랜잭션을 추적하는 데 도움이 된다. \n\n트랜잭션이 종료되고 트랜잭션이 커밋되면 변경 사항이 디스크에 기록되고 이후 모든 트랜잭션에서 변경 사항을 볼 수 있다. 트랜잭션이 롤백되면 해당 트랜잭션에 의해 변경된 내용은 undo log의 정보를 사용하여 실행 취소된다.     \n\n트랜잭션 ID가 lazy 할당 되기 때문에 읽기 전용 트랜잭션이나 데이터베이스를 수정하지 않는 트랜잭션이 불필요하게 트랜잭션 ID를 사용하지 않도록 한다.     \n\n#### 예시\n\n1. 격리수준 serializable 트랜잭션 A가 먼저 시작된다. 이후 트랜잭션 B가 시작된다. 그 다음 트랜잭션 B가 table1 에 12를 insert 하고 commit 해서 트랜잭션 A보다 먼저 종료되었다. 이 경우, 트랜잭션 B가 트랜잭션 A보다 먼저 처리된 것으로 간주하여 A는 B의 반영사항을 그대로 읽을 수 있다.\n2. 격리수준 repeatable read 트랜잭션 A가 먼저 시작된다. 이후 트랜잭션 B가 시작된다. 그 다음 트랜잭션 B가 table1 에 12를 insert 하고 commit 해서 트랜잭션 A보다 먼저 종료되었다. 이 경우, 트랜잭션 A는 B가 반영한 정보(12)를 볼 수 없다. 이유는 undo 영역의 snapshot 을 사용하여 트랜잭션 A가 유지되는 기간 동안 동일한 데이터를 읽어오기 때문이다.\n\n### 트랜잭션 격리 수준에서 발생할 수 있는 문제점\n\n#### Dirty Read\n특정 트랜잭션에 의해 데이터가 변경되었으나, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 트랜잭션 내부에서 발생한 변경 사항을 조회할 수 있는 문제이다. \n\nA 트랜잭션에서 데이터를 변경하고 커밋하지 않은 시점에 B 트랜잭션이 변경된 데이터를 읽은 상황에서 A 트랜잭션이 롤백하게 되면 치명적일 수 있다. B 트랜잭션은 롤백으로 무효가 된 데이터를 가지고 처리를 진행하기 때문에 문제가 발생한다.\n\n#### Non-Repetable Read\n같은 트랜잭션 내에서 같은 데이터를 여러 번 조회했을 때 읽어온 데이터가 다른 경우를 의미한다.\n\n#### Phantom Read\nNon-Repeatable Read의 한 종류로, 조회해온 결과의 행이 새로 생기거나 없어지는 현상이다.\n\n**참고**\n- https://hudi.blog/transaction-isolation-level/\n- https://mysqldba.tistory.com/334\n- https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation\n\n### Lock\n\n## 선언적 트랜잭션이란\n\n트랜잭션의 동작을 명시적으로 정의하지 않고, 선언적인 방식으로 트랜잭션을 처리하는 개념이다. 주로 프레임워크나 라이브러리 수준에서 정의된다.\n\n개발자가 명시적으로 트랜잭션을 관리하는 대신, 프레임워크에게 책임을 위임하여 간단한 설정이나 어노테이션으로 트랜잭션을 선언하고 처리한다. \n\n## `@Transactional` 이란\n\nSpring의 선언적 트랜잭션 방식 중 하나이다. \n\n트랜잭션을 적용하고자 하는 클래스나 메서드 위에 `@Transactional` 을 선언하면 트랜잭션 기능이 적용된 프록시 객체가 생성되고, `@Transactional` 이 포함된 메서드가 호출되는 경우 `PlatformTransactionManager` 를 사용하여 트랜잭션을 시작한다.\n\n### propagation 옵션\n\n트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할 지 결정하는 것을 트랜잭션의 전파 설정이라고 한다.\n\n#### 물리 트랜잭션 vs 논리 트랜잭션\n\n1개의 트랜잭션을 사용한다는 것은 하나의 Connection 객체를 사용한다는 것이다. \n트랜잭션이 실제 데이터베이스의 트랜잭션을 사용한다는 점에서 **물리 트랜잭션**이라고 한다. \n커넥션을 통해 커밋/롤백하는 단위이다.\n\n전파 속성에 따라 외부 트랜잭션과 내부 트랜잭션이 동일한 트랜잭션을 사용할 수도 있다.\n스프링에서는 실제 데이터베이스 트랜잭션과 스프링이 처리하는 트랜잭션을 구분하기 위해 **논리 트랜잭션**이라는 개념이 등장했다.\n\n트랜잭션 전파 없이 1개의 트랜잭션만 사용되면 물리 트랜잭션만 존재하고, 트랜잭션 전파가 사용될 때 논리 트랜잭션 개념이 사용된다. \n\n#### 종류\n\n- `REQUIRED` : 기본값. 부모 트랜잭션이 존재하는 경우 참여하고, 존재하지 않는 경우 트랜잭션을 새롭게 생성한다.\n- `SUPPORTS` : 부모 트랜잭션이 존재하는 경우 참여하고, 없는 경우 non-transactional 상태로 실행한다.\n- `MANDATORY` : 부모 트랜잭션이 있으면 참여하고, 없는 경우 예외를 발생시킨다.\n- `REQUIRES_NEW`\n\t- 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션을 생성한다. \n\t- 부모/자식 트랜잭션의 롤백 여부는 서로 영향을 주지 않는다.\n\t- 내부 트랜잭션이 롤백되는 경우는 실제 Connection에 롤백을 호출하는 경우이므로 트랜잭션이 종료된다.\n\t- \n- `NOT_SUPPORTED` : non-transactional 상태로 실행하며, 부모 트랜잭션이 존재하는 경우 일시 정지 시킨다.\n- `NEVER` : non-transactional 상태로 실행하며, 부모 트랜잭션이 존재하는 경우 예외를 발생시킨다.\n- `NESTED`\n\t- 부모 트랜잭션과는 별개의 중첩된 트랜잭션을 만든다. \n\t- 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만, 자식 트랜잭션의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다. \n\t- 부모 트랜잭션이 없는 경우에는 새로운 트랜잭션을 생성한다.\n\n**참고**\n- https://hwannny.tistory.com/98\n\n### readOnly 옵션\n\n기본적으로는 false로 설정되어 있다.\n\n**true로 설정하는 경우**: 데이터에 대해 Lock을 적용할 필요가 없고, 접근할 수 있는 데이터(스냅샷, 튜플 등)가 변경되지 않기 때문에 일관적인 데이터를 읽어오고 제공할 수 있다.\n\n조회 작업만 수행한다는 것을 명시적으로 나타낼 수 있다.\n\n#### MySQL에서의 readOnly\n\nSELECT 문에 대해서만 기능을 지원하고, Transaction ID 설정에 대한 오버헤드를 해결할 수 있다. (MVCC) \n즉, Read Only 트랜잭션에 대해서는 Transaction ID가 부여되지 않는다.\n\n별도의 스냅샷을 통해 데이터를 조회하기 때문에 데이터 일관성을 보장할 수 있다. \n데이터 변경과 같이 조회가 아닌 작업을 하는 경우 에러를 발생시킨다.\n\n- 스냅샷 : 데이터 수정 요청이 전달되었을 때, 변경되는 데이터를 따로 저장해두는 것.\n\n### isolation 옵션\n\n- `DEFAULT`: 기본적으로 `DEFAULT` 옵션이 적용되어 있다. 사용하는 DB의 기본 격리 수준을 따른다.\n- `READ_UNCOMMITTED` : 커밋되지 않은 데이터를 다른 트랜잭션에서 접근 가능하다.\n- `READ_COMMITTED` : 매 조회가 이루어질 때마다 새로운 스냅샷을 뜨기 때문에 다른 트랜잭션이 커밋하면 (변경 사항이 존재하면) 변경된 데이터를 볼 수 있다. 즉, B 트랜잭션이 끝나기 전에 A 트랜잭션에 의해 데이터가 변경되면 다시 조회할 때 변경된 데이터를 읽게 된다.\n- `REPEATABLE__READ` : 조회한 데이터에 대해 Shared Lock이 걸려서 다른 트랜잭션이 새로운 데이터를 추가할 수 있다. A 트랜잭션이 시작하고 처음 조회한 데이터의 스냅샷을 저장하고, 이후에 동일한 쿼리를 호출하면 해당 스냅샷에서 데이터를 가져온다. 즉, B 트랜잭션이 새로 커밋해도 (변경 사항이 있어도) A 트랜잭션이 조회하는 데이터는 변하지 않는다.\n- `SERIALIZED` : 읽기 작업에도 락을 걸어 여러 트랜잭션이 동시에 같은 데이터에 접근할 수 없다. 가장 안전하지만 성능 저하가 크기 때문에 자주 사용되지 않는다.\n\n### ProxyMode\n\n프록시를 생성하는 방식을 제어하는데 사용되는 옵션이다. \n\n1. ProxyMode.DEFAULT\n\t- 스프링이 프록시 모드를 결정한다.\n\t- 인터페이스를 구현하고 있는 경우에는 ProxyMode.PROXY를, 구현하지 않는 경우에는 ProxyMode.TARGET_CLASS를 사용한다.\n2. ProxyMode.PROXY\n\t- JDK 기반의 다이나믹 프록시를 생성한다.\n\t- 대상 객체가 인터페이스를 구현하고 있어야 한다.\n\t- 대상 객체의 인터페이스 메서드 호출 시 프록시를 거쳐 AOP 동작을 호출한다.\n3. ProxyMode.ASPECTJ\n\t- AspectJ를 사용하여 프록시를 생성한다.\n\t- 인터페이스를 구현하고 있지 않아도 된다.\n\t- 컴파일 타임에 AspectJ \n\n**갑자기 무슨 인터페이스라는 말인가...**\n\n> 스프링 AOP에서 ProxyMode.PROXY를 사용하는 경우, 대상 객체는 인터페이스를 구현하고 있어야 합니다. 이는 JDK 다이나믹 프록시를 사용하여 프록시 객체를 생성하기 때문입니다. 다이나믹 프록시는 인터페이스의 구현을 바탕으로 프록시 객체를 생성하므로, 대상 객체가 인터페이스를 구현하지 않으면 프록시를 생성할 수 없습니다. **by G-선생**\n\n"},{"excerpt":"Java Bean? 스윙에서 독립적인 GUI 컴포넌트의 개발을 용이하게 하기 위해 고안되었다.\n특정 형태의 클래스를 가리키는 뜻으로 사용된다. 다음의 조건을 만족해야 한다.  을 구현하여 직렬화가 가능해야 한다. public 기본 생성자를 가져야 한다. getter, setter를 가져야 한다. 모든 필드는 private으로 getter, setter를 …","fields":{"slug":"/bean/"},"frontmatter":{"date":"2023년 05월 29일 09:05","title":"Spring Bean","tags":["spring","개발"]},"rawMarkdownBody":"\n## Java Bean?\n\n스윙에서 독립적인 GUI 컴포넌트의 개발을 용이하게 하기 위해 고안되었다.\n특정 형태의 클래스를 가리키는 뜻으로 사용된다.\n\n다음의 조건을 만족해야 한다.\n- `Serializable` 을 구현하여 직렬화가 가능해야 한다.\n- public 기본 생성자를 가져야 한다.\n- getter, setter를 가져야 한다.\n- 모든 필드는 private으로 getter, setter를 통해 접근 가능해야 한다.\n\n## Spring Bean?\n\nSpring Container가 관리하는 객체이다. \nSpring Application의 기본 구성 요소이자, 다른 bean과 함께 연결하여 애플리케이션의 기능을 생성할 수 있는 재사용 가능한 구성 요소이다.\n\nXML, Java 어노테이션, `@Configuration` 같은 설정 클래스를 통해 정의된다.\n\n## 관련 문서\n\n- [[bean-scope]]\n- [[bean-candidate]]\n- [[mock-vs-mockbean]]\n\n### Spring Container에게 객체 생성과 관리를 위임하는 것의 장단점\n\n#### 장점\n- 의존성 주입을 사용하여 객체 사이의 결합도를 낮춘다. (클래스 내부에서 클래스 의존 관계를 설정하는 것이 아니라 스프링 프레임워크에서 자동으로 주입해주므로)\n- 객체의 생성, 초기화, 소멸 작업을 스프링 컨테이너가 담당하여 개발자는 비즈니스 로직에 좀 더 집중할 수 있다. \n- 다양한 bean 스코프에 따라 객체의 생명 주기, 스코프를 관리할 수 있다.\n- 애플리케이션의 객체 생성과 관리에 필요한 정보를 별도의 설정 파일 또는 클래스로 분리할 수 있다. 이를 통해 코드의 유연성과 재사용성을 높일 수 있다.\n\t- XML 설정 방식, Java 어노테이션, `@Configuration` 설정 클래스\n\n#### 단점\n- 객체 생성과 관리, 의존성 주입 등을 컨테이너가 담당하여 런타임에 약간의 오버헤드가 발생할 수 있다. (그러나 보통 이런 오버헤드는 성능에 큰 영향을 주지 않는다.)\n\n## Spring Bean Definition\n\n### 그게 뭔데\nSpring bean을 생성하고 구성하기 위한 설정 정보이다. \n어떤 클래스를 bean으로 사용할 것인지, 어떤 의존성을 주입할 것인지, bean의 scope 등을 정의한다.\n\n`@Component`, `@Service`, `@Repository`, `@Controller` 어노테이션을 사용해서 bean을 등록할 수 있다. 위와 같은 어노테이션을 달게 되면 해당 클래스를 컴포넌트 스캔 대상으로 지정하여 스프링 컨테이너가 자동으로 bean으로 등록한다.\n\nJava 설정 클래스를 사용하는 방식에서는 `@Configuration` 어노테이션이 지정된 클래스를 생성하고, `@Bean` 어노테이션을 사용하여 bean을 생성한다. \n`@Bean` 어노테이션을 붙인 메서드는 해당 메서드가 생성한 객체를 Spring Bean으로 등록한다. \n기본적으로 `@Bean` 어노테이션을 붙이게 되면 bean이 싱글톤으로 생성된다. \n\n### 언제, 어디서 초기화 될까?\nSpring Bean은 스프링 컨테이너가 시작될 때 초기화된다. \n\n`ApplicationContext`의 `refresh()` 메서드가 호출되면, 스프링 컨테이너의 초기화 과정이 시작된다. 스프링 컨테이너의 구성 요소들을 설정하고, bean definition을 로드하며, bean 객체를 생성한다.\n`refresh()` 내부에서 bean 생성 및 의존성 주입이 이루어진다. `DefaultListableBeanFactory` 가 bean definition을 관리하고, bean의 생성, 의존성 주입을 담당한다.\n\n`DefaultListableBeanFactory` 는 `refresh()` 메서드에서 `preInstantiateSingletons()` 메서드를 호출하여 모든 싱글톤 bean들을 생성하고 의존성 주입을 수행한다.\n\n```java\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {  \n   // Initialize conversion service for this context.  \n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&  \n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {  \n      beanFactory.setConversionService(  \n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));  \n   }  \n  \n   // Register a default embedded value resolver if no BeanFactoryPostProcessor  \n   // (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:   // at this point, primarily for resolution in annotation attribute values.   if (!beanFactory.hasEmbeddedValueResolver()) {  \n      beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));  \n   }  \n  \n   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.  \n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);  \n   for (String weaverAwareName : weaverAwareNames) {  \n      getBean(weaverAwareName);  \n   }  \n  \n   // Stop using the temporary ClassLoader for type matching.  \n   beanFactory.setTempClassLoader(null);  \n  \n   // Allow for caching all bean definition metadata, not expecting further changes.  \n   beanFactory.freezeConfiguration();  \n  \n   // Instantiate all remaining (non-lazy-init) singletons.  \n   beanFactory.preInstantiateSingletons();  \n}\n```\n\nbean 객체의 의존성 주입이 완료되면 초기화 메서드가 호출된다. \n`InitializingBean` 인터페이스를 구현한 빈은 `afterPropertiesSet()` 메서드가 호출되며, `@PostConstruct` 어노테이션이 지정된 메서드는 자동으로 호출된다.\n\n## Bean LifeCycle\n\nBean으로 등록된 객체들을 초기화하고 싶은 경우, 의존관계 주입이 완료된 후에 초기화 작업을 수행해야 한다.\n스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려준다. \n스프링 컨테이너가 종료되기 직전에는 소멸 콜백을 제공한다.\n\n### 과정\n\n1. 스프링 컨테이너 생성\n2. 스프링 빈 생성\n3. 의존 관계 주입\n4. 초기화 콜백 실행\n5. 사용\n6. 소멸 전 콜백 실행\n7. 스프링 종료\n\n### 생명주기 콜백\n\n#### `InitializingBean`, `DisposableBean`\n\n```java\n@Component  \npublic class Bean implements InitializingBean, DisposableBean {  \n    @Override  \n    public void destroy() throws Exception {  \n        System.out.println(\"소멸 콜백\");  \n    }  \n  \n    @Override  \n    public void afterPropertiesSet() throws Exception {  \n        System.out.println(\"초기화 콜백\");  \n    }  \n}\n```\n\n```shell\n2023-06-06 15:46:26.932  INFO 49436 --- [           main] hello.DemoApplication                    : No active profile set, falling back to 1 default profile: \"default\"\n2023-06-06 15:46:27.289  INFO 49436 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2023-06-06 15:46:27.298  INFO 49436 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2023-06-06 15:46:27.298  INFO 49436 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.65]\n2023-06-06 15:46:27.335  INFO 49436 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2023-06-06 15:46:27.336  INFO 49436 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 385 ms\n2023-06-06 15:46:27.348  INFO 49436 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2023-06-06 15:46:27.391  INFO 49436 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2023-06-06 15:46:27.396  INFO 49436 --- [           main] o.s.b.a.h2.H2ConsoleAutoConfiguration    : H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:testdb'\n초기화 콜백\n2023-06-06 15:46:27.553  INFO 49436 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2023-06-06 15:46:27.559  INFO 49436 --- [           main] hello.DemoApplication                    : Started DemoApplication in 0.757 seconds (JVM running for 0.999)\n소멸 콜백\n2023-06-06 15:46:34.602  INFO 49436 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...\n2023-06-06 15:46:34.604  INFO 49436 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.\n```\n\n**단점만 있네**\n스프링 전용 인터페이스에 의존하게 되어, POJO 객체가 아니게 된다.\n초기화, 소멸 메서드의 이름을 변경할 수 없다.\n코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.\n스프링 초창기에 나온 방식으로 지금은 거의 사용하지 않는다.\n\n#### `@PostConstruct`, `@PreDestroy` 어노테이션\n\n스프링에서 가장 권장하는 방식. \n`javax.annotation.PostConstruct` 를 사용하여 스프링이 아닌 다른 컨테이너에서도 동작한다.\n\n```java\n@Component  \npublic class AnnotationBean {  \n    @PostConstruct  \n    public void initializeCallBack() {  \n        System.out.println(\"어노테이션 초기화 콜백\");  \n    }  \n  \n    @PreDestroy  \n    public void destroyCallBack() {  \n        System.out.println(\"어노테이션 소멸 콜백\");  \n    }  \n}\n```\n\n단, 외부 라이브러리에는 적용하지 못한다.\n\n#### `@Bean`의 `initMethod`, `destroyMethod`\n\n외부 라이브러리에도 적용할 수 있는 콜백 메서드 지정 방식이다.\n`@Bean`의 `initMethod`, `destroyMethod` 에 각각 문자열로 메서드 이름을 지정해주면 된다.\n\n```java\npublic class NormalBean {  \n    public void initMethod() {  \n        System.out.println(\"빈 설정 초기화 콜백\");  \n    }  \n  \n    public void destroyMethod() {  \n        System.out.println(\"빈 설정 소멸 콜백\");  \n    }  \n}\n```\n\n```java\n@Configuration  \npublic class Config {  \n    @Bean(initMethod = \"initMethod\", destroyMethod = \"destroyMethod\")  \n    public NormalBean getNormalBean() {  \n        return new NormalBean();  \n    }  \n}\n```\n\n#### 동시에 사용하면\n\n```shell\n2023-06-06 15:54:38.077  INFO 49507 --- [           main] hello.DemoApplication                    : No active profile set, falling back to 1 default profile: \"default\"\n2023-06-06 15:54:38.429  INFO 49507 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2023-06-06 15:54:38.432  INFO 49507 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2023-06-06 15:54:38.432  INFO 49507 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.65]\n2023-06-06 15:54:38.473  INFO 49507 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2023-06-06 15:54:38.473  INFO 49507 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 379 ms\n2023-06-06 15:54:38.484  INFO 49507 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2023-06-06 15:54:38.528  INFO 49507 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2023-06-06 15:54:38.533  INFO 49507 --- [           main] o.s.b.a.h2.H2ConsoleAutoConfiguration    : H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:testdb'\n어노테이션 초기화 콜백\n초기화 콜백\n빈 설정 초기화 콜백\n2023-06-06 15:54:38.692  INFO 49507 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2023-06-06 15:54:38.699  INFO 49507 --- [           main] hello.DemoApplication                    : Started DemoApplication in 0.761 seconds (JVM running for 1.003)\n빈 설정 소멸 콜백\n소멸 콜백\n어노테이션 소멸 콜백\n2023-06-06 15:54:40.466  INFO 49507 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...\n2023-06-06 15:54:40.469  INFO 49507 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.\n```\n\n신기하게도 언제나 어노테이션 초기화 콜백이 가장 먼저 불리고, 그다음은 `InitializingBean` 초기화 콜백, 마지막은 `@Configuration`에 설정해둔 초기화 콜백이 마지막으로 불린다.\n소멸은 반대 순서로 이루어진다. 신기하네\n\n## Bean Injection\n\n## Bean 등록 방법\n\nxml 방식도 있지만 자주 사용되지 않는 방식이니 제외했다.\n\n### `@Configuration`\n\n`@Configuration` 에서 수동으로 Bean을 등록해줄 수 있다. \n```java\n@Configuration  \npublic class Config {  \n    @Bean  \n    public NormalBean getNormalBean() {  \n        return new NormalBean();  \n    }  \n}\n```\n\n메서드 이름으로 bean 이름이 결정되니, 중복된 빈 이름이 존재하지 않도록 주의해야 한다.\n스프링 빈으로 등록된 다른 클래스 안에서 `@Bean` 으로 직접 빈을 등록해주는 것도 동작은 하지만, `@Configuration` 내부에서 `@Bean` 을 사용해야 싱글톤을 보장받을 수 있다. \n\n```java\n@Component  \npublic class CustomBean {  \n    @Bean  \n    @Scope(value = \"singleton\")  \n    public OtherBean getOtherBean() {  \n        return new OtherBean();  \n    }  \n}\n```\n\nbean을 싱글톤으로 생성하도록 설정해도 `getOtherBean` 을 호출할 때마다 계속해서 여러 객체가 생성된다.\n\n**어떤 때에 `@Bean` 을 쓰면 좋을까** \n\n다음과 같은 경우에 `@Bean` 으로 직접 빈을 등록해준다. \n1. 개발자가 직접 제어가 불가능한 라이브러리를 활용할 때 (외부 라이브러리 사용)\n2. 애플리케이션 전범위적으로 사용되는 클래스를 등록할 때\n3. 다형성을 활용하여 여러 구현체를 등록해주어야 할 때\n\n애플리케이션 전범위적으로 사용하는 클래스와 다형성을 활용하여 여러 구현체를 등록할 때 `@Bean` 을 사용하면 좋은 이유는 유지보수하기 좋기 때문이다. \n여러 구현체를 빈으로 등록할 때 어떤 구현체가 빈으로 등록되는지 파악하려면 `@Configuration` 만 확인하면 되어 유지보수가 용이하다.\n\n### `@Component`\n\n컴포넌트 스캔을 사용해서 `@Component` 어노테이션이 있는 클래스들을 찾아서 자동으로 빈 등록을 해준다.\n`@Service`, `@Controller`, `@Repository` 등은 `@Component` 어노테이션을 갖는다.\n\n원래 `@Component` 를 이용할 때 Main이나 App 클래스에서 `@ComponentScan` 으로 컴포넌트를 찾는 탐색 범위를 지정해주어야 하지만, SpringBoot 에서는 `@SpringBootConfiguration` 하위에 기본적으로 포함되어 있어 별도 설정이 필요 없다.\n\n**참고**\n- https://mangkyu.tistory.com/75"},{"excerpt":"LOG 잠깐 잠실에 가서 코드 리팩토링을 하는 시간을 가졌다. 생각보다 뼈대 코드를 리팩토링할 부분이 많아서, 오늘은 도메인과 엔티티를 분리하고 Repository를 만들었다. 배운 것  에서   에는 primary key를 적어주어야 한다. 다른 키를 함께 적게 되면 다른 키도 primary key로 인식되는 듯 하다. (composite key? 로 …","fields":{"slug":"/2023-05-28/"},"frontmatter":{"date":"2023년 05월 28일 14:05","title":"2023년 05월 28일","tags":null},"rawMarkdownBody":"## LOG\n- 잠깐 잠실에 가서 코드 리팩토링을 하는 시간을 가졌다. 생각보다 뼈대 코드를 리팩토링할 부분이 많아서, 오늘은 도메인과 엔티티를 분리하고 Repository를 만들었다. \n\n## 배운 것\n- `SimpleJdbcInsert` 에서  `usingGeneratedKeyColumns` 에는 primary key를 적어주어야 한다. 다른 키를 함께 적게 되면 다른 키도 primary key로 인식되는 듯 하다. (composite key? 로 인식하는 듯)\n- termius 좋다. 코드 템플릿도 적어두고 재사용 가능하고, 서버와 쉽게 연결 가능한 것도 좋다. 앞으로도 애용할 듯. 특히 ip 주소 까먹는 경우가 많은데 그래서 그런지 템플릿 기능이 매우 유용하다...\n- mysql 서버와 production 서버가 연결되지 않았던 이유: 외부에서는 root 권한으로 접근할 수가 없다. 따라서 production 서버를 user로 등록해서 외부에서도 연결할 수 있도록 user 테이블에 추가해주어야 한다. + 우리는 vero, hubk, dazzle 데이터베이스가 다 다른데, 각각의 유저에 데이터베이스에 접근할 수 있는 권한도 추가해주어야 했다.\n\n```sql\n+--------------------------------------------------------------+\n| GRANT USAGE ON *.* TO `wooteco`@`ip주소`                      |\n| GRANT ALL PRIVILEGES ON `vero`.* TO `wooteco`@`ip주소`        |\n+--------------------------------------------------------------+\n```\n\n- 진짜 이상하게도 아래 sql은 bad sql이라는 예외가 발생한다.\n```sql\nSELECT ci.id, ci.member_id, ci.quantity, \nm.email, m.point, \np.id, p.name, p.price, p.image_url\nFROM cart_item ci \nINNER JOIN member m ON ci.member_id = m.id\nINNER JOIN product p ON ci.product_id = p.id\nWHERE ci.member_id = ?\n```\n\n이걸 해결하려면 무조건 AS로 column 이름을 지정해줘야 한다.\n\n```sql\nSELECT ci.id AS cart_id, \nci.member_id AS cart_member_id, \nci.quantity AS cart_quantity,\nm.email AS member_email, \nm.point AS member_point, \np.id AS product_id, \np.name AS product_name, \np.price AS product_price, \np.image_url AS product_image_url \nFROM cart_item ci \nINNER JOIN member m ON ci.member_id = m.id   \nINNER JOIN product p ON ci.product_id = p.id   \nWHERE ci.member_id = ?\n```\n\n## 궁금한 것\n- 왜 저게 bad sql 일까\n\n## 느낀 것\n- 오늘도 기분이 좋다~ 비도오고 그래서~ 비오는 날이 안 좋기만 한 건 아닌 것 같다. 끈적거리고 습하고 우산들고 있는 팔은 아프지만 그래도 비오는 날만의 장점이 있다. 장점은 구체적으로 칭찬 안 하고 싶으니까 여기까지~"},{"excerpt":"앞으로 회고 모임에 적는 글들을 여기에도 올려보려고 한다 ˙ᵕ˙ 🌈 이번 주의 생각 💭 즐선생님, 헙선생님과 장바구니 협업 페어가 되었다. 프론트엔드인 도밥과 아이크도 정말 좋으신 분들이다. 특히 질문이 많으셔서 좋다. 나는 언제나 강의든 과외든 하게 되면 질문을 해달라고 하는 편이었는데, 그런 말을 하지 않아도 궁금한 게 많고 물어보기를 주저하지 않아서…","fields":{"slug":"/level2-week7-retrospect/"},"frontmatter":{"date":"2023년 05월 28일 14:05","title":"레벨2 7주차 회고","tags":["회고"]},"rawMarkdownBody":"\n앞으로 회고 모임에 적는 글들을 여기에도 올려보려고 한다 ˙ᵕ˙\n\n## 🌈 이번 주의 생각 💭\n\n-   즐선생님, 헙선생님과 장바구니 협업 페어가 되었다. 프론트엔드인 도밥과 아이크도 정말 좋으신 분들이다. 특히 질문이 많으셔서 좋다. 나는 언제나 강의든 과외든 하게 되면 질문을 해달라고 하는 편이었는데, 그런 말을 하지 않아도 궁금한 게 많고 물어보기를 주저하지 않아서 좋다.\n    -   프론트엔드 분들과 잠실에서 만나서 요구사항 정의하고 명세를 정리했던 시간이 생각보다 너무 즐거웠다. 이번 페어의 컨셉은 ‘모든 생각들을 기록으로 남겨보자’ 였는데, 의외로 정리하는 시간이 즐거워서 앞으로도 페어하면서 정리하는 습관을 길러야겠다.\n    -   즐선생님은 내가 생각하지 못한 부분을 잘 짚어주신다. 헙선생님과 내가 프론트엔드에서 고려해야 하는 사항을 적을 때 즐선생님은 옆에서 이런 문제가 있을 수 있다, 이런 경우에는 어떻게 해야 할까를 항상 물어봐줘서 예외 케이스를 생각하는데 도움이 많이 됐다.\n    -   헙선생님은 뭔가 뚝딱해오신다. mysql 연결 문제가 있었을 때도 한 시간 만에 해결해오시고, logback 설정도 어떻게 알아오셔서 전체 로그와 warn 로그를 분리하는 기능까지 뚝딱 구현해 오셨다. 엄청 신기하다 ㅋㅋㅋ\n    -   나도 칭찬해보자. 이번 페어 때는 기록을 열심히 했다. 어떤 고민을 했고, 어떤 선택을 했는지를 (다는 아니지만) 적어두어서 지금 볼 때도 이런 생각으로 판단을 내렸다는 것을 확인할 수 있어 좋다. 의견을 낼 때는 장단점을 동시에 이야기 했다. 다른 사람이 판단을 할 때 좋고 나쁨을 확실하게 알고 판단하는 것이 좋다고 생각한다. 그래서 이게 무조건 좋다! 무조건 나쁘다! 보다는 이런 경우에는 좋다, 이런 경우에는 안 좋을 수 있다라는 화법으로 의견을 제안하니 다른 사람이 선택하기에 수월했던 것 같다.\n-   matzip에 좀 더 시간을 투자했다. 오리와 페어도 열심히 하고, PR 올라온 것도 보는 시간을 가졌다. 시간이 많지 않아 소홀했던 점이 아쉽다. 앞으로의 계획에 대해 회의하는 시간도 가졌는데, 의견이 빠르게 하나로 모이지는 않았지만 나는 그것대로 좋았다고 생각한다. 계획대로 안 되는 것도, 하고 싶은 게 많은 것도, 서로의 가치관과 생각이 다른 것도 어쩌면 당연한 것이라 자연스러운 일이었다. 만약 서로의 의견을 중재하는 사람이 필요해진다면 내가 해보고 싶다. 나는 크게 의견이 있는 사람이 아니라서, 의견을 좀 더 객관적으로 볼 수 있지 않을까 싶다. 그냥 그렇다고 ㅋㅋ\n-   그것과는 별개로 matzip에서 배우는 내용이 많다. 서브모듈도 matzip이 아니었다면 몰랐을 거고, 멀티 모듈이며 graceful shutdown도 하나도 몰랐을 것 같은데 알아가는 키워드들이 많아서 좋다. 4기 오리가 열심히 페어해주시는 것도 감사하다. 퇴근하고 솔직히 쉬고 싶으실 텐데 우리가 matzip을 이어나갈 우테코 후배 기수라는 이유만으로 도움을 주시는 것에 굉장한 감사를 느끼고 있다. 감사합니다 오리 🫶🏻\n-   새싹 교실이 끝났다. 인터페이스까지 다루지 못해 아쉬움을 느끼지만, 그래도 개인적으로 지금까지 강의했던 것에 비해 많이 늘었다고 느낀다. 처음에는 단지 정보 전달을 하기 위해 급급해서 재작년까지는 솔직히 새싹들에게 크게 도움이 된 건 아니었다고 생각한다. 그렇지만 이번에는 왜 이걸 써야 하는지, 왜 이렇게 하는 것이 좋은지 내가 고민했던 부분을 최대한 전달하려고 애썼다. 단순히 int의 범위나 상속을 하는 방법을 알려주는 게 아니라, 왜 변수를 써야하고 왜 final을 써야 하는지 등 개인적으로 고민했던 내용들을 전달하는 것에 중심을 두어서 나도 수업하면서 즐거웠다. 한 주만 더 있었다면 좋았겠다는 생각도 했다. (그렇지만 앞으로 2주가 시험기간이기 때문에 욕심은 마음에 고이 접어두었다…)\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n-   지금의 소통하는 방식이 마음에 든다. 의견을 말할 때 무조건 장단점, 발생될 수 있는 효과를 동시에 말하는 습관을 들이자. 다른 사람이 내 의견을 듣고 나서 좀 더 쉽게 결정내릴 수 있게 된다.\n-   페어하면서 고민했던 내용을 정리하고, 어떤 주제에 대해 서로 의견을 나눴던 내용을 정리하자. 의외로 시간도 얼마 들지 않고 기록해 놓은 글이 나중에 너무 도움이 된다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n-   TIL을 많이 못 썼다. 할 일도 많긴 했지만 많이 놀아서도 맞다. 집에 가서 TIL 안 쓰고 놀거나 그냥 누워버리는 일이 잦았다. 최대한 그 날 알게 된 내용은 바로바로 적는 습관을 들여야겠다. 느낀점, LOG가 없더라도 배운 점이라도 있다면 좋을 거 같다.\n-   감정에 솔직하려고 노력했지만, 언제나 솔직하지는 못했다. 가끔 다른 사람의 눈치를 본 것도 있고, 내가 정말로 이 감정을 가지고 있는지 자신이 없는 경우도 있었다. 그럴 때 생각을 잠깐 멈추고 내가 어떤 생각을 하고 있는지, 정말로 원하고 있는 게 맞는지를 생각해보자.\n-   이번 주는 조금 피곤했다. 너무 늦게까지 깨어 있지 말고 졸릴 때 바로 자는 습관을 들여보자.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n-   틈틈이 matzip 코드를 읽어보자. 어떤 부분부터 읽자! 하고 읽기 보다는 이 부분 궁금한데 한 번 봐볼까? 라는 느낌으로 읽어보는 게 좋을 거 같다.\n-   미래 계획을 세워보자. 단기 목표도 좋고, 장기 목표도 좋다. 내가 무엇을 하고 싶은지 찾아갈 수 있는 좋은 기회가 될 것이다.\n\n## 📚 다음 주 목표\n\n-   무사히 협업 미션 제출하기\n-   내 감정에 솔직하게 살아가기\n-   다음 주 안에 목표가 무엇일지 생각해보고 글로 정리하기"},{"excerpt":"LOG 2시에 matzip 회의가 있었다. 루루, 체인저, 애슐리, 주드와 오찌, 블링, 오리가 참석했다. 나는 에어팟이 없어서 250만원짜리 전화기를 썼다... 근데 진짜 하나도 안 들려서 그냥 정리해준 거 봤다. 체인저 나이스. 생산적인 회의였다. 지하철 미션 제출했다. 리뷰 온 지 4일만에 죽은 자 가운데서 다시 태어나시고.. 하나의 쿼리로 모든 노…","fields":{"slug":"/2023-05-27/"},"frontmatter":{"date":"2023년 05월 27일 13:05","title":"2023년 05월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 2시에 matzip 회의가 있었다. 루루, 체인저, 애슐리, 주드와 오찌, 블링, 오리가 참석했다. 나는 에어팟이 없어서 250만원짜리 전화기를 썼다... 근데 진짜 하나도 안 들려서 그냥 정리해준 거 봤다. 체인저 나이스. 생산적인 회의였다.\n- 지하철 미션 제출했다. 리뷰 온 지 4일만에 죽은 자 가운데서 다시 태어나시고.. 하나의 쿼리로 모든 노선을 조회할 수 있도록 변경한 게 뿌듯했다. 근데 다시 돌아보면 이런 간단한 걸 왜 못했을까 싶긴 했다. 아무래도 select * 를 쓰면 조인이 제대로 안 됐는데 조회하는 컬럼의 이름을 지정해주면 조인이 잘 된다.\n\n## 배운 것\n- `@Positive` 를 컨트롤러 `@PathVariable`에 적어줄 수 있다. 다음과 같이 사용할 수 있다. \n\n```java\n@Validated  \n@RestController  \n@RequestMapping(\"/path\")  \npublic class PathController {  \n    private final PathService pathService;  \n  \n    public PathController(final PathService pathService) {  \n        this.pathService = pathService;  \n    }  \n  \n    @GetMapping(\"/{startStationId}/{endStationId}\")  \n    public ResponseEntity<ShortestPathResponse> findShortestPath(  \n            @PathVariable(\"startStationId\") @Positive(message = \"역 ID는 양수여야 합니다.\") final Long startStationId,  \n            @PathVariable(\"endStationId\") @Positive(message = \"역 ID는 양수여야 합니다.\") final Long endStationId  \n    ) {  \n        ShortestPathResponse shortestPathResponse = pathService.findShortestPath(startStationId, endStationId);  \n        return ResponseEntity.ok(shortestPathResponse);  \n    }  \n}\n```\n\n이때 리턴하는 예외는 `ConstraintViolationException` 이다. 해당 예외를 처리하기 위해 `@ControllerAdvice`  에 다음과 같이 작성해주었다. \n\n```java\n@ExceptionHandler(ConstraintViolationException.class)  \npublic ResponseEntity<ErrorResponse> handleNotFoundException(ConstraintViolationException e) {  \n    List<String> errorMessages = List.of(e.getMessage().split(\": \"));  \n    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(errorMessages.get(1)));  \n}\n```\n\n`ConstraintViolationException` 예외의 메시지는  `findShortestPath: \"역 ID는 양수여야 합니다.\"` 라고 전달되기 때문에 파싱해주는 작업을 추가로 진행하였다. \n\n## 궁금한 것\n- `ConstraintViolationException` 메시지는 무조건 저런 형태로 나오나?\n\n## 느낀 것\n- "},{"excerpt":"앞으로의 계획 크레딧을 가지고 전체 배포와 인프라 쪽을 옮겨오는 작업 CI/CD 안 되어 있음. 기존에는 손배포 진행 -> jar 로컬에서 만들어서 scp 후 run CI는 github action 으로 되고 있음. CD도 github action을 쓸 것이다. jenkins를 좀 더 실무에서 많이 쓴다. 쓰는 이유: jenkins의 플러그인들이 다양하고…","fields":{"slug":"/ori-05-26/"},"frontmatter":{"date":"2023년 05월 26일 13:05","title":"5월 26일 오리와 페어","tags":["matzip"]},"rawMarkdownBody":"\n### 앞으로의 계획\n- 크레딧을 가지고 전체 배포와 인프라 쪽을 옮겨오는 작업\n- CI/CD 안 되어 있음. 기존에는 손배포 진행 -> jar 로컬에서 만들어서 scp 후 run\n- CI는 github action 으로 되고 있음. CD도 github action을 쓸 것이다. jenkins를 좀 더 실무에서 많이 쓴다.\n\t- 쓰는 이유: jenkins의 플러그인들이 다양하고, 플러그인을 사용하기 위해 어쩔 수 없이 쓴다.(Circle CI) 커스텀이 편해서 대부분의 회사가 쓴다.\n\t- 안 쓰는 이유: 새로 구축하는 것이 귀찮다. 젠킨스용 서버를 따로 띄워야 해서 계속 관리를 해주어야 한다. (번거로움)\n\t- 손배포 할 때 메모리가 터진다. t4g.micro는 메모리가 딸리는데 jenkins 빌드할 때는 메모리가 중요하다. `./gradlew bootJar`는 메모리가 필요하다. 그러나 스왑 메모리 설정을 하면 매우 느리다.\n\t- 서버 관리 필요 없고, 메모리 관리가 필요 없는 github action을 쓸 것이다.\n- CI github action (확정)\n- CD github action (예정)\n\n### 기존 서버 설명\n- EC2\n\t- 실제 서버 application\n\t\t- 스프링 서버\n\t\t\t- 내부에서 ssl 설정을 해줄 수 있지만 안하는 이유? : 스프링 서버는 application(api 제공)의 역할만 해야 한다. \n\t\t\t- ssl을 수행할 수는 있지만, ssl을 관리하는 역할을 수행하면 안 된다.\n\t\t- nginx\n\t\t\t- ssl 인증을 할 때 443 포트로 요청을 한다. ssl redirect, dns 요청을 처리하는 역할\n\t\t\t- 통신 전반에 대한 처리를 수행한다.\n\t\t\t- https -> http + ssl 인증서\n\t- 테스트용 데이터베이스 서버\n- RDS (프리티어 사용할 예정)\n\t- 실제 서버 데이터베이스\n- 호스팅\n\t- 가비아 (블링)\n\t- 모두 수행한 후에 블링에게 옮겨달라고 요청하면 된다.\n\n### 오늘 해야 하는 것\n#### 기존 인프라 구조 가져오기\n- [x] aws ec2 테스트용 데이터베이스를 가져와서 로컬에 저장해둔다.\n\t- 성능 테스트용 데이터베이스 (리뷰 데이터가 1000만~2000만건이 들어가있다.)\n- [ ] aws rds 데이터베이스를 가져와서 dev.matzip에 올리기\n\t- 데이터 가져오기\n\t- security group 설정\n\t\t- 인바운드, 아웃바운드 설정\n- [x] aws ec2에 있는 nginx config 설정 값 가져와서 로컬에 저장해둔다.\n\t- 코드 보고 이해하기\n- [ ] github action에 CI용 yml script 정리 -> 오리가 과제로 내주기로 했다\n\n#### 인프라 구조 구축하기 (언젠가 누구든)\n- 새로 띄운 aws ec2를 dns에 붙이는 것 (블링한테 요청하기)\n- github action cd 구축\n\n#### 나중에 추가로 할 것들\n- 무중단 배포\n웬만하면 우테코 교육 과정 내에서 배우는 정도로 진행할 것.\n\n## 진행\n- 탄력적 IP는 언제나 할당하자. 안 그러면 과금되니까!\n- 프라이빗 IPv4을 막아두어야 하는 이유?\n\t- 퍼블릭 IP가 열려야 외부에서 접근할 수 있다.\n\t- 데이터베이스가 퍼블릭 IPv4가 열려있으면 디도스 공격을 맞을 수 있다. \n\t- application 서버가 디도스를 맞더라도 앞 단에서 조치를 취할 수 있기 때문에 프라이빗 ip는 막아두는 것이 좋다.\n- 굳이 서버 설정에서 퍼블릭 ip를 쓸 이유가 없다.\n\n### 설명해주신 개념들\n- 프록시 서버: 요청을 대리하는 것. 프론트 단에서 프록시 서버가 있어서 프론트의 요청을 대신 넘겨주는 역할을 한다. \n- 리버스 프록시: 백엔드 서버 앞에서 요청을 필터링하는 역할을 한다.\n- 게이트웨이: 요청에 대한 처리들을 앞쪽에서 처리해주는 것.\n- 사이드카 패턴: spring boot 애플리케이션이 nginx를 사이드카처럼 데리고 다닌다\n\t- 사이드카를 붙이든 떼어내는 것처럼 애플리케이션의 기능에 영향을 주지 않고 추가 기능을 적용할 수 있다.\n\n## 오늘 한 것\n- 테스트 DB dump (복사)\n\t- `scp -i pem키 복사할파일 ssh유저이름@주소:복사할파일경로/파일명`\n\t- `mysqldump -uroot -p루트비밀번호 데이터베이스이름 > 경로/저장될파일명.sql`\n- nginx config 코드 이해하기\n- github action ci 코드 읽어보기\n"},{"excerpt":"페어 기록 ori-05-26 ohzzi-05-30 ori-06-08","fields":{"slug":"/matzip_pair/"},"frontmatter":{"date":"2023년 05월 26일 13:05","title":"matzip 페어 활동","tags":["matzip","우테코"]},"rawMarkdownBody":"\n## 페어 기록\n- [[ori-05-26]]\n- [[ohzzi-05-30]]\n- [[ori-06-08]]\n"},{"excerpt":"LOG 도밥과 아이크가 잠실로 와서 같이 점심을 먹었다. 원래 59쌀피자에 가려고 했는데 사람이 많아서 나왔더니 갈 곳이 없었다. 가까운 식당 중에 그나마 괜찮은 곳이 연어식당이어서 거기서 밥을 먹었다. 32000원짜리 카이센동 먹은 아이크... 멋지다. 역시 롯데타워 오너는 다르다 ㄷㄷ 프론트 분들이랑 같이 이야기 하는 거 되게 재밌었다. 질문을 많이 …","fields":{"slug":"/2023-05-26/"},"frontmatter":{"date":"2023년 05월 26일 07:05","title":"2023년 05월 26일","tags":null},"rawMarkdownBody":"\n## LOG\n- 도밥과 아이크가 잠실로 와서 같이 점심을 먹었다. 원래 59쌀피자에 가려고 했는데 사람이 많아서 나왔더니 갈 곳이 없었다. 가까운 식당 중에 그나마 괜찮은 곳이 연어식당이어서 거기서 밥을 먹었다. 32000원짜리 카이센동 먹은 아이크... 멋지다. 역시 롯데타워 오너는 다르다 ㄷㄷ 프론트 분들이랑 같이 이야기 하는 거 되게 재밌었다. 질문을 많이 해주신 도밥에게 감사합니다.\n- 오리와 페어를 했다. 기록은 여기에 -> [[ori-05-26]] \n- matzip 기획 회의를 했다. 사실 까먹었는데 ㅋㅋㅋ 다행히 4시간 전에 알게 돼서 준비를 할 수 있었다. 아찔하다. 요즘에 todo를 안 써서 그런가 너무 일정이 아무것도 기억이 안 난다. 앞으로 다시 열심히 써보자.\n\n## 배운 것\n- restdocs가 별로인 이유 by 오리: 별도 테스트를 작성하는 리소스가 발생한다. asciidocs을 내가 관리해야 한다. (완전 자동화 아님) -> 차라리 swagger 쓰고 말지\n- https의 기본 포트는 443이다.\n- 리버스 프록시가 http 요청이 들어왔을 때 https로 리다이렉트를 해준다.\n- ssh 연결로 파일을 보낼 수 있다 : `scp -i pem키 전송할파일 접속할호스트이름@파일을보낼서버IP:복사할파일경로/복사할파일이름`\n- `@PropertySource` 를 사용하면 external properties를 가져올 수 있다. + 환경 변수로도 properties의 경로를 받아서 값을 전달해줄 수 있다.\n\t- 그냥 이 방법 자체가 별로다 by 오리 -> 대체제로는 submodule 이랑 뭔가 더 있었다...\n\t- 환경 변수를 쓰는 게 별로인 이유 by 오리: 환경 변수를 쓴다면 배포 스크립트가 존재할텐데, 여러 서버에서 동일한 애플리케이션을 실행할 때마다 스크립트가 공유되어야 한다. \n- 80 포트를 쓸 때는 관련 코드에 sudo 써야 한다.\n\t- `sudo fuser -k 80/tcp`\n\t- `sudo nohup java -jar jwp-shopping-order.jar &`\n\t- chat.gpt 인용\n\t> 일반적으로 1024보다 낮은 포트(80 포트 포함)는 관리자 권한이 필요합니다. EC2 인스턴스에서 애플리케이션을 80 포트로 실행하려면 애플리케이션을 루트 또는 슈퍼 유저 권한으로 실행해야 합니다. 예를 들어, `sudo` 명령어를 사용하여 애플리케이션을 실행해 보세요.\n\n - Well known port (0~1023번 포트)는 sudo 권한이 필요하다. 키워드 제공 by 포이\n\n## 궁금한 것\n- submodule 말고 다른 방법이 더 있었던 거 같은데 뭐였을까 (솔라가 키워드를 말해주셨던 거 같은데 기억이 안 난다. 물어보자~)\n\n## 느낀 것\n- 선한 의도로 선한 영향력을 끼치는 사람이 멋지다. 바로 오리. 퇴근하고 나서 피곤하고 귀찮으실텐데 아무런 대가도 없이 우테코 후배 기수라는 이유 하나만으로 굉장히 많은 도움을 주신다. 오리는 안 보시겠지만 항상 감사하고 있습니다 🚀 나도 선한 의도로 선한 영향력을 끼칠 수 있는 사람이 되고 싶다.\n- 아이크와 도밥이 열정적이어서 협업하는 것이 즐겁다. 두 분 다 궁금하거나 이해가 잘 안 되는 부분, 잘 모르겠는 부분을 적극적으로 말해주셔서 대답하는 것도 즐겁고 토론하는 것도 너무 재밌었다. 그것과는 별개로 ec2 db 연결하는 부분이 잘 안 돼서 나는 결국 해결 못하고 집에 갔다. 즐선생님과 헙선생님 두 분이 갑자기 해결해주셔서 황송했다... 감사합니다."},{"excerpt":"페어 규칙 시간은 재지 않고 진행한다. 궁금한 점이나 의견은 언제든지 자유롭게 말한다. 분위기에 끌려가지 말기. 둘 다 좋다고 하지 않기 -> 진짜 둘 다 좋은 경우에는 각각 좋은 이유를 말할 것. 마음 속에 뭔가 정답이 있는 경우에는 그냥 말하기. 경청 잘하기. 유저 받아서 변경하기 pull 로 바꾸기 기존에 디렉토리가 존재하면 pull, 없으면 clo…","fields":{"slug":"/level2-shopping-order/"},"frontmatter":{"date":"2023년 05월 23일 05:05","title":"레벨2 장바구니 협업 with 다즐 헙크","tags":["우테코","레벨2"]},"rawMarkdownBody":"\n## 페어 규칙\n- 시간은 재지 않고 진행한다.\n- 궁금한 점이나 의견은 언제든지 자유롭게 말한다. 분위기에 끌려가지 말기. \n- 둘 다 좋다고 하지 않기 -> 진짜 둘 다 좋은 경우에는 각각 좋은 이유를 말할 것.\n\t- 마음 속에 뭔가 정답이 있는 경우에는 그냥 말하기.\n- 경청 잘하기.\n\n### 유저 받아서 변경하기\n\n```shell\n#!/bin/sh\n\n# kill process\nfuser -k 8080/tcp\n\n# remove original code\nrm -rf jwp-shopping-order\n\n- [ ] # clone git main branch\ngit clone https://github.com/$1/jwp-shopping-order.git\n\n# build\ncd jwp-shopping-order\n./gradlew bootJar\n\n# execute\ncd build/libs\nnohup java -jar jwp-shopping-order.jar &\n```\n\n### pull 로 바꾸기\n\n- 기존에 디렉토리가 존재하면 pull, 없으면 clone\n\n```shell\n#!/bin/sh\n\n# kill process\nsudo fuser -k 80/tcp\n\n# clone git main branch\nif [ -d ~/jwp-shopping-order ]\nthen\n\tcd jwp-shopping-order\n\tgit pull origin $2\nelse\n\tgit clone https://github.com/$1/jwp-shopping-order.git\n\tcd jwp-shopping-order\nfi\n\n# build\n./gradlew bootJar\n\n# execute\ncd build/libs\nsudo nohup java -jar jwp-shopping-order.jar &\n```\n\n### https 설정하기\n- **도메인 사서 설정 -> cloudfare** \n\t- 서브 도메인 사용\n\n## 2단계\n\n### 필수 구현 사항\n\n- 추가될 테이블\n\t- ![[table_schema.png]]\n- 상품 주문하기 API\n- 주문 상세 정보 API\n- 사용자 별 주문 목록 확인\n- 특정 주문의 상세 정보 확인\n\n## 선택 구현 사항\n\n### 프론트가 추가 할 것 같은 부분?\n- 주문하기 버튼\n- 차감되는 포인트 (항상 전체 사용이냐 아니면 선택할 수 있게 하느냐)\n\t- 사용되는 포인트 프론트로부터 받는다. -> 값을 수정해야 한다.\n\t- 언제나 제공된 포인트까지만 입력할 수 있도록 넣어야 한다. (프론트에서 처리 필요)\n- 최종 결제 금액 (계산 로직 - 프론트에서 처리)\n- 백엔드로 전달되어야 하는 것\n\t- 사용한 포인트\n\t- 최종 결제 금액 -> 사용자의 포인트 계산 (백엔드에서 처리)\n\n### 프론트에게 질문\n- `/orders` 요청 한 번에 정보를 다 주는데 굳이 상세 정보 API가 필요할까? (클라이언트 단에서 캐싱하면 되는데)\n\t- `/orders` (모든 주문 정보)\n\t- `/orders/{orderId}` (주문 상세)\n\t- orders 페이지를 안 거치고 갈 가능성 있으므로 (주문 상세 페이지로 바로 들어가게 되는 경우도 존재할 것이다.) 따라서 필요하다.\n- 모든 정보를 다 주는 것 vs 현재 필요한 정보만 주는 것\n\t- 어차피 필요한 것은 프론트에서 선별하기 때문에 다 내려줘도 괜찮다 by 도밥\n\t- 뷰는 변화에 민감하므로 계속해서 변경될 수 있지만, 뷰의 변화에 따라 API가 변화하는 것은 바람직하지 않다. url에 맞는 정보를 최대한 제공해서 뷰가 변화할 때마다 필요한 정보를 선별하는 것이 낫다. by 포이\n\n### 백엔드에서 구현해야 하는 사항\n- 기존 애플리케이션에 포인트를 추가한다.\n- 계산 시에 포인트를 차감해서 할인을 받도록 한다.\n- 포인트는 현금과 1:1 매칭\n- 포인트는 어떻게 제공되나? -> 최종 결제 금액에서 10% 포인트 적립\n\n###  기존 코드 수정 필요\n- 도메인 검증 로직 추가\n- `delete cascade` 제외했으므로 product 삭제 시 `cart_item`도 삭제하는 로직 필요\n- DB 주소 `application.properties`\n\t- 서브 모듈은 기각 -> 각각의 데이터베이스가 다르므로 `application.yml`에 들어가야 할 DB 링크도 달라지게 된다. 그렇다면 파일을 여러 개를 만들어야 하는데 (헙크, 나, 다즐 용으로) 그러면 굳이 하나의 레포에서 관리할 이유가 없다. 여러 개의 레포를 사용하는 것이 오히려 나을 수 있다. 근데 그런 경우에는 굳이 서브 모듈을 사용할 필요가 있을까?\n\t- `application external properties`를 사용하자.\n\n## 함께 자라기 🌱\n\n### url 길이 조정\n- image_url이 255는 너무 작은 것 같다. -> internet explorer의 url 최대 길이인 2048로 변경\n\n### 엔티티와 도메인은 분리되어야 하는가?\n- 최대한 분리하는 것이 좋다.\n\n### dao, repository, service, controller 테스트?\n- dao: `@JdbcTest`\n- repository: `@JdbcTest`\n- service: `@SpringBootTest`\n- controller: 안 함\n\n### DB를 믿을 것인가? (선택)\n- FK가 걸려 있음에도 findById를 수행해야 하는가? vs 굳이 할 필요 없다.\n\t- 다즐: DB의 예외가 서비스 계층으로 올라오는 것이 좀 별로다.\n\t- 헙크: 좀 믿자ㅋㅋ\n\n- equals -> id로 정의\n\n### 도메인 동등성?\n\n### 어디까지 확장성을 고려해야 할까?\n\n## 논의할 내용\n- [x] 뭔가를 찾을 수 없으면 NOT_FOUND로 한다.\n- [x] orders에 delivery_fee 추가 \n\t- 프론트가 배송비를 알려줘야 하나?\n\t\t- 알려줄 때: deliver_fee가 유연하다. 이 값을 믿을 수 있는지? 서버 단에서 다시 검증해야 될 수도.\n\t\t- 안 알려줄 때: 추가 검증 과정 필요 X, 프론트 로직 수정 X, API 수정. deliver_fee가 서버 값으로 무조건 고정된다. (배송비를 바꾸려면 서버를 바꿔야 한다.)\n\t- 확장되는 순간: 5만원 이하면은 3000원, 3만원 이하면 5000원.\n-> 클라이언트 쪽에서 배송비 받는 것으로 변경. 배송비 받고 나서 추가 검증 수행하기 + 주문 내려줄 때도 배송비 포함하기로.\n만약 배송비 값이 달라지게 되었을 때, 클라이언트와 서버가 각각 배송비 계산을 하게 된다면 값이 변경되는 경우에 정합성 문제가 발생할 수 있다. (서버의 값은 바뀌었는데, 클라이언트는 안 바뀌는 문제)\n- [x] mysql 서버 타임 시간 설정\n- [x] 장바구니 상품 삭제하는 거 batch delete (step2 끝날 무렵쯤 반영)\n\t-  /cart-items DELETE 요청 -> batch delete는 주로 어떻게 Url 구성할까?\n\t- Request: \n```json\n{\n\tcartItemIds: [1, 3, 5, 7]\n}\n```\n \t     - Respose: 204 No Content\n- [x] 총 가격에서만 포인트 계산을 해줘야 한다. (배송비 제외)\n- [x] `OrderProductResponse` 내부 값을 `ProductResponse` 로 변경하기\n\n## 시나리오\n\n### 주문 저장 (POST)\n1. 입력된 멤버가 해당 장바구니의 상품의 owner와 동일한지 확인한다. (검증)\n2. 사용된 포인트가 멤버가 갖는 포인트보다 작거나 같은지 확인한다. (검증)\n3. 멤버가 사용할 포인트가 전체 상품 가격 + 배송비보다 작거나 같은지 확인한다. (검증)\n4. 멤버의 포인트를 사용한다.\n5. 멤버의 포인트를 적립한다.\n6. 선택된 장바구니 상품을 삭제한다.\n7. 주문을 저장한다.\n\n## 2단계 리뷰 도둑질\n\n- `createdAt`을 현재는 Java에서 생성해주고 있는데요.\n1. 이 부분을 Java에서 생성하는 것과, DB에서 생성하는 것은 어떠한 장/단점이 있을까요?\n2. Java에서 생성하는 방식을 선택한 이유는 무엇인가요?\n- 메서드의 이름을 지어줄 때, 각각 어떠한 기준으로 정의했는지, 그에 일관성이 있는지 궁금하네요!\n1. 어떠한 도메인의 Controller/Service/Repository일 때, 접미사로 그 어떠한 도메인을 붙여줄 것인가?\n    - ex. `orderApiController.createOrder()` vs `orderApiController.create()`\n2. 무언가를 등록할 때, 용어를 선정하는 기준은 무엇인가?\n    - ex. `create` vs `register` vs `save`\n    - ex. `get` vs `find`\n3. 조건에 대해서도 접미사로 붙여줄 것인가?\n    - ex. `get` vs `getById` / `find` vs `findById`"},{"excerpt":"5/23","fields":{"slug":"/level2-week6/"},"frontmatter":{"date":"2023년 05월 23일 01:05","title":"레벨2 6주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 5/23\n"},{"excerpt":"LOG 이상한 사람들이 많다. 잠실 가려고 항상 타던 버스를 탔는데 버스에 들어가자마자 어떤 분이 소리지르고 계셨다 ㅋㅋ 갑자기 소리지르신 분이 경찰에 신고하고 버스기사분과 승객들과 계속 말다툼을 했다. 원래는 그냥 계속 버스 타고 가려고 했는데 점점 언성이 높아지길래 일단 아무 곳에서나 내렸다. 근데 갑자기 내릴 때 그 분이 112에 전화하고 있었는데 …","fields":{"slug":"/2023-05-22/"},"frontmatter":{"date":"2023년 05월 22일 11:05","title":"2023년 05월 22일","tags":null},"rawMarkdownBody":"\n## LOG\n- 이상한 사람들이 많다. 잠실 가려고 항상 타던 버스를 탔는데 버스에 들어가자마자 어떤 분이 소리지르고 계셨다 ㅋㅋ 갑자기 소리지르신 분이 경찰에 신고하고 버스기사분과 승객들과 계속 말다툼을 했다. 원래는 그냥 계속 버스 타고 가려고 했는데 점점 언성이 높아지길래 일단 아무 곳에서나 내렸다. 근데 갑자기 내릴 때 그 분이 112에 전화하고 있었는데 '그냥 이 사람이랑 알아서 처리하세요' 이러더니 같이 내려버렸다. 그래놓고 뒤도 돌아보지 않고 골목길로 뚜벅뚜벅 사라졌다... ㅋㅋㅋㅋ 어쩌다보니 신림에서 지하철을 타게 됐는데 잡상인을 만났다. 1호선에서는 만나봤는데 2호선 잡상인은 귀해서 신기했다. 벌써 일주일간 이상한 사람 4명 정도 본 것 같은데 ㅋㅋㅋ 신기하네요...\n- 미션을 간신히? 제출했다. 1단계 리뷰를 반영 못한 채로 구현을 시작해서, 2단계 구현이 끝나고 나서 리뷰 반영을 했다. 왜 매일 미션만 했는데 시간이 부족했을까? 이상한 일이다 🤔\n- 주드, 체인저와 graceful shutdown PR을 제출했다. 사실상 주드가 다 한 feature 개발 ㅋㅋㅋ 그래도 찾아보는 과정이 되게 재밌었다. 조만간 matzip issue에 글로 정리해야겠다. 근데 submodule 적용은 언제하지.. 해야 하는 게 많아서 어떻게 시간 분배를 해야 할 지 모르겠다.\n\n## 배운 것\n- 오늘은 스터디가 있어서 [[bean-candidate|여러 개의 Bean 후보가 존재할 때 Bean을 주입받는 방법]] 에 대해 공부했다.\n- `application.yml` 을 분리할 거면 이름을 `application.yml` 로 통일해야 한다.\n```yaml\nspring:  \n  profiles:  \n    active: prod  \n---  \nspring:  \n  config:  \n    activate:  \n      on-profile: prod  \n  datasource:  \n    url: jdbc:mysql://localhost:3306/subway?useSSL=false&characterEncoding=UTF-8&serverTimezone=UTC  \n    username: root  \n    password: root  \n    driver-class-name: com.mysql.cj.jdbc.Driver  \n  sql:  \n    init:  \n      mode: always  \n      schema-locations: classpath*:schema.sql\n```\n\n```yaml\n# test/application.yml\nspring:  \n  profiles:  \n    active: test  \n---  \nspring:  \n  config:  \n    activate:  \n      on-profile: test  \n  h2:  \n    console:  \n      enabled: true  \n  \n  datasource:  \n    url: jdbc:h2:mem:testdb;MODE=MySQL  \n    driver-class-name: org.h2.Driver\n```\n\n## 궁금한 것\n\n## 어려웠던 것\n- 미션에 얼마나 많은 시간 분배를 해야 할까. 미션에 너무 집중하다보니 기술 관련 고민을 많이 하지 못했다. 미션 자체는 즐거웠지만 공부가 많이 되었는지는 잘 모르겠다.\n\n## 느낀 것\n- 데일리 때 자기 방어 기제 테스트를 해봤다. 좀 더 자세하게 알아보려고 체인저가 알려 준 서울 사이버 대학 질문지를 해봤다. 부정, 왜곡, 예견, 유머, 회피가 나왔다. 예견과 유머는 성숙한 자기 방어기제지만, 부정, 왜곡, 회피는 미성숙한 자기 방어 기제라고 한다. 그래도 좋은 게 두 개나 나왔으니 좋은 거 아닐까 싶다. 예전에는 안 좋은 것만 나왔던 거 같은데 ㅋㅋ 최근에는 좀 웃음으로 많이 승화시키려고 노력하는 것 같다.\n- 오 테스트 커버리지가 높다. 원래 이렇게 높게 나오는 건지 궁금하다 ㅋㅋㅋ\n![[test-coverage.png]]\n"},{"excerpt":"Bean의 후보가 여러 개라면? 의존성 주입을 수행할 때 bean이 여러 개라면 오류가 발생한다.\n이를 해결하기 위해 3가지 방법을 사용할 수 있다.  의 필드 이름 매칭   가장 잘 일치하는 하나의 bean을 찾을 수 없는 경우에는  이 발생한다. 사용할 클래스 정리  필드 이름 매칭 필드 이름으로 주입하는 방법이다. 먼저 필드 주입이 가능하다. 위와 …","fields":{"slug":"/bean-candidate/"},"frontmatter":{"date":"2023년 05월 22일 09:05","title":"여러 개의 Bean 후보","tags":["스터디","학습로그","spring"]},"rawMarkdownBody":"\n## Bean의 후보가 여러 개라면?\n\n의존성 주입을 수행할 때 bean이 여러 개라면 오류가 발생한다.\n이를 해결하기 위해 3가지 방법을 사용할 수 있다.\n\n- `@Autowired` 의 필드 이름 매칭\n- `@Qualifier`\n- `@Primary`\n\n가장 잘 일치하는 하나의 bean을 찾을 수 없는 경우에는 `NoUniqueBeanDefinitionException` 이 발생한다.\n\n## 사용할 클래스 정리\n\n```java\npublic interface ExtraFarePolicy {  \n    Fare calculateExtraFare(final Path path);  \n}\n```\n\n```java\n@Component  \npublic class DistanceBasedExtraFarePolicy implements ExtraFarePolicy {  \n\tpublic DistanceBasedExtraFarePolicy() {  \n\t    System.out.println(getClass());  \n\t}\n\t\n\t@Override  \n\tpublic Fare calculateExtraFare(final Path path) {  \n\t\treturn null;\n\t}\n}\n```\n\n```java\n@Component  \npublic class DummyPolicy implements ExtraFarePolicy{  \n    public DummyPolicy() {  \n        System.out.println(getClass());  \n    }  \n  \n    @Override  \n    public Fare calculateExtraFare(final Path path) {  \n        return null;  \n    }  \n}\n```\n\n```java\n@Component  \npublic class Dummy {  \n    public ExtraFarePolicy policy;  \n}\n```\n\n## `@Autowired` 필드 이름 매칭\n\n필드 이름으로 주입하는 방법이다.\n\n먼저 필드 주입이 가능하다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    private ExtraFarePolicy dummyPolicy;  \n}\n```\n\n위와 같은 코드를 작성하면, `ExtraFarePolicy` 에 들어가는 구현체는 놀랍게도 `DummyPolicy` 클래스가 된다.\n\n생성자로 주입을 받으면 매개변수 이름이 주입받는 클래스 이름이 된다. \n`distanceBasedExtraFarePolicy` 라는 이름으로 주입 받기 때문에 `DistanceBasedExtraFarePolicy` 가 `ExtraFarePolicy` 에 대입된다.\n\n```java\n@Component  \npublic class Dummy {  \n    private final ExtraFarePolicy dummyPolicy;  \n  \n    public Dummy(final ExtraFarePolicy distanceBasedExtraFarePolicy) {  \n        this.dummyPolicy = distanceBasedExtraFarePolicy;  \n        System.out.println(a.getClass());  \n    }  \n}\n```\n\n아예 구현체의 이름으로 존재하지 않는 다른 이름을 적으면 컴파일 에러가 발생한다.\n이 경우에는 Spring이 Bean을 주입할 때 여러 구현체 중에 어떤 구현체를 선택해야 할 지 모르기 때문에 컴파일 에러가 발생하게 된다. \n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    private ExtraFarePolicy extraFarePolicy;  \n}\n```\n\n그러나 이렇게 주입하는 방식은 추천하지 않는다.\nSpring이 컴파일러에게 높은 우선순위를 부여하는 구현체 기반의 주입 매커니즘과는 관련이 없는 일반적인 빈 이름 기반의 주입 매커니즘이기 때문에, 규칙을 따르는 것이 더 명확하고 안전하다.\n\n## `@Qualifier`\n\nSpring 컨테이너가 동일한 유형의 bean을 여러 개 찾았을 때, 모호함을 해결하기 위해 추가적으로 판단할 수 있는 정보를 제공한다. 주의할 점은 등록되는 bean의 이름을 바꾸는 것이 아닌, 구분자를 추가하는 형식이라는 점이다.\n\n**특징**\n- 메서드, 필드, 생성자 매개변수에 사용할 수 있다.\n- `@Autowired` 와 함께 사용해야 한다.\n\n`@Qualifier` 를 생성자 매개변수에 달아줄 수 있다.\n이런 경우에는 생성자 매개변수 이름이 다른 구현체 이름이더라도 정확하게 해당 bean을 등록하게 된다.\n\n```java\n@Component  \npublic class Dummy {  \n    private ExtraFarePolicy dummyPolicy;  \n  \n    public Dummy(@Qualifier(\"distanceBasedExtraFarePolicy\") final ExtraFarePolicy dummyPolicy) {  \n        this.dummyPolicy = dummyPolicy;  \n        System.out.println(\"dummy\" + dummyPolicy.getClass());  // dummyclass subway.domain.fare.DistanceBasedExtraFarePolicy\n\n    }  \n}\n```\n\n필드 주입을 사용하려면 다음과 같이 사용하면 된다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    @Qualifier(\"distanceBasedExtraFarePolicy\")  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n존재하지 않는 `@Qualifier` 를 사용하면 `NoSuchBeanDefinitionException` 이 발생한다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    @Qualifier(\"strangePolicy\")  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n```\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'subway.domain.fare.ExtraFarePolicy' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true), @org.springframework.beans.factory.annotation.Qualifier(value=\"strangePolicy\")}\n```\n\n## `@Primary`\n\n```java\n@Primary  \n@Component  \npublic class DummyPolicy implements ExtraFarePolicy {  \n    public DummyPolicy() {  \n        System.out.println(getClass());  \n    }  \n  \n    @Override  \n    public Fare calculateExtraFare(final Path path) {  \n        return null;  \n    }  \n}\n```\n\n우선순위를 주고 싶은 bean의 클래스 상단에 적어주면 된다.\n\n`@Primary` 어노테이션이 여러 개 존재하는 경우에는 `NoUniqueBeanDefinitionException` 이 발생한다.\n\n```\nCaused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'subway.domain.fare.ExtraFarePolicy' available: more than one 'primary' bean found among candidates: [distanceBasedExtraFarePolicy, dummyPolicy]\n```\n\n## `@Resource` ?\n\n`@Resource` 어노테이션은 필드 타입으로 bean을 찾는 `@Autowired`와 달리 bean의 이름으로 bean을 주입한다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Resource  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n해당 코드에서는 `DummyPolicy` 를 주입받게 된다.\n\n## 우선 순위\n\n`@Qualifier` 와 `@Primary` 어노테이션이 모두 존재하는 경우, `@Qualifier` 가 우선된다.\n\n```java\n@Qualifier(\"dummyPolicy\")  \n@Component  \npublic class DummyPolicy implements ExtraFarePolicy{  \n    \n}\n```\n\n```java\n@Primary  \n@Component  \npublic class DistanceBasedExtraFarePolicy implements ExtraFarePolicy {\n}\n```\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    @Qualifier(\"dummyPolicy\")  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n이런 경우에는 `Dummy` 의 `ExtraFarePolicy` 에는 `DummyPolicy` 가 주입되게 된다."},{"excerpt":"LOG matzip aws 계정 생성 드디어 했다 ㅋㅋ 나 왜 이렇게 시간이 없을까... 뭔가 해야 할 일이 많이 쌓여있는데 해결이 안 되고 쌓이기만 하는 느낌이다. 계정 생성 그거 별거 아닌데도 엄청 오래걸리고. 얼른 미션을 마무리하고 matzip 이슈 해결도 하고 오리가 맡겨주신 application.yml 설정도 완료해야겠다. 즐선생님, 헙크와 같이…","fields":{"slug":"/2023-05-21/"},"frontmatter":{"date":"2023년 05월 21일 16:05","title":"2023년 05월 21일","tags":null},"rawMarkdownBody":"\n## LOG\n- matzip aws 계정 생성 드디어 했다 ㅋㅋ 나 왜 이렇게 시간이 없을까... 뭔가 해야 할 일이 많이 쌓여있는데 해결이 안 되고 쌓이기만 하는 느낌이다. 계정 생성 그거 별거 아닌데도 엄청 오래걸리고. 얼른 미션을 마무리하고 matzip 이슈 해결도 하고 오리가 맡겨주신 application.yml 설정도 완료해야겠다.\n- 즐선생님, 헙크와 같이 페어가 된 걸 확인했다. 포이가 즐선생님 칭찬을 많이 해서 나도 같이 페어 해보고 싶다고 생각하던 차였는데 포이와 페어 교환했다 ㅋㅋㅋ 포이는 토리와 페어 ~ 역시 페어는 돌고 돈다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 나의 감정을 돌아보고, 솔직하게 표현하는 것이 어렵다. \n- 블로그 글을 열심히 쓰지 못하고 있다 😂 TIL은 그날 저녁에 계속 올려야 하는데 많이 밀리고 있고 ㅋㅋ 이번 미션이 어려워서 그런지 미션에 많이 집중하느라 블로그 포스팅에 소홀했다. 앞으로 노력하겠습니다~\n\n## 느낀 것\n- 오늘 TIL에 쓸 내용은 아니긴 하지만 ㅋㅋㅋ 레벨2 글쓰기로 썼던 주제 의외로 마음에 들어서 좋았다. 원래는 '나는 왜 살고 삶의 목표는 무엇인가'라는 무거운 주제라 시작하기 어려웠는데, 내가 자신있는 주제로 쓰다보니 훨씬 글이 잘 나오는 것 같다.\n- 계속해서 고민하고 있는 주제. '나는 어디까지 솔직해질 수 있는가?' 나는 솔직하지 못한 사람인데, 솔직하지 못한 사람을 좋아하지는 않는다. 역설적이다 ㅋㅋ 내가 느꼈던 것, 생각하는 것, 서운한 것, 슬픈 것, 기쁜 것 ... 여러 생각들을 하는데도 정말로 솔직하게 말하는 것은 요즘따라 몇 안 되는 기분이 든다. 문제는 좋은 것도 제대로 말 못한다는 것에 있다. 칭찬에 인색하지 말고, 감사에 인색하지 말아야 하는데 말은 그렇게 하면서도 지키기 어렵다. 솔직하게 내 생각을 이야기하는 것에 더 익숙해지기 위해 노력해야겠다. 오늘도 두 번의 노력을 해보았는데, 생각보다 큰 용기가 필요해서 내가 이만큼 솔직하지 못한 사람이라는 것만 알게 되었다 ㅋㅋ 어쨌든 앞으로도 노력해보자."},{"excerpt":"LOG 코엑스에 가서 가디언즈 오브 갤럭시를 봤다. 원래 좋아하던 영화였는데 왠지 이번이 마지막인 것처럼 영화가 끝나서 조금 아쉬웠다. 로켓의 과거가 좀 슬펐다. 솔라가 가오갤 팬이면 안 보면 후회한다고 한 말이 무슨 말인지 어렴풋이 느꼈다. 이제서야 미션 구현을 시작했다. 조금 많이 늦은 감이 있지만, 어쨌든 제출은 빨리 해야 한다... 배운 것 는 테…","fields":{"slug":"/2023-05-20/"},"frontmatter":{"date":"2023년 05월 20일 02:05","title":"2023년 05월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 코엑스에 가서 가디언즈 오브 갤럭시를 봤다. 원래 좋아하던 영화였는데 왠지 이번이 마지막인 것처럼 영화가 끝나서 조금 아쉬웠다. 로켓의 과거가 좀 슬펐다. 솔라가 가오갤 팬이면 안 보면 후회한다고 한 말이 무슨 말인지 어렴풋이 느꼈다.\n- 이제서야 미션 구현을 시작했다. 조금 많이 늦은 감이 있지만, 어쨌든 제출은 빨리 해야 한다...\n\n## 배운 것\n- `@ActiveProfiles`는 테스트 코드에서만 사용 가능하다.\n- `build.gradle` 을 수정할 때 깃허브 메시지는 `chore`를 사용한다.\n- stream의 결과가 `List<List<>>` 형태일 때 flat하게 `List<>`로 만들고 싶은 경우 `flatMap(List::stream)` 을 사용하면 된다.\n```java\n// List<Line> lines가 주어짐\n\nlines.stream()  \n        .map(Line::getSectionsByList)  \n        .flatMap(List::stream)  \n        .collect(Collectors.toList());\n```\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 요즘 니체의 생각이 좋다. 처음에는 니체 철학은 허무주의 아닌가? 해서 접하게 되었는데, 알아가다 보니 니체가 말하고 싶었던 것은 삶을 사랑하라는 것이다. '바람직한 죽음'에 관한 관점도 좋다. 주체적으로 죽음을 택하는 것, 즉 내가 어떻게 살아가야 하는지가 중요하다고 생각하는 것이다. 나에게 죽음은 두려운 것이 아니지만 나는 솔직한 사람이 아니다. 하루하루를 언제나 만족스럽게 보내고 있는 것도 아니다. 최선을 다해 내 마음을 돌아보고 솔직한 방향으로 나아가려고 하지만 항상 잘 되는 것만은 아니다. 그래서 요즘은 에라 모르겠다식 결정보다는 내 마음을 다시 돌아보고 솔직하게 선택하려고 노력하는 중이다. 계속 노력하다보면 살아가면서 솔직한 결정을 더 잘할 수 있지 않을까?\n- 새싹교실이 끝나간다. 드디어 상속까지 진행했다. 그런데 하고 싶은 말은 많은데 수업이 한 시간 밖에 안 남아서 좀 아쉽다. 새싹들이 어디까지 알고 있을지 궁금하다. 예전에 수업할 때보다 더 잘 가르치는 것 같기는 해서 뿌듯하다."},{"excerpt":"신나게 사는 법 저는 우테코에서 신나게 사는 사람 중 하나라고 자부합니다. (신나게 사는 사람 배틀은 언제나 환영입니다.)\n여러분도 신나게 살고 싶으시다면 제 글을 읽고 한 번 따라 해 보세요 ˙ᵕ˙ 긍정적으로 생각하기 저는 굉장히 부정적인 사람입니다. 어떤 상황이 주어졌을 때 항상 최악을 가장 먼저 생각합니다. 가장 안 좋은 일을 미리 대비해야 마음의 …","fields":{"slug":"/level2-writing/"},"frontmatter":{"date":"2023년 05월 18일 06:05","title":"레벨2 글쓰기","tags":["레벨2","우테코","글쓰기"]},"rawMarkdownBody":"\n# 신나게 사는 법\n\n저는 우테코에서 신나게 사는 사람 중 하나라고 자부합니다. (신나게 사는 사람 배틀은 언제나 환영입니다.)\n여러분도 신나게 살고 싶으시다면 제 글을 읽고 한 번 따라 해 보세요 ˙ᵕ˙\n\n## 긍정적으로 생각하기\n\n저는 굉장히 부정적인 사람입니다. 어떤 상황이 주어졌을 때 항상 최악을 가장 먼저 생각합니다. 가장 안 좋은 일을 미리 대비해야 마음의 준비를 할 시간이 있기 때문입니다. \n\n그런데 그렇게 살다 보니까 언제나 안 좋은 점만 보였습니다.\n우테코를 신청하기 전에도 먼저 부정적인 생각부터 들었습니다.\n\n`떨어지면 어떡하지?`\n`떨어질 것 같은데 그냥 시험공부나 하는 게 좋지 않을까?`\n`잘하지도 못하는데 붙을 수 있을까?`\n\n무수히 많은 부정적인 생각을 했습니다. 생각하다 보니 우테코에 지원하지 않아야 할 이유만 계속해서 꼬리를 물었습니다.\n\n그렇지만 에라 모르겠다 하고 신청을 넣어서 제가 지금 우테코에 있는 거겠죠?\n곰곰이 생각해 보면 잘 된 경험은 준비 없이 뭐라도 시작하고 나서 생각한 일이 잘됐습니다. 먼저 안 좋은 생각부터 할 이유가 없는 거죠.\n특히 시도해 보지 않고 안 좋은 생각을 하면 더 과장되게 생각하게 됩니다.     \n\n그러니 일단 잘될 거라고 생각하고 해봅시다. 앞으로 어떻게든 되겠죠!     \n잘 되면 좋은 거고, 안 되면 어떤가요. 어차피 인생은 많이 남았습니다. 👍\n\n## 많이 웃기\n\n웃으면 복이 온다는 진부한 내용은 아니니 계속 읽어주세요.   \n전 원래 웃음이 많은 사람입니다. 이제 겨우 23년 살았지만, 동 나이대 사람 중에 제가 제일 많이 웃었을 것 같으니 저는 웃음 전문가라고 할 수 있겠습니다.     \n웃는 걸 노력해 본 적은 없지만, 대충 생각해 봤을 때 저는 확실히 하루에 4시간 정도는 웃습니다. 매우 많네요.    \n\n웃다 보면 제가 웃는 것에 웃겨서 더 웃게 됩니다.     \n그러면 가끔 옆에 있는 사람이 제가 웃는 걸 보고 웃습니다. 주로 '너는 이런 걸로 또 웃니?' 라는 느낌이기는 합니다.   \n확실히 생각해 봤을 때, 다른 사람이 웃는 걸 보면 기분이 좋습니다.    \n저의 웃음이 다른 사람에게 감정적으로 긍정적 영향을 줄 수 있다는 것이 기쁩니다.    \n\n여러분도 일단 아무렇게나 웃어보시는 건 어떨까요.    \n실소도 좋고, 억지 미소도 좋고, 갑자기 뜬금없이 웃어도 좋습니다.     \n복은 안 와도, 주변 사람들과 함께 행복해지면 그것 자체로 좋은 것 아닐까요?     \n이 글을 보고 여러분이 웃게 된다면 제가 행복해질 것 같네요. 웃어주세요. 😊     \n\n## 사소한 것에서 즐거움 찾기\n\n'재밌는' 하루를 보내는 것은 어렵습니다. 반복되는 일상, 어려운 공부, 미래에 대한 걱정 ... 많은 사람이 다양한 주제의 걱정으로 하루를 살아갑니다.    \n\n그런데도 하루에 '즐거운' 일은 있습니다. 막 재밌는 게 아니어도 좋습니다.     \n점심으로 먹었던 밥이 맛있었다든지, 친구가 웃긴 농담을 했다든지, 10분 더 집중했다든지 같은 사소한 일들을 생각해 봅시다.      \n오히려 사소하고 당연한 즐거운 일을 자각하기가 어렵습니다.      \n우리는 오늘 '무엇을 해냈다'에 집중하느라 오늘 있었던 '즐거운 일'에는 관심을 덜 쏟는 경향이 있습니다.      \n\n대부분 사람의 목표는 행복일 것으로 생각합니다.     \n그렇지만 행복이 거창한 건 아닙니다. 거창한 행복을 바랄수록 평범한 현실을 자각하면 오히려 불행해집니다.      \n주변에는 의외로 감사한 일, 즐거운 일이 많습니다.     \n\n큰 행복을 향해 뛰는 것도 좋지만, 가끔은 잠시 멈춰 오늘의 소소한 행복을 발견해 봅시다.     \n과거의 작은 행복이 모이다 보면 힘들 때 뒤를 돌아봤을 때 큰 위로가 되더라고요. \n\n생각보다 그렇게 어렵지 않죠? 여러분도 신나는 삶에 도전해 보세요 💪"},{"excerpt":"LOG 토리 테코톡이 있어서 아침에 연습하는 거 들었다. 엄청 걱정하더니 테코톡 때는 안 떨고 잘 말해서 대단했다 👏 질문 나온 것들도 잘 대답해서 멋졌다. 역시 토리가 최고다~ 배운 것 jar, war 파일 프로젝트의 내용을 압축해서 담아놓은 파일. 컴퓨터가 읽을 수 있는 형태의 파일을 전달하기 위해 만든다. (plain) jar : 자바 프로젝트를 압…","fields":{"slug":"/2023-05-18/"},"frontmatter":{"date":"2023년 05월 18일 05:05","title":"2023년 05월 18일","tags":null},"rawMarkdownBody":"\n## LOG\n- 토리 테코톡이 있어서 아침에 연습하는 거 들었다. 엄청 걱정하더니 테코톡 때는 안 떨고 잘 말해서 대단했다 👏 질문 나온 것들도 잘 대답해서 멋졌다. 역시 토리가 최고다~\n\n## 배운 것\n### jar, war 파일\n프로젝트의 내용을 압축해서 담아놓은 파일. 컴퓨터가 읽을 수 있는 형태의 파일을 전달하기 위해 만든다. \n- (plain) jar : 자바 프로젝트를 압축한 파일. 외부 라이브러리가 포함되지 않는다. 다른 프로젝트에 종속성으로 사용될 때, 로컬 환경에서 실행되는 애플리케이션으로 사용한다. \n- (Runnable) jar : 웹 애플리케이션이 의존하는 라이브러리나 외부 모듈 등을 포함한다. 내장 톰캣을 포함하여 웹 프로젝트를 압축한 파일. 외부 웹서버 없이 웹 애플리케이션을 단독 실행할 수 있다.\n\t- war : 웹 프로젝트를 압축한 파일. 해당 파일을 실행하려면 WAS가 필요하다. 웹 애플리케이션을 통째로 패키징하고 배포하기 위해 사용한다.\n\t- 스프링 부트에서 빌드하는 표준형식은 jar -> 그러나 내장된 서블릿 컨테이너는 JSP를 실행할 수 없다.\n\t- war는 jsp를 사용해서 화면을 구성하거나, 외장 WAS를 사용하게 된다면 사용하는 것이 좋다.\n\n### 배포\n#### 서버 환경 구축\n- 어떤 서버를 사용하느냐, 어떤 파일을 업로드 하냐에 따라 달라진다. \n\n#### nohup, &\nnohup : 터미널이 종료된 후에도 프로그램이 실행해야 할 때\n& : 사용자가 터미널을 다른 작업에 사용해야 할 때 (멀티 태스킹)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"LOG 배운 것  의 를 사용할 때 주의할 점 : as 내부에 DTO가 존재하고 DTO의 매개변수가 1개라면 꼭 기본 생성자가 필요하다. (Response용으로 사용되더라도!) 일관성을 위해 모든 DTO에 기본 생성자를 달아주자.","fields":{"slug":"/2023-05-17/"},"frontmatter":{"date":"2023년 05월 17일 04:05","title":"2023년 05월 17일","tags":null},"rawMarkdownBody":"## LOG\n\n## 배운 것\n- `RestAssured` 의 `as`를 사용할 때 주의할 점 : as 내부에 DTO가 존재하고 DTO의 매개변수가 1개라면 꼭 기본 생성자가 필요하다. (Response용으로 사용되더라도!) 일관성을 위해 모든 DTO에 기본 생성자를 달아주자.\n```java\nExtractableResponse<Response> response = RestAssured  \n        .given().log().all()  \n        .accept(MediaType.APPLICATION_JSON_VALUE)  \n        .when().get(\"/lines/{노선_ID}\", 노선_ID)  \n        .then().log().all()  \n        .extract();  \n        \nLineResponse lineResponse = response.as(LineResponse.class);\n```\n"},{"excerpt":"5/16 피드백 DTO는 어디에? DTO는 어느 레이어에 속하게 하는 게 좋을까? -> 나는 서비스라고 생각한다. 우르와 페어할 때 DTO가 컨트롤러 레이어에 두게 되면 하위 계층인 서비스에서 상위 계층인 DTO를 참조하게 되는 역류 참조가 발생하므로 서비스에 사용하는 것이 좋다고 생각한다. 이 의견은 DTO가 서비스에서 사용된다는 가정하에 있는 것이기는…","fields":{"slug":"/level2-week5/"},"frontmatter":{"date":"2023년 05월 16일 01:05","title":"레벨2 5주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 5/16\n\n## 피드백\n\n### DTO는 어디에?\n- DTO는 어느 레이어에 속하게 하는 게 좋을까? -> 나는 서비스라고 생각한다. 우르와 페어할 때 DTO가 컨트롤러 레이어에 두게 되면 하위 계층인 서비스에서 상위 계층인 DTO를 참조하게 되는 역류 참조가 발생하므로 서비스에 사용하는 것이 좋다고 생각한다. 이 의견은 DTO가 서비스에서 사용된다는 가정하에 있는 것이기는 하다. 만약 서비스에서 사용하는 DTO가 따로 있다면 기존 DTO는 컨트롤러 레이어, 서비스로 값이 전달될 때 사용하는 DTO를 서비스 레이어에 둘 것 같다. \n\n### 단위 테스트 중복?\n- 레이어별로 만들어놓은 단위 테스트가 같은 기능을 검증하고 있는 것 같다. 컨트롤러 테스트에서 세부적인 비즈니스 규칙을 모두 검증할 필요가 있을까? \n-> 검증하고자 하는 대상이 무엇인지에 집중한다.\n\n컨트롤러의 역할은 요청을 받고 응답을 하는 것이다. \n비즈니스 규칙의 일부는 검증될 수 있을지언정 컨트롤러의 역할을 검증하는 것이 목표가 되어야 한다. 즉, 컨트롤러 테스트에서는 비즈니스 규칙을 테스트할 필요는 없다고 생각한다.\n\n**테스트 피라미드**\n![[test_pyramid.jpg]]\n\n### 테스트에서만 사용되는 프로덕션 코드?\n\n테스트만을 위한 프로덕션 코드는 지양하되, 과하게 사용하는 것이 아니라면 제한적으로 허용하자.\n\nEx. 적절한 생성자가 없는 경우 테스트를 위한 생성자를 추가하는 방법\n\nbut, 테스트를 짜기 쉬운 코드를 만드는 것에 좀 더 집중하자.\n\n## Spring JDBC with Datasource\n\n### Datasource\n연결 설정, 쿼리 실행, 트랜잭션 관리에 필요한 메서드들을 인터페이스로 제공하는 틀\n애플리케이션과 기본 데이터베이스 사이의 브리지 역할을 한다.\n\n### Datasource로 설정할 수 있는 것들\n- url\n- driver class\n- user name & password\n- connection pool 설정\n\n### Profile\n선택적으로 Spring Context를 구성하고, 선택적으로 활성화할 수 있다.\n다양한 배포 시나리오에 따라서 변경할 수 있다.\n\n`@Profile` 로 설정할 수 있다.\n\napplication-prod.properties와 application-test.propterties 중에 누가 우선순위가 높을까?\n\n# 5/19\n\n## ATDD\n\n요구사항을 검증하는 테스트로 소프트웨어를 개발하는 프로세스\n-> 인수테스트로 소프트웨어를 개발하는 프로세스\n\n## ATDD를 하는 이유\n\n### 생산성 증가\n구현 전에 인수 테스트를 수행하는 경우, 팀의 생산성이 두 배가 되었다.\n-> 작업의 명확한 시작과 끝을 제시한다.\n-> 빠른 피드백이 가능하다. \n-> 귀찮은 작업을 프로세스로 강제한다.\n\n### Acceptance Test\n- 사용자 스토리를 검증하는 기능 검증 테스트\n- 소프트웨어 이외 다른 분야에서도 사용되는 용어\n- 보통 마지막 단계에서 수행하는 테스트를 의미\n\n### 테스트 종류\n- 단위 테스트\n- 통합 테스트\n- E2E 테스트\n- 인수 테스트 : 사용자 스토리를 검증하는 기능 테스트\n\n### 인수테스트?\n- 인수 테스트는 API 테스트? E2E 테스트? 통합 테스트?\n\n인수테스트는 테스트 의도에 따라 정해지는 것이지 어떻게 구현하는지에 따라 정해지는 것이 아니다. (단위 테스트가 될 수도 있다?)\n\n### 이번 특강에서 말하는 인수 테스트\n- 백엔드 개발자가 단독적으로 적용해서 실천해볼 수 있는 범위\n- 고객은 프론트엔드 개발자 혹은 API 활용하는 사람 대상\n- API 접점에서 검증하는 E2E 테스트\n- API 의 Request와 Response 정보 이외 내부 정보는 최대한 가리는 블랙 박스 형식의 테스트\n\n## 인수 테스트 만들기\n\n### 만들기 전에 알아야 할 것\n- 블랙박스 테스트 : 인수 테스트는 블랙 박스 테스트의 성격을 가지고 있다. 내부 동작의 구현보다는 시나리오가 잘 동작하는지 확인한다.\n- 블랙박스?\n\t- 클라이언트는 표먼적으로 확인할 수 있는 요소를 바탕으로 검증한다.\n\t- 실제 사용하는 상황의 시나리오를 바탕으로 요구사항을 작성한다.\n\t- 내부 구현이나 기술에 의존적이지 않는 블랙 박스 테스트\n- E2E 테스트 : 종단간 테스트. API 레벨의 블랙박스 테스트이므로 요청과 응답 기준으로 API 레벨의 E2E 테스트로 검증한다.\n\n### 인수 테스트 도구 설명\n\n- SpringBootTest\n\t- ApplicationContext를 쉽게 지정하게 도와준다.\n\t- 기존 `@ContextConfiguration` 의 발전된 기능\n- webEnvironment\n\t- MOCK, RANDOM_PORT, DEFINED_PORT, NONE(웹 요청을 안 받는)\n- MockMvc\n\n## 인수 테스트 격리\n\n`@DirtiesContext` 를 사용하면 컨텍스트를 테스트마다 계속해서 생성한다. 캐시 기능을 사용하지 않게 설정하면 매번 Context를 새로 구성하다보니 시간이 많이 걸린다.\n\n설정이 같으면 캐싱된 컨텍스트를 재사용한다. (MockBean을 사용하는 경우)\n\nDatabaseCleanup : EntityManager를 활용하여 테이블 이름 조회 후 각 테이블 Truncate 수행. ID auto-increment 숫자를 1로 복구시킨다.\n\n## 인수 조건\n- 인수 테스트가 충족해야 하는 조건\n- 이번 과정에서는 시나리오 형태로 표현\n\n## 인수 테스트에서 TDD로 넘어가기\n\n인수 조건을 세우고 -> 이를 검증하는 인수테스트를 만들고 -> 인수테스트를 만족시키는 기능을 구현해도 인정\n\n컨트롤러부터 도메인 방향 -> outside in\n도메인에서 컨트롤러 방향 -> inside out\n왔다갔다 해도 좋지만 잘 아는 것을 기반으로 모르는 방향으로 진행할 것"},{"excerpt":"LOG 오늘도 지하철 타고 가는데 30초에 한 번 문 쪽을 쳐다보는 아저씨가 계셨다. 나중 가니까 문을 보는지 나를 보는지 모르겠어서 자리를 옮겼는데 갑자기 근처로 오셔서 ㅋㅋㅋ 옆 칸으로 도망갔다. 아무 일도 일어나지 않았고 진짜 나를 본 것도 아니겠지만 그냥 피하는 게 맞았던 것 같다. 체인저, 주드와 함께 오늘도 matzip 이슈 보는 시간을 가졌다…","fields":{"slug":"/2023-05-16/"},"frontmatter":{"date":"2023년 05월 16일 01:05","title":"2023년 05월 16일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘도 지하철 타고 가는데 30초에 한 번 문 쪽을 쳐다보는 아저씨가 계셨다. 나중 가니까 문을 보는지 나를 보는지 모르겠어서 자리를 옮겼는데 갑자기 근처로 오셔서 ㅋㅋㅋ 옆 칸으로 도망갔다. 아무 일도 일어나지 않았고 진짜 나를 본 것도 아니겠지만 그냥 피하는 게 맞았던 것 같다.\n- 체인저, 주드와 함께 오늘도 matzip 이슈 보는 시간을 가졌다. 후니가 `ApplicationEvent` 를 사용해서 asyncExecutor가 종료되기를 기다리고 + 일정 시간 뒤에 종료하라는 힌트를 더 주셔서 같이 찾아봤다. 찾아보니 `ThreadPoolTaskExecutor` 의 속성 중에 `setWaitForTasksToCompleteOnShutdown` 을 설정하면 모든 진행중인 작업이 끝날 때까지 기다리고, `setAwaitTerminationMillis` 를 설정해주면 종료되기까지 최대 몇 밀리초를 기다릴지 설정할 수 있다. 주드 말로는 비동기 스레드는 graceful shutdown을 해주지 않아도 잘 종료되는데 동기 스레드는 graceful shutdown을 해야 한다고 한다. 내일 가서 좀 더 설명을 들어야겠다. \n- 포이와 체인저 집에 가서 밥을 먹었다 ㅋㅋㅋ 집 가기 전에 체인저가 제육 먹는다고 하고 같이 먹을래? 라고 말하길래 장난인줄 알았더니 진짜 가게 돼서 당황스러웠다 ㅋㅋㅋㅋ 근데 체인저 제육 폼 미쳤다.. 닭강정까지 같이 사서 먹었는데 양이 많았다. 체인저랑 포이는 그렇게 생각 안 한 것 같지만 ㅋㅋㅋ\n\n## 배운 것\n- 복합키를 구성하는 값은 NULL일 수 없다. 기본 키는 행을 고유하게 식별하는 데 사용한다. 그런데 NULL값이 존재하게 되면 비교가 되지 않는다. (NULL = NULL 비교는 실패한다) 따라서 NULL 이 포함된 열은 복합키가 될 수 없다.\n- 애그리거뜨 루뜨에 대한 설명을 누누한테 들었는데 다시 정리하자니 어렵네... 내일 누누한테 다시 물어봐야겠다.\n\n## 궁금한 것\n- 도대체 헥사고날이 뭘까 ㅋㅋ 누누 등장해서 알려줘\n\n## 어려웠던 것\n\n## 느낀 것\n- 요즘 공부 많이 해서 기분은 좋은데 중간에 안 쉬니까 머리가 너무 아프다 ㅋㅋ 막판에 가면 아무것도 집중 안 되는 상태가 되는데, 공부 하다가도 중간에 쉬는 시간이 필요한 것 같다. 4시간 - 5시간을 한 번에 집중하는 건 역시 어렵군..\n- 세상에 웃긴 게 너무 많다 ㅋㅋㅋ 그냥 별 것도 아닌데 특정 말을 듣기만 하면 너무 기분이 좋아진다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ 왕주먹 랄프.. 까만 이우진...ㅋㅋㅋㅋㅋㅋㅋㅋ"},{"excerpt":"cloudfront의 image 링크를 열면 이미지 열기가 아니라 파일을 다운로드하는 문제 MIME 유형을 지정해 주지 않아 발생한 문제였다. -> mime 로컬 환경에서 로컬 프로필이 적용되지 않는 문제 여러 개의 active가 설정되어 있어 발생한 문제였다. -> Spring Profile 적용 순서","fields":{"slug":"/matzip-issue/"},"frontmatter":{"date":"2023년 05월 15일 07:05","title":"matzip에서 발생한 issue 정리","tags":["우테코","matzip","issue"]},"rawMarkdownBody":"\n## cloudfront의 image 링크를 열면 이미지 열기가 아니라 파일을 다운로드하는 문제\n\nMIME 유형을 지정해 주지 않아 발생한 문제였다. -> [[mime]]\n\n## 로컬 환경에서 로컬 프로필이 적용되지 않는 문제\n\n여러 개의 active가 설정되어 있어 발생한 문제였다. -> [[spring-multi-profile-issue|Spring Profile 적용 순서]]"},{"excerpt":"matzip-issue matzip 페어 기록 matzip-feature-develop","fields":{"slug":"/matzip/"},"frontmatter":{"date":"2023년 05월 15일 07:05","title":"matzip 개발기","tags":["우테코","matzip"]},"rawMarkdownBody":"- [[matzip-issue]]\n- [[matzip_pair|matzip 페어 기록]]\n- [[matzip-feature-develop]]\n"},{"excerpt":"LOG 스터디 주제 공부하기, matzip 이슈 공부하기, 저녁에는 지하철 리뷰 반영하기 해서 내내 공부했다. 그러고 나니까 머리가 어지럽다 ㅋㅋㅋ 집에 갈 때쯤에 말해보카를 했는데 똑같은 문장 4번 틀려서 확실히 뇌 자원을 다썼구나.. 라는 생각이 들었다. 그래도 열심히 공부했으니 뿌듯하다~ 오늘 지하철에서 이상한 아저씨를 만났다ㅋㅋㅋ 냅다 나보고 휴먼…","fields":{"slug":"/2023-05-15/"},"frontmatter":{"date":"2023년 05월 15일 05:05","title":"2023년 05월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 스터디 주제 공부하기, matzip 이슈 공부하기, 저녁에는 지하철 리뷰 반영하기 해서 내내 공부했다. 그러고 나니까 머리가 어지럽다 ㅋㅋㅋ 집에 갈 때쯤에 말해보카를 했는데 똑같은 문장 4번 틀려서 확실히 뇌 자원을 다썼구나.. 라는 생각이 들었다. 그래도 열심히 공부했으니 뿌듯하다~\n- 오늘 지하철에서 이상한 아저씨를 만났다ㅋㅋㅋ 냅다 나보고 휴먼이라고 하는 아저씨... 솔직히 뭐라고 하시는지 대부분은 못 알아먹었다 ㅋㅋ 처음엔 좀 거리가 있었는데 점점 가리키는 손이 가까워져서 다른 칸으로 이동해서 집에 갔다. 가끔 이런 이슈가 발생할 때가 있는데 역시 아무렇지 않은 것처럼 행동하는 게 나은 거 같다.\n- matzip issue를 후니에게 전달 받아서 공부해봤는데, graceful shutdown이라는 키워드를 알게 되었다. 1시간의 짧은 시간이었지만, GracefulShutdown 코드 내부를 살펴볼 수 있었다. 운영체제 때 이런 내용은 안 배웠는데;; 우리 학교는 대체 무엇을 가르치는가.. 어쨌든 이슈 해결을 해야 되니까 좀 더 공부를 해봐야겠다.\n- 말랑이 아침에 내 출입증을 빌려가서 가져가버렸다 ㅋㅋㅋ 나는 내일 들어갈 수 있을까... 역시 괴도 말랑\n\n## 배운 것\n- 스프링 부트 버전 3부터는 패키지명에서 Java를 모두 없애고 jakarta로 바꾸었다. mysql이 8.0.31 버전부터 자신들의 네이밍 가이드라인에 맞춰 groupid, artifactid를 바꾸어서 이제 `runtimeOnly 'com.mysql:mysql-connector-j'`를 사용해야 한다.\n- 오늘 스터디가 있어서 스터디 주제를 공부했다: [[vepohuhemal-study-question|5월 15일]]\n\n## 궁금한 것\n- 면접 보면서 `ProxyMode`라는 말이 나왔는데 사실 아직도 무슨 말인지 잘 이해를 못했다 ㅋㅋㅋ 내일 시간 나면 좀 더 알아봐야겠다.\n\n## 어려웠던 것\n- 하는 일이 잘 안 풀릴 때에도 긍정적인 마음을 유지하자. 저녁에 리팩토링이 잘 안 되고 해낸 게 없는 것 같아서 평소처럼 기분을 유지하기 어려웠다. 기분이 태도가 되지 않도록 하자.\n\n## 느낀 것\n- 요즘 마음이 평온하다. 말을 할 때에도 차분하게 말할 수 있고 (안 웃는다는 건 아니고) 일이 잘 안 풀리더라도 그냥 그럴 수 있지 라는 마인드로 살아가고 있다. 지금의 내 감정이 왔다갔다 하지 않아서 좋다. 특히 안 좋은 감정이 드는 걸 내 머릿속에서 의도적으로 배제하는 것 같아서 안 좋은 감정을 못 느끼고 있는 거 같다. 오히려 좋아\n- 공부를 하면 에너지가 많이 소모된다. 아무래도 오늘은 공부를 많이 한 날이라 집에 왔더니 그냥 누워버릴 수밖에 없었다..ㅋㅋㅋ 딴 짓 안 하고 그냥 누워있기만 하니까 오히려 좋은 거 같기도 하고. 긍정적으로 생각하자."},{"excerpt":"LOG 한강에 놀러 갔다. 제이슨이 올려주신 글을 보니까 재밌을 것 같아서 갔다. 뚜벅뚜벅 축제를 하고 있어서 열심히 걸었다. 웬 물이 뿜어져 나오는 잠수교가 있었는데, 노래가 바뀔 때마다 물이 뿌려지는 게 달라져서 신기했다. 배운 것  : Foreign Key의 제약 조건을 끄고 하위 명령어들을 실행할 수 있게 해준다.  : Foreign Key의 제약…","fields":{"slug":"/2023-05-14/"},"frontmatter":{"date":"2023년 05월 14일 09:05","title":"2023년 05월 14일","tags":null},"rawMarkdownBody":"## LOG\n- 한강에 놀러 갔다. 제이슨이 올려주신 글을 보니까 재밌을 것 같아서 갔다. 뚜벅뚜벅 축제를 하고 있어서 열심히 걸었다. 웬 물이 뿜어져 나오는 잠수교가 있었는데, 노래가 바뀔 때마다 물이 뿌려지는 게 달라져서 신기했다.\n\n## 배운 것\n- `SET foreign_key_checks = 0` : Foreign Key의 제약 조건을 끄고 하위 명령어들을 실행할 수 있게 해준다. \n- `SET foreign_key_checks = 1` : Foreign Key의 제약 조건 켜기 - 출처 https://iambeginnerdeveloper.tistory.com/84\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"2단계 리뷰 혹시 Index를 걸면 좋을만한 것들을 고민해보셨을까요? index란 추가적인 쓰기 작업과 저장공간을 활용하여 DB 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 조회 뿐만 아니라 update, delete의 성능이 함께 향상된다. create, delete, update가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져 성능…","fields":{"slug":"/level2-cart/"},"frontmatter":{"date":"2023년 05월 14일 05:05","title":"레벨2 장바구니 미션","tags":["레벨2","미션","우테코"]},"rawMarkdownBody":"## 2단계 리뷰\n\n- 혹시 Index를 걸면 좋을만한 것들을 고민해보셨을까요?\n\t- index란 추가적인 쓰기 작업과 저장공간을 활용하여 DB 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 조회 뿐만 아니라 update, delete의 성능이 함께 향상된다.\n\t- create, delete, update가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져 성능이 저하되는 역효과가 발생할 수 있다.\n\t- 복합 인덱스는 join, select 쿼리에 유용할 수 있다. mysql에서는 최대 16 column까지 인덱스를 정의할 수 있다. \n\t- where 절에서 참조되거나 join 절에서 사용되는 필요한 column을 기준으로 인덱싱해야 한다.\n\t- 키가 아닌 인덱스 열을 너무 많이 추가하게 되면 인덱스를 저장하는데 더 많은 디스크 공간이 필요하다.\n\t- 쿼리 성능의 이득이 데이터 수정 중 성능에 미치는 영향과 추가 디스크 공간 요구 사항보다 더 큰지 판단하는 것이 중요하다. 모든 열을 인덱싱하고 싶을 수 있지만, 불필요한 것은 추가하지 않는 것이 좋다.\n- create, update, delete가 빈번한 column에 index를 걸면 안 되는 이유?\n\t- 자주 업데이트되는 column을 인덱싱하면 인덱스 조각화가 발생할 수 있다. (인덱스 페이지가 연속적이지 않다는 것) 데이터베이스는 데이터를 검색하기 위해 추가 I/O 작업을 수행해야 한다. 따라서 인덱스를 사용하는 쿼리의 성능이 저하될 수 있다.\n\t- 인덱스 조각화란? \b인덱스에 있는 페이지의 논리적 순서가 데이터 파일의 페이지의 물리적 순서와 일치하지 않을 때 발생하는 상태이다. 인덱스를 스캔할 때 성능 문제를 일으킬 수 있다. \n\t- 자주 업데이트 되는 column을 인덱싱하면 페이지 분할 가능성이 높아질 수 있다. 이미 꽉 찬 페이지에 새 레코드가 삽입되면 페이지를 두 페이지로 분할해야 하며, 디스크 I/O가 추가되고 성능이 저하될 수 있다.\n\t- 디스크 공간 사용량이 증가한다.\n\t- 자주 업데이트되지만 검색 빈도도 높은 column의 경우 해당 column을 인덱싱하면 쿼리 성능이 개선된다. 따라서 상황에 따라서는 자주 업데이트되는 column을 인덱싱하는 것이 도움이 될 수도 있다.\n- 페이지가 꽉 찼을 때 새로운 데이터가 추가되는 경우에는 기존 페이지의 데이터 절반을 새로운 페이지에 할당한다. 따라서 페이지 밀도가 100%에서 50%로 줄어들게 된다."},{"excerpt":"이번 페어는 토리~ 🐿️ 1단계 미션에서 궁금했던 것 foreign key를 삭제해서 테스트는 편한데 이래도 될까? foreign key가 있으면 foreign key가 존재하는지에 대한 검증을 하지 않아도 된다는 장점이 있다. 그러면 foreign key를 믿을 것인가? foreign key가 있다가 없어질 수 있나? 그렇다면 foreign key가 있더…","fields":{"slug":"/level2-subway/"},"frontmatter":{"date":"2023년 05월 12일 07:05","title":"지하철 미션","tags":["우테코","미션","레벨2"]},"rawMarkdownBody":"\n이번 페어는 토리~ 🐿️\n\n## 1단계 미션에서 궁금했던 것\n- foreign key를 삭제해서 테스트는 편한데 이래도 될까?\n\t- foreign key가 있으면 foreign key가 존재하는지에 대한 검증을 하지 않아도 된다는 장점이 있다.\n\t- 그러면 foreign key를 믿을 것인가?\n\t- foreign key가 있다가 없어질 수 있나? 그렇다면 foreign key가 있더라도 검증을 하는 게 맞을 듯하다. 그런데 DB 설계가 수정되는 일이 많을까?\n- 도메인에 id가 있어도 될까?\n\t- 일단 id가 있으면 너무 편하다. id를 찾기 위해 DB를 다시 확인하는 일이 없어도 된다.\n\t- DB 의존적이라고 생각한다.\n- 모든 상황을 고려해서 예외 처리해야 할까?\n\t- 언제나 쓰는 곳이 정해져 있는데 그렇지 않은 경우를 상정하고 예외처리할 것인가?\n- 여러 개 추가될 때 어떤 값을 Location에 적어야 할까? 정말 전달하지 않는 것만이 최선이었을까?\n- dao 테스트 굳이 필요한가. 너무 복붙 코드고(대부분의 dao 테스트가 유사한 코드를 작성하게 된다) 의미가 없는 느낌이다.\n\t- 어쩔 수 없이 실제 DB를 사용하기 위해서는 save 메서드에 의존하게 되는데 이렇게 dao 테스트 하는 게 맞을까?\n- 도메인을 굳이 만들었어야 했을까? 사실 서비스에서 다 할 수 있는데 객체지향을 위해 도메인을 추가한 느낌?\n- 조인 vs 여러 번의 쿼리 중에 언제나 조인이 좋을까?\n\n\n## 1단계 미션에서 고민했던 것\n\n### 객체 설계 방법과 그 이유\nLine 안에 Sections가 있고, Section은 시작역과 도착역, 거리를 저장한다. Station은 역 이름을 저장한다.모든 Station에 종점인지 확인하기 위한 필드를 둘지 고민했다. 계산할 때는 편하지만 의미없는 데이터들이 많이 생길 것 같아 이런 설계를 고안하게 되었다.  \n\n장점: 의미 없는 데이터가 없다. 종점을 저장하는 것은 종점이 바뀔때마다 데이터가 변경되어야 하므로 데이터 안정성이 떨어진다.  \n단점: 종점을 찾는 로직을 설계하는게 어려웠다.\n\n### 테이블 설계 방법과 그 이유  \nstation 테이블은 id, 이름, line_id를 갖는다. section 테이블은 id, 시작역_id, 도착역_id, 거리, line_id를 갖는다. line 테이블은 id와 이름을 갖는다.객체 설계와 유사하게 테이블을 구성했다.  \nstation이 여러 line에 존재할 수 있기 때문에 line_id를 갖도록 했다.\n\n### API 설계 방법과 그 이유  \n노선 추가, 전체 노선과 역 조회, 특정 노선과 역 조회, 역 추가, 역 삭제하는 API를 설계했다.요구사항을 만족하는 기능만 구현했다.  \n\n시간이 부족했다. 역 조회, 역 목록 조회가 뼈대 코드에는 있었는데 노선 조회나 역 CREATE에서 역 id를 리턴하지 않아 클라이언트가 역 id를 알 수 있는 방법이 없다. 따라서 역 DELETE에서 이름을 받아 삭제하도록 했다.장점은 딱히 없고 상황상 어쩔 수 없이 선택했다. \n역을 추가할 때 역이 두 개가 한 번에 추가되는 경우가 있어 Location 헤더에 어떤 값을 전달해야 할 지 몰라서 id를 보내지 않았다. 또한 노선 조회에서 역 id를 찾으려면 N번 쿼리를 보내야 했기 때문에 성능상 전달할 수 없었다.  \n단점: http 컨벤션에 맞지 않는 API다. id는 index 처리가 되어 있지만 이름은 index 처리가 되어 있지 않아 쿼리 속도가 느리다.\n\n### 설계 과정에서 가장 고민을 많이 했던 부분  \n1. 종점 찾는 로직  \n2. 객체지향을 어떻게 지킬까  \n3. 노선을 생성만 하면 역이 어떻게 알아서 정렬되게 할까\n"},{"excerpt":"LOG 어제의 음주로 인해 아침에 일어나자마자 머리가 아팠다;; 이제 앞으로는 음주를 좀 자제해야 할 것 같다. 아침에 오니 디투랑 홍실도 아무것도 기억 못해서 웃겼다 ㅋㅋㅋ 자제하는 법 배우기... 주드, 박스터, 포이와 함께 제줏간에 갔다. 토리가 리사조 회식을 제줏간에서 한다고 해서 우연을 가장한 잠입을 했다. 백김치가 맛있었다. 배운 것 홍합은 영…","fields":{"slug":"/2023-05-12/"},"frontmatter":{"date":"2023년 05월 12일 06:05","title":"2023년 05월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 어제의 음주로 인해 아침에 일어나자마자 머리가 아팠다;; 이제 앞으로는 음주를 좀 자제해야 할 것 같다. 아침에 오니 디투랑 홍실도 아무것도 기억 못해서 웃겼다 ㅋㅋㅋ 자제하는 법 배우기...\n- 주드, 박스터, 포이와 함께 제줏간에 갔다. 토리가 리사조 회식을 제줏간에서 한다고 해서 우연을 가장한 잠입을 했다. 백김치가 맛있었다. \n\n## 배운 것\n- 홍합은 영어로 mussel이다.\n- foreign key가 있으면 foreign key가 존재하는 지에 대한 검증을 하지 않아도 된다는 장점이 있다. 쿼리를 날릴 때 FK가 유효하지 않은 경우 예외를 발생시킨다.\n\n## 궁금한 것\n- foreign key가 있다가 없어질 수 있나? 그렇다면 foreign key가 있더라도 검증을 하는 게 맞을 듯하다. 그런데 DB 설계가 수정되는 일이 많을까?\n- DB를 신뢰하는 것은 옳은가\n\n## 어려웠던 것\n\n## 느낀 것\n- 오늘 제줏간에서 술을 마실 수 있었지만 자제했다. 2차도 갈 수 있었지만 술을 안 마시기로 했기 때문에 가지 않았다. 절제하는 나자신 칭찬해 \n- 리뷰어와 디엠으로 소통하는 게 좋은 것 같다. 장바구니 리뷰 중에 이해가 안 되는 리뷰가 있어서 디엠을 보냈는데 빠르게 답변받을 수 있어서 좋았다. 제대로 이해되지 않거나 궁금한 것들은 앞으로 디엠으로 물어봐볼까."},{"excerpt":"LOG 미션을 완료했다! 사실 전날도 matzip 약속 때문에 저녁에 아무것도 못한 게 마음에 걸렸는데 다행이었다. 말랑의 코드를 아침에 보면서 왔는데 많은 도움이 된 것 같다. 말랑 그는 나의 거인. 거인의 어깨 위에서 많은 걸 배웠다. 서비스에 있던 비즈니스 로직을 다 도메인으로 옮기는 대작업을 했는데도 불만없이 잘 따라와준 토리한테도 감사하다 🥹 설…","fields":{"slug":"/2023-05-11/"},"frontmatter":{"date":"2023년 05월 12일 06:05","title":"2023년 05월 11일","tags":null},"rawMarkdownBody":"## LOG\n- 미션을 완료했다! 사실 전날도 matzip 약속 때문에 저녁에 아무것도 못한 게 마음에 걸렸는데 다행이었다. 말랑의 코드를 아침에 보면서 왔는데 많은 도움이 된 것 같다. 말랑 그는 나의 거인. 거인의 어깨 위에서 많은 걸 배웠다. 서비스에 있던 비즈니스 로직을 다 도메인으로 옮기는 대작업을 했는데도 불만없이 잘 따라와준 토리한테도 감사하다 🥹 설계가 자주 바뀌어서 제출 못할까봐 걱정했는데 다행이다.\n- 디투, 포이, 홍실과 육화식당에 갔다. 원래는 꿉당에 가려고 했는데 어제 오찌가 육화 식당 맛있다고 했던 것 같아서 (근데 확실하지 않다 ㅋㅋㅋ) 말했더니 목적지가 변경됐다. 고기는 맛있었고 김치찌개는 진짜 맛있었다;; 한 시간 만에 소주 3병 마시는 빠른 템포로 가다가 2차 갔는데 결국 기억이 하나도 안 난다ㅋㅋㅋ 진짜 음주를 했다... 집에는 어떻게 갔는지... 술 마시고 1일 3감사에 1감사만 올렸던데 올린 것도 기억이 안 난다 ㅋㅋㅋㅋㅋㅋ 술 좀 자제하자\n\n## 배운 것\n- Integer 같은 wrapper 클래스가 아닌 primitive 타입을 사용하고 `@Positive` 같은 validation 어노테이션을 사용하면 적용되지 않는다.\n- URL에 복수형을 쓸 때 컬렉션이나 배열에 추가/조회할 때로 생각하면 편하다.\n\n## 궁금한 것\n- foreign key를 삭제해서 테스트는 편한데 이래도 될까?\n- 도메인에 id가 있어도 될까?\n\t- 일단 id가 있으면 너무 편하다. id를 찾기 위해 DB를 다시 확인하는 일이 없어도 된다.\n\t- DB 의존적이라고 생각한다.\n- 모든 상황을 고려해서 예외 처리해야 할까?\n\t- 언제나 쓰는 곳이 정해져 있는데 그렇지 않은 경우를 상정하고 예외처리할 것인가?\n- 여러 개 추가될 때 어떤 값을 Location에 적어야 할까? 정말 전달하지 않는 것만이 최선이었을까?\n- dao 테스트 굳이 필요한가. 너무 복붙 코드고(대부분의 dao 테스트가 유사한 코드를 작성하게 된다) 의미가 없는 느낌이다.\n\t- 어쩔 수 없이 실제 DB를 사용하기 위해서는 save 메서드에 의존하게 되는데 이렇게 dao 테스트 하는 게 맞을까?\n- 도메인을 굳이 만들었어야 했을까? 사실 서비스에서 다 할 수 있는데 객체지향을 위해 도메인을 추가한 느낌?\n- 조인 vs 여러 번의 쿼리 중에 언제나 조인이 좋을까?\n\n## 어려웠던 것\n\n## 느낀 것\n- 미션이 끝나고 긴장이 풀려서 그런가 너무 신나게 놀아버렸다. 장바구니 미션 PR도 보내야 하고, 스터디도 있다는 거 잊지 말자. 할 일이 없을 때가 제일 열심히 해야할 때라고 생각한다~\n- 왠지 모르겠는데 말이 잘 나오는 날이었다. 사람들이랑 만나서 이야기하는 거 역시 재밌따~"},{"excerpt":"LOG mat.zip 4기 오리, 오찌, 후니, 블링, 태태, 샐리와 함께 밥을 먹게 되었다. 원래 교촌에 가기로 했는데 가는 곳마다 자리가 없어서 결국 크래프트 아일랜드에서 저녁을 먹게 되었다. 맛있게 잘 먹었습니다~ 이것저것 이야기를 많이 들었는데, 현업에서 일어나는 일들, 지금 하면 좋은 것들, 앞으로 어떻게 공부하면 좋을지 인사이트를 얻을 수 있어…","fields":{"slug":"/2023-05-10/"},"frontmatter":{"date":"2023년 05월 10일 15:05","title":"2023년 05월 10일","tags":null},"rawMarkdownBody":"## LOG\n- mat.zip 4기 오리, 오찌, 후니, 블링, 태태, 샐리와 함께 밥을 먹게 되었다. 원래 교촌에 가기로 했는데 가는 곳마다 자리가 없어서 결국 크래프트 아일랜드에서 저녁을 먹게 되었다. 맛있게 잘 먹었습니다~ 이것저것 이야기를 많이 들었는데, 현업에서 일어나는 일들, 지금 하면 좋은 것들, 앞으로 어떻게 공부하면 좋을지 인사이트를 얻을 수 있어서 매우 감사한 시간이었다. 다들 너무 유쾌하시고 재밌었다 ㅋㅋㅋ 2023 mat.zip 파이팅~!\n- 토리와 함께 지하철 역 추가를 구현하느라 하루를 다 썼다. 중간에 전혀 객체지향 하고 있지 않다는 걸 발견해서 그거 바꾸느라 시간이 너무 많이 들었다 😂 미션 완료할 수 있겠지...? 오늘 약속이 있는 바람에 구현을 많이 못해서 내일 9시에 만나서 하기로 했다. 열심히 노력해보고, 잘 되기를 바라야지..\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 객체지향을 지키는 것을 까먹어버렸다. 하도 DB랑 뭔가 하다보니까 절차 지향에 익숙해진걸까 ㅠ 객체지향을 놓지 않도록 앞으로 주의해야겠다.\n\n## 느낀 것\n- 이번 미션 너무 어렵다 ㅋㅋㅋ ㅜ 이것저것 이벤트들이 많은 바람에 시간이 조금 모자라서 걱정이 된다. 못 내면 어쩔 수 없긴 하지만 그래도 최선을 다해보자!! 토리 베로 파이팅 💪\n- 모르는 분들과 이야기할 주제를 많이 생각할 수 있게 되었다. 좀 더 덜 어색하게 말할 수 있어서 다행이었다. 애슐리와 말하는 것도 너무 즐거웠고, 다른 4기분들과 이야기하는 것도 즐거웠어서 역시 요즘은 사람 만나는 게 좋다~ 지금은 바빠서 많이 못하고 있는 것 같지만 😂\n"},{"excerpt":"나는 왜 사는가 왜 살아야 할까 살면서 계속해서 들었던 생각이다. 어떻게든 답을 듣고 싶어서 다른 사람들에게 물어보면, 그런 이야기 하지 말라고 했다. 어린 놈(?)이 무슨 벌써 그런 걱정을 하냐고 타박부터 들었다. 부모님한테 미안하지도 않냐는 말도 들었다. 그런 말은 하는 거 아니라며 다짜고짜 화내는 사람도 있었다. 그 중에서도 '원래 그냥 사는거다' …","fields":{"slug":"/writing-subject-candidate/"},"frontmatter":{"date":"2023년 05월 10일 01:05","title":"글감 주제","tags":["글"]},"rawMarkdownBody":"\n# 나는 왜 사는가\n\n**왜 살아야 할까**\n\n살면서 계속해서 들었던 생각이다.   \n어떻게든 답을 듣고 싶어서 다른 사람들에게 물어보면, 그런 이야기 하지 말라고 했다.   \n어린 놈(?)이 무슨 벌써 그런 걱정을 하냐고 타박부터 들었다. 부모님한테 미안하지도 않냐는 말도 들었다.    \n그런 말은 하는 거 아니라며 다짜고짜 화내는 사람도 있었다.\n\n그 중에서도 '원래 그냥 사는거다' 는 말이 제일 싫었다.   \n정말 이상하지 않나. 나는 앞으로도 계속 살아갈 텐데 내가 왜 사는지 묻지도 말라니.   \n어떻게든 정답을 찾고 싶었다. 살아가는 인생의 목적을 알고 싶었다.    \n앞으로 뭘 하고 싶은지도 모르는데 열심히 살 수는 없다. \n\n오기가 생겨서 오히려 일찍 죽겠다고 여기저기 말하고 다녔다. 처음엔 반쯤 오기였는데 이제는 진심이 되었다. \n나는 정말 내일 당장 죽어도 아쉽거나 미련이 남지 않을 것 같다.\n\n**목표가 없다**\n\n다른 사람들은 되고 싶은 것, 하고 싶은 것, 먹고 싶은 것 ... 원하는 게 많다. \n단기적으로든 장기적으로든 멋진 목표를 갖고 있는 사람들도 꽤나 많다. \n\n그런 사람들을 동경해서 나도 목표를 정하고 싶었다. \n\n**나는 재밌는 게 좋다**\n\n간절하지 않다. 하고 싶은 것도 없다. 그래서 내 인생은 꽤나 따분하다.\n오히려 재미를 찾는 이유는 그래서일지도 모른다. \n\n**나는 되는 대로 살고 싶다**\n\n사는 이유에 대한 정답은 못 찾았다.\n어쩌면 정답 같은 건 상관 없었을지도 모른다. 나에게는 살아야 하는 정당성이 필요하지 않았을까?\n\n현재를 살고 싶다. 앞으로 어떻게 사는지는 미래의 나에게 맡기자.\n그렇지만 결정을 할 때 과거가 방해가 되지 않게 살자. "},{"excerpt":"5/9 단위 테스트 단위 테스트란? 작은 코드 조각(단위)을 검증 빠르게 수행 가능 격리된 방식으로 처리 통합과 고립 협력 객체를 실제 객체로 사용하는지 mock 객체로 사용하는지에 따라 테스트 구현이 달라진다. Test Double 실제 객체 대신 사용되는 모든 종류의 객체에 대한 일반 용어 즉, 실제를 가짜 버전으로 대체한다는 의미 Stub 테스트 중…","fields":{"slug":"/level2-week4/"},"frontmatter":{"date":"2023년 05월 09일 02:05","title":"레벨2 4주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"\n# 5/9\n\n## 단위 테스트\n\n### 단위 테스트란?\n- 작은 코드 조각(단위)을 검증\n- 빠르게 수행 가능\n- 격리된 방식으로 처리\n\n### 통합과 고립\n- 협력 객체를 실제 객체로 사용하는지 mock 객체로 사용하는지에 따라 테스트 구현이 달라진다.\n\n## Test Double\n- 실제 객체 대신 사용되는 모든 종류의 객체에 대한 일반 용어\n- 즉, 실제를 가짜 버전으로 대체한다는 의미\n\n### Stub\n테스트 중에 만들어진 호출에 미리 준비된 답변을 제공하며 일반적으로 테스트를 위해 프로그래밍된 것 외에는 전혀 응답하지 않는다.\n\n`mock()` 을 사용하면 stub 객체를 만들 수 있다.\n\n`@Mock` 을 사용해도 stub 객체를 주입받을 수 있다.\n`@MockBean` 는 스프링 컨테이너에 올라가는 객체를 stub 객체로 만들 때 사용한다. \n\n### Fake\n실제 객체가 있고, 실제 객체와 똑같은 행위를 하는 비슷한 Fake 객체를 만드는 것.\n\n### 협력 객체를 실제 객체로? 가짜 객체로?\n실제 객체를 사용하면 협력 객체의 행위를 협력 객체 스스로가 정의한다.\n가짜 객체를 사용하면 협력 객체의 행위를 테스트가 정의한다.\n\n실제 객체를 사용하면 협력 객체의 상세 구현에 대해 알 필요가 없지만 협력 객체의 정상 동작 여부에 영향을 받는다. \n\n### 테스트 코드를 작성할 때\n가짜 객체를 활용하면 실제 객체를 사용할 때보다 좀 더 편하게 테스트를 작성할 수 있다. \n\n그러나 상세 구현에 의존하는 테스트가 될 수 있다.\n\n## Mockist의 단위 테스트\n테스트 대상을 협력 객체로부터 격리하기 위해 테스트 대상이 의존하는 모든 것을 가짜 객체로 대체한다.\n\n따라서 Line과 Station 모두 잘 동작하는지 검증한다는 것은 단위와 단위의 통합이 잘 동작하는지를 검증하는 것이다!\n\n### Outside In\nMockist TDD (London style)\n\n상위 레벨 테스트부터 시작한다.\n테스트 더블을 활용해서 테스트 대상이 의존하는 협력 객체의 예상 결과를 정의하고, 다음 사이클로 테스트 더블로 미리 정의한 협력 객체를 테스트 대상으로 한다.\n\n**단점**\n\n### Inside Out\nClassic TDD(Chicago style)\n\n실제 객체를 다뤄야 하기 때문에 도메인 모델을 시작.\n의존하는 협력 객체가 실제 존재해야 테스트를 작성할 수 있다.\n공유하는 객체(외부 리소스)를 사용할 때는 가짜 객체를 사용하기도 한다.\n\n**단점**\n도메인 설계가 충분히 이루어진 다음 진행 가능하다.\nTDD 사이클을 이어나가기가 상대적으로 어렵다.\n\n각 방법의 장단점이 명확하다.\n둘 중 하나를 선택해야 하는 문제가 아니다. 컨트롤러를 먼저 만들 것인지, 도메인 모델을 먼저 만들 것인지는 정답이 없다.\n\n### 아는 것에서 모르는 것으로\n> 사실은 상향식, 하향식 둘 다 TDD의 프로세스를 효과적으로 설명해줄 수 없다. 만약 어떤 방향성을 가질 필요가 있다면 아는 것에서 모르는 것으로 가는 방향이 유용할 것이다. 우리가 어느 정도의 지식과 경험을 가지고 시작한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.\n\n### 추천하는 방법\n- Top-down으로 방향을 잡고, Bottom-up으로 구현하기\n- 통합 테스트 작성을 통해 요구사항과 기능 전반에 대한 이해를 선행한다.\n- 내부 구현에 대한 설계 흐름을 구상한다.\n- 설계가 끝나면 도메인부터 차근차근 TDD로 기능 구현\n- 만약 도메인이 복잡하거나 설계가 어려울 경우 이해하고 있는 부분부터 기능 구현\n\n# 5/10\n## 워크숍 Day 1\n1. 각자 쓰고 싶은 주제에 대한 이야기 나누기\n\t1. 어떤 경험을 글에 담아내고 싶은지 이야기하기\n\t2. 왜 이 주제를 선택했는지, 어떤 경험에서 비롯된 소재인지, 어떤 형식의 글을 쓰고 싶은지, 예상 독자는 누구인지 등등\n2. 저자의 이야기를 듣고 다른 사람들은 그 이야기를 4-5줄로 간단히 요약\n3. 독자들이 요약해 준 글에서 본인 이야기의 핵심이라고 생각하는 부분을 뽑아 한 문장으로 공유\n\n## 글의 핵심 씨앗 만들기 (소재 탐색하기)\n\n각자 쓰고 싶은 주제에 대한 이야기를 나눌 때, 저자가 아닌 다른 크루들의 역할이 매우 중요하다. \n저자가 주제에 대해 소개할 때, 소재(쓸 거리)를 풍부하게 찾아낼 수 있도록 경험을 끌어내주자.\n\n그 주제에 대해 가장 좋았던 경험?\n그 주제와 관련해 힘들고 후회되는 경험? 재밌었던 일화 등등\n\n### 목차 만들기\n\n각 그룹에서 글의 목차를 함께 만든다. 글에서 가장 핵심이 되는 부분을 위에 적고, 핵심을 더 잘 드러내기 위한 내용을 목차로 함께 추가해야 한다.\n핵심과 멀어지는 부분을 추가하는 것을 지양한다.\n\n"},{"excerpt":"LOG 오늘 스터디가 있어서 공부를 열심히 했다. 이번에 맡은 부분은 ApplicationContext 인데, 내용이 너무 어려워서 오열하면서 했다 ㅋㅋㅋ 스프링은 왜 이렇게 어려울까... 스터디 하고 나니까 공부할 게 더 많아져서 ㅋㅋㅋ 할 게 생겼다. 내일 새로운 페어와 또 다른 미션을 하게 되는데 기대가 되네요. 공부를 열심히 해봅시다. 평소보다 너…","fields":{"slug":"/2023-05-08/"},"frontmatter":{"date":"2023년 05월 08일 12:05","title":"2023년 05월 08일","tags":null},"rawMarkdownBody":"\n## LOG\n- 오늘 스터디가 있어서 공부를 열심히 했다. 이번에 맡은 부분은 ApplicationContext 인데, 내용이 너무 어려워서 오열하면서 했다 ㅋㅋㅋ 스프링은 왜 이렇게 어려울까... 스터디 하고 나니까 공부할 게 더 많아져서 ㅋㅋㅋ 할 게 생겼다. 내일 새로운 페어와 또 다른 미션을 하게 되는데 기대가 되네요. 공부를 열심히 해봅시다.\n- 평소보다 너무 늦게 일어났다. 10시 40분에 기상해서 너무 촉박하게 준비했지만? 의외로 잠실에는 빨리 도착해서 도착한 김에 맥날에 갔다. 빅맥을 먹어봤는데 맛있었다. \n\n## 배운 것\n- Filter에서는 Spring ExceptionHandler 예외 처리가 불가능하다. Filter도 요즘에는 Spring Bean으로 등록된다고 한다.\n\n## 궁금한 것\n- BeanDefinition이 어디서 초기화되는가?\n- Filter가 어떻게 bean으로 등록될까?\n- OncePerRequestFilter 가 일반 Filter와 다른 점이 뭘까?\n\n## 어려웠던 것\n- `ApplicationContext` 코드를 읽다 보니까 너무 머리에 안 들어와서 고생했다. 내 능력을 좀 많이 벗어나는 일을 빠른 시간 내에 해치우려고 하니 많이 힘들었을지도.. 좋은 프롤로그 글이 나온 건 아닌 것 같아서 아쉬웠다.\n\n## 느낀 것\n- 특별하게 있었던 일은 없었지만, 그래도 오늘 하루 재밌었다. 다만 공부할 게 어려워서 하루가 너무 금방 지나간 것 같아서 조금 아쉽다.\n- 스프링은 파면 팔수록 너무 어려운 것 같다 ㅋㅋㅋ ㅜ 내일 지하철 미션에도 '레벨2에는 스프링 기능 학습이 전부일 것이라는 생각을 해서 스프링 동작 원리에 집중했던 과거의 나를 원망하기' 라는 말이 있었는데 ㅋㅋㅋㅋ 아무래도 난가... 싶네요ㅋㅋ 그렇지만 어떻게 되지 않을까 싶습니다~ 너무 깊게 들어가서 고민하는 중인가도 고민이 된다. 아직 스프링을 잘 사용할 줄 아느냐, 하면 그렇지 않아서 어디까지 공부해야 할 지 고민이 많이 된다. 일단 지금은 그냥 공부하고 싶은 것 이것저것 공부하는 중이다. 이렇게 하면 효율이 별로일 때도 있으니, 좀 더 고려해봐야 할 것 같다."},{"excerpt":"LOG 오늘은 공부를 열심히 했다. 스타벅스에 가서 집중했는데, 한 6시까지는 집중이 잘 되다가 너무 어려운 내용이 나오니까 집중하기 쉽지 않았다. 중간에는 몇 번 존 것 같기도 하다 ㅋㅋㅋ ㅠ 확실히 잘 모르거나 집중이 안 되는 상황만 오면 졸리다. 요즘 그냥 졸린 거 같기도 하고? 날이 추웠다. 반팔, 셔츠, 니트까지 껴입었는데도 추웠는데 기온은 18…","fields":{"slug":"/2023-05-07/"},"frontmatter":{"date":"2023년 05월 07일 08:05","title":"2023년 05월 07일","tags":null},"rawMarkdownBody":"\n## LOG\n- 오늘은 공부를 열심히 했다. 스타벅스에 가서 집중했는데, 한 6시까지는 집중이 잘 되다가 너무 어려운 내용이 나오니까 집중하기 쉽지 않았다. 중간에는 몇 번 존 것 같기도 하다 ㅋㅋㅋ ㅠ 확실히 잘 모르거나 집중이 안 되는 상황만 오면 졸리다. 요즘 그냥 졸린 거 같기도 하고?\n- 날이 추웠다. 반팔, 셔츠, 니트까지 껴입었는데도 추웠는데 기온은 18도여서 그냥 날씨 자체가 아이러니했다. 내일은 좀 안 추웠으면 좋겠다.\n- 미션 2단계 PR을 제출했다. 벌써 모레면 새로운 페어를 만나게 된다는 게 와닿지 않는다. 이번에는 좀 더 빨리 미션을 제출할 수 있었을 것 같은데 컨디션 난조로 인해 늦게 제출한 게 많이 아쉽다. 리뷰를 빨리 받기 위해서는 얼른 얼른 제출하는 게 훨씬 더 이득 같다. 그래도 늦게 제출했지만 다른 크루들의 리뷰를 많이 훔쳐봐서 그 과정에서 많이 배운 것 같다. 리뷰 savage 좋아요~\n\n## 배운 것\n- `RestAssured` 와 같이 외부에 API 요청을 하는 방식으로는 `@Transactional`이 적용되지 않는다.\n\n## 궁금한 것\n- 인증 로직은 대체 어디에 있어야 할까? ArgumentResolver, Filter, Interceptor, AuthService?\n- ArgumentResolver의 패키지 위치는 어딜까? (Controller, 혹은 다른 패키지?)\n- audit이 필요한 이유?\n\n## 어려웠던 것\n- 어렵고 지루한 내용이 나올 때 집중을 유지하기 어렵다. 이럴 때는 잠깐 쉬었다가 하는 게 좋을까? 근데 아까는 쉬어도 끝까지 집중력이 돌아오지 않았다. \n- 어려운 내용을 어디까지 파야 할까? 아직 그 기준을 세우는 게 너무 어렵다. 어디까지가 깊고, 어디까지가 얕은 건지 몰라서 그런 것 같기도 하다. \n\n## 느낀 점\n- 인생에 대한 고찰과 내가 어떻게 살아가고 있는지, 어떻게 살고 싶은지에 대한 생각을 많이 했다. 그냥 흘러가는 대로 사는 것도 좋지만, 살아가는 것에 대한 의미를 계속해서 사유하며 살아가자.\n- 잠실캠에 안 간 지 좀 됐는데 사람들이 보고 싶다 ㅋㅋㅋ 어쩔 수 없이 사람들과 이야기하는 게 재밌어서 그런 거 같다. 데일리도 하고 싶고, 이야기도 하고 싶고, 공부도 하고 싶다~"},{"excerpt":"IoC Container란? 각각의 용어를 풀어보자. IoC 란 Inversion of Control 의 약자로서, 제어의 역전을 뜻한다. 의존성 주입이라고 하기도 한다.\n컨테이너는 객체의 생명주기를 관리하고, 생성된 인스턴스들에게 추가적인 기능을 제공한다. 즉, IoC Container는 객체의 생성과 라이프사이클을 관리하고, 의존성을 클래스에 주입하기…","fields":{"slug":"/ioc-container-and-di/"},"frontmatter":{"date":"2023년 05월 07일 07:05","title":"IoC Container와 DI","tags":["spring","개발"]},"rawMarkdownBody":"\n## IoC Container란?\n\n각각의 용어를 풀어보자.\n\n**IoC** 란 Inversion of Control 의 약자로서, 제어의 역전을 뜻한다. 의존성 주입이라고 하기도 한다.\n**컨테이너**는 객체의 생명주기를 관리하고, 생성된 인스턴스들에게 추가적인 기능을 제공한다.\n\n즉, IoC Container는 객체의 생성과 라이프사이클을 관리하고, 의존성을 클래스에 주입하기도 한다.\n\n주로 다음과 같은 기능을 제공한다.\n\n- IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다.\n- POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.\n- 개발자들이 직접 POJO를 생성할 수 있지만 컨테이너에게 맡긴다.\n- 개발자는 비즈니스 로직에 집중할 수 있다.\n- 객체 생성 코드가 없으므로 TDD가 용이하다.\n\nSpring Framework의 IoC 컨테이너 구현은 org.springframework.beans, org.springframework.context 패키지의 기반이 된다.\n\n그 중에서도 `BeanFactory` 인터페이스는 모든 유형의 객체를 관리할 수 있는 고급 Configuration 메커니즘을 제공한다.\n`BeanFactory` 와 `ApplicationContext` 인터페이스는 Spring IoC 컨테이너를 가리킨다.\n\nSpring IoC 컨테이너가 관리하는 객체를 **빈(bean)** 이라고 하고, 이 빈(bean)들을 관리한다는 의미로 컨테이너를 **빈 팩토리(BeanFactory)** 라고 부른다.\n- 객체의 생성과 객체 사이의 런타임(run-time) 관계를 DI 관점에서 볼 때는 컨테이너를 **BeanFactory**라고 한다.\n- BeanFactory에 여러 가지 컨테이너 기능을 추가하여 **애플리케이션 컨텍스트(ApplicationContext)** 라고 부른다.\n\n### BeanFactory와 ApplicationContext\n\n- **BeanFactory**\n**Bean Factory**는 Bean을 등록, 생성, 조회, 반환을 관리한다. 보통은 BeanFactory를 바로 사용하지 않고, 이를 확장한 ApplicationContext를 사용한다. `getBean()` 메서드가 정의되어 있다.\n\n- **ApplicationContext**\nBean을 등록,생성,조회,반환을 관리하는 기능은 **BeanFactory**와 같다. Spring의 각종 부가 서비스를 추가로 제공한다. \n\n## DI (Dependency Injection) 이란?\n\n외부에서 클라이언트에게 서비스를 제공하는 것이다. \n즉, 객체가 필요로 하는 어떤 것을 외부에서 전달해주는 것이다.\n\n### 장점\n- 코드의 재사용성과 유연성이 높다.\n- 객체간 결합도가 낮아 한 클래스를 수정했을 때 다른 클래스를 수정해야 하는 상황을 막아준다.\n- 유지보수가 쉬우며 테스트가 용이하다. 어떤 클래스가 의존하는 객체가 변경되었을 때 코드의 변경을 최소화하며 유지보수할 수 있다. 또한 의존성 주입을 사용하면 클래스가 의존하는 객체를 외부에서 주입받아 사용하게 된다. 테스트 시에 클래스의 의존성을 변경하며 테스트할 수 있어 테스트가 용이하다.\n- stub, mock 객체를 사용하여 단위 테스트 시에 이점을 갖는다.\n\n### 단점\n- 주입된 객체들에 대해 코드 추적이 어렵고, 가독성이 떨어진다.\n- 간단한 프로그램을 만들 때는 오히려 번거롭다.\n\n## 의존관계 주입 방식\n\n### 생성자 주입\n생성자를 통해 의존 관계를 주입 받는다.\n\n스프링에서는 생성자 주입을 권장하고 있다. \n객체 생성 이후 의존 관계가 변경되지 않는 경우 생성자 주입을 사용하는 것이 좋다.\n\n#### 특징\n- 생성자 호출 시점에 한 번만 호출하는 것이 보장된다.\n- 생성자가 1개만 존재하는 경우에는 `@Autowired` 를 생략해도 자동으로 주입된다. 2개 이상일 때는 컴파일 예외가 발생한다.\n- 필드가 존재하지 않는 NPE를 방지할 수 있다.\n- 주입 받을 필드가 final이 될 수 있다.\n- 순환 참조를 방지한다. 필드 주입과 setter 주입은 빈이 생성된 이후에 참조하기 때문에 애플리케이션이 예외, 경고 없이 실행되어 실제 코드가 호출될 때까지 문제를 알 수 없다. 생성자를 통해 의존관계를 주입하면 `BeanCurrentlyInCreationException` 이 발생하여 문제를 알 수 있다.\n\n```shell\n2023-06-06 17:01:38.453  WARN 49905 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'circularReferenceBean' defined in file [/Users/cyma/IdeaProjects/sample-project/build/classes/java/main/hello/practice/CircularReferenceBean.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'practiceBean' defined in file [/Users/cyma/IdeaProjects/sample-project/build/classes/java/main/hello/practice/PracticeBean.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'circularReferenceBean': Requested bean is currently in creation: Is there an unresolvable circular reference?\n```\n\n### Setter 주입\n\n필드 값을 변경하는 setter로 의존 관계를 주입하는 방법이다.\n`@Autowired` 가 있는 setter로 자동으로 의존관계를 주입한다.\n\n#### 특징\n- 객체 생성 이후 변경 가능성이 있는 의존 관계에서 사용한다.\n- `@Autowired` 를 입력하지 않으면 실행이 되지 않는다.\n- `set필드명` 메서드로 의존 관계를 주입한다.\n\n### 필드 주입\n\n필드에 `@Autowired`를 붙여서 주입하는 방식이다.\n\n```java\npublic class A {\n\t@Autowired\n\tprivate B b;\n}\n```\n\n#### 특징\n- 필드 주입을 하게 되면 DI 컨테이너 안에서만 정상 작동한다. 즉, POJO가 아니다.\n- final 키워드를 사용할 수 없기 때문에 불변이 아닌 필드를 갖게 되고, setter로 가변 속성도 아닌 애매한 포지션이다.\n\n### 일반 메서드 주입\n\n```java\npublic class A {\n\tprivate B b;\n\tprivate C c;\n\n\t@Autowired\n\tpublic void method(B b, C c) {\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n}\n```\n\n#### 특징\n- 여러 필드를 주입받을 수 있다. -> 근데 이럴거면 생성자 주입 씀"},{"excerpt":"장바구니 미션  는  방식보다는 되도록 Controller를 작성해주는 것이 좋다. 해당 엔드포인트에 대한 컨트롤러가 중복될 수도 있고, 찾지 못할 수도 있기 때문이다. admin용 응답과 서비스용 응답은 현재 응답이 같더라도, 다른 service, 다른 responseDto를 활용하는게 좋습니다.  admin용 응답에는 더 디테일한 데이터가 들어갈 수 …","fields":{"slug":"/level2-review-mosquito/"},"frontmatter":{"date":"2023년 05월 07일 06:05","title":"레벨2 리뷰 훔쳐보기","tags":["레벨2","우테코"]},"rawMarkdownBody":"\n## 장바구니 미션\n\n- `ViewController` 는 `Configuration` 방식보다는 되도록 Controller를 작성해주는 것이 좋다. 해당 엔드포인트에 대한 컨트롤러가 중복될 수도 있고, 찾지 못할 수도 있기 때문이다.\n- admin용 응답과 서비스용 응답은 현재 응답이 같더라도, 다른 service, 다른 responseDto를 활용하는게 좋습니다.  admin용 응답에는 더 디테일한 데이터가 들어갈 수 있고, 서비스용 메서드는 인증 절차와 같은 부수적인 기능이 포함될 수 있기 때문입니다.\n- 오류메시지의 정보는 많이 넣어주자. 대신 클라이언트까지 전달되는 값은 보안상 부적절하니, Exception의 메시지 자체에는 오류 내용을 풍부하게 싣고 ExceptionHandler에서 사용자 메시지로 전달되는 부분을 변경하면 좋을 것 같다.\n- 인증인가 부분은 특히 메시지에 신경을 써야한다. 오류에서 생성되는 메시지들이 공격자에게 유효한 정보를 주지는 않는지 점검해보자.\n- jackson 2.13 릴리즈 패치에서 기본생성자 없이도 직렬화가 가능하도록 변경되었습니다[https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.13#no-constructor-deserializer-module](https://github.dev/woowacourse/jwp-shopping-cart/pull/298/files \"https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.13#no-constructor-deserializer-module\")\n\n### 의문점\n- 인증 로직은 대체 어디에 있어야 할까? ArgumentResolver, Filter, Interceptor, AuthService?\n- ArgumentResolver의 패키지 위치는 어딜까? (Controller, 혹은 다른 패키지?)\n- audit이 필요한 이유?\n\n테스트에서 데이터를 통해 의존성이 생기는 것은 주의하자.\n인증 쪽에서 로그인을 해야 사용할 수 있다. 유저를 매번 생성하지 않고 미리 하나 만들어두고 재사용하는 방식을 사용한다. 테스트 스코프는 중요하다.\n\n**슬라이스 테스트**가 의미가 있다고 생각하시는가? \n컨트롤러 계층에 대한 테스트는 e2e 테스트로도 충분히 검증할 수 있다고 생각한다. 컨트롤러 mocking은 굳이 의미 없다고 생각한다. 그러나 컨트롤러에 로직이 들어간다면 그럴 수 있다.\n서비스도 슬라이스 테스트가 의미 없다. 지금은 dao 에서 조회만 하고 있기 때문에 그렇다. 서비스에 로직이 들어가게 되면 의미가 있을 것이다. 그러나 그런 로직이 없기 때문에 더욱 의미가 없는 것처럼 느껴진다. \n\n### 럿고\n\n서비스 계층을 mocking을 하는 것\n테스트는 현재에 대해서만 검증하면 된다고 생각하지만, 미래를 대비하는 역할을 한다. 그런 부분에서는 테스트 코드가 안정성이 더 중요하다. 더 꼼꼼하게 작성하자. slice 테스트든 뭐든 학습 목적으로는 많이 고민해보는 것이 좋다. 호되게 당해보는 것도 오히려 좋을 수 있다. \n\n클라이언트에서 찾을 수 없는 id에 대한 업데이트와 삭제를 요청하는 경우, 현재는 404를 리턴하고 있는데, 200 ok나 500 예외를 던지는 것 중 어떤 것이 좋을까요? -> **404 Not Found**\nbody로 전달을 하게 된다면? -> update를 할 때도 URI에는 ID를 넣기 때문에(컨벤션) 해당 API가 존재하지 않는다는 뜻을 가지므로 괜찮다고 생각한다.\nHttpStatus Code에 대해 좀 더 알아보자.\n\nDB는 최대한 데이터를 가공하는 것은 피하는 것이 좋다고 생각한다.\n\nDB 테이블에 audit을 추가하면 좋다는 리뷰를 다른 크루의 리뷰에서 봤었는데, audit을 추가했을 때 관리 측면에서 좋은 이유가 무엇인가요? -> created_at, updated_at가 필요한 이유? 장애가 발생했을 때 롤백을 하기 위해서? 관리 측면도 있고, 게시판 형태에서 많이 사용한다. 차후에 미래를 생각하면서 만드는 것 같다. 예전에 만들어진 데이터에 관해서도 \n\n### 고칠 부분\n- [ ] 404 응답을 5xx 예외로 변경하기"},{"excerpt":"LOG 몸 상태가 너무 안 좋아서 네오에게 재택한다고 말씀드리고 집에서 재택을 했다. 네오도 어제 병가를 냈다고 하시던데 아마 나와 같지 않으셨을까 싶다...ㅋㅋㅋ 어제 검사해보니 A형 독감이라고 나와서 다른 사람들에게 옮기지 않기 위해서라도 재택을 하는 게 맞았던 거 같다. 아침까지는 열이 정말 많이 났는데, 약을 좀 꾸준히 먹으니 좀 더웠다. 다행히 …","fields":{"slug":"/2023-05-04/"},"frontmatter":{"date":"2023년 05월 04일 17:05","title":"2023년 05월 04일","tags":null},"rawMarkdownBody":"## LOG\n- 몸 상태가 너무 안 좋아서 네오에게 재택한다고 말씀드리고 집에서 재택을 했다. 네오도 어제 병가를 냈다고 하시던데 아마 나와 같지 않으셨을까 싶다...ㅋㅋㅋ 어제 검사해보니 A형 독감이라고 나와서 다른 사람들에게 옮기지 않기 위해서라도 재택을 하는 게 맞았던 거 같다. 아침까지는 열이 정말 많이 났는데, 약을 좀 꾸준히 먹으니 좀 더웠다. 다행히 지금은 그렇게 열이 많이 나거나 하지 않는다!\n- 드디어 도메인을 등록했다. 허브신님이 어떻게 하는지 알려줘서 한 2일간 못하던 거 끝냈따~ 앞으로는 vero.wiki 로 접속해주세요 ^-^\n\n## 배운 것\n- `Interceptor` 는 특정 url path를 지정할 수 있고, `Filter` 는 모든 url에 적용된다고 한다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 몸 관리를 잘하자... 건강하지 않으니 아무것도 할 수가 없다. 오늘도 공부하려고 했는데 너무 졸려서 4시간 자버려서 공부를 거의 못했다. 실제로 컨디션이 공부에 영향을 미치게 되니 나도 미칠 노릇이다 ㅋㅋ 얼른 나아서 열심히 공부하자 ~\n- 집에서보다 밖에서 공부하는 게 집중이 더 잘 되는 거 같다. 집에 붙어있지 않도록 노력해봐야겠다... 😂"},{"excerpt":"LOG 확실히 감기가 걸렸다. 이번에는 오래 안 아프고 싶어서 바로 병원에 갔다. 사실 병원에 안 가도 괜찮을 것 같다는 생각을 잠깐 했는데, 기침을 하다보니 피맛이 나서 ㅋㅋ 그냥 병원에 갔다. 병명은 원인불명의 기관지염. 기관지염 뭘까.. 자꾸 의사선생님이 비염이 있냐고 물어봤다. 없던 비염이 생긴 건 아니겠지? 회고 모임에서 한강으로 오프라인 모임을…","fields":{"slug":"/2023-05-02/"},"frontmatter":{"date":"2023년 05월 02일 15:05","title":"2023년 05월 02일","tags":null},"rawMarkdownBody":"## LOG\n- 확실히 감기가 걸렸다. 이번에는 오래 안 아프고 싶어서 바로 병원에 갔다. 사실 병원에 안 가도 괜찮을 것 같다는 생각을 잠깐 했는데, 기침을 하다보니 피맛이 나서 ㅋㅋ 그냥 병원에 갔다. 병명은 원인불명의 기관지염. 기관지염 뭘까.. 자꾸 의사선생님이 비염이 있냐고 물어봤다. 없던 비염이 생긴 건 아니겠지?\n- 회고 모임에서 한강으로 오프라인 모임을 갔다. 날이 좋아서 (생략) 기분이 좋았다. 뭔가 뛰고 싶었는데 못 뛰어서 좀 아쉬웠다. 기술적인 성장 + 기술 외적인 성장에 대해 회고했다. 기술적인 성장에서 다들 뭘 배웠는지에 대해 말하는 게 아니라 내가 어떤 식으로 공부하게 되었는지 말하는 게 되게 좋은 방향이라고 생각했다. 기술 외적인 성장에서는 내가 얼마나 이전의 나보다 긍정적으로 바뀌었는지, 사람들에게 더 잘 다가가게 되었다는 이야기를 했다. 회고 끝나고는 체인저의 여자친구 목도리 돌리기, 당신의 이웃을 사랑하십니까 게임을 했다 ㅋㅋㅋ 재밌었다. 이런 게임은 언제 안 재밌을까 ㅋㅋ\n- 말랑과 오잉의 테코톡 발표를 들었다. 둘 다 내용도 유익하고 발표도 잘해서 여기는 발표 잘 하는 사람밖에 없나? 라는 생각을 했다. 나도 나중에 테코톡 발표할 때 말을 어떻게 해야 좋을지 갑자기 고민이 됐다.\n\n## 배운 것\n- Base64에 대해 좀 더 알아봤다 : 아직 덜 쓴 [[spring-authentication]]\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 오늘따라 공부가 하고 싶었는데, 항상 이런 날에는 약속이 있다. 베로의 약속 법칙... 공부가 하기 싫은 날에는 아무 일도 없어서 확실히 타이밍을 잘 맞춰야 한다. 요즘에 많이 놀아서 더 공부가 하고 싶은 거 같기도 하다. 그만 놀고 공부해야겠다.\n- 최근에 니체의 책을 읽었다. `마흔에 읽는 니체` 였나 ㅋㅋ 마흔은 아니지만 마흔의 나를 상상하며 읽었다. 갑자기 인간 말종에 대한 말이 나왔는데, 제대로 된 사람은 삶을 욕망한다고 한다. 그런데 생각해보면 내가 삶을 살면서 욕망했던 것은 손에 꼽는 것 같다. 그래서 아마도 ? 과거의 나는 확실하게 인간 말종이었을지도?ㅋㅋㅋ 지금의 나를 대입해서 봐도 아직은 인간 말종일 수도 있을 것 같다. 니체에 따르면 인간 말종은 그저 즐거운 소일거리에만 매달리는 삶을 산다고 한다. 아직 나는 즐거운 소일거리가 너무 좋은 거 같다. 니체가 그렇게 말했다고 해서 ABN? by all means~ 아직은 바뀌고 싶은 생각이 없으니 좀 더 인간 말종으로 살아보자 ~"},{"excerpt":"인증과 인가 인증 식별 가능한 정보로 서비스에 등록된 유저의 신원을 입증하는 과정 인가 인증된 사용자에 대한 자원 접근 권한 확인 (인증이 선행되어야 한다) 인증과 인가 => 자원을 적절한 / 유효한 사용자에게 전달하거나 공개하기 위한 방법이다. Basic Authentication 클라이언트가 사용자 이름과 비밀번호를 통해 인증을 수행하는 것이다. Ba…","fields":{"slug":"/spring-authentication/"},"frontmatter":{"date":"2023년 05월 02일 06:05","title":"Authentication","tags":["레벨2","spring","개발"]},"rawMarkdownBody":"\n## 인증과 인가\n\n### 인증\n- 식별 가능한 정보로 서비스에 등록된 유저의 신원을 입증하는 과정\n\n### 인가\n- 인증된 사용자에 대한 자원 접근 권한 확인 (인증이 선행되어야 한다)\n\n인증과 인가 => 자원을 적절한 / 유효한 사용자에게 전달하거나 공개하기 위한 방법이다.\n\n## Basic Authentication\n\n클라이언트가 사용자 이름과 비밀번호를 통해 인증을 수행하는 것이다. \n\nBasic 키워드로 시작해서 base64로 인코딩된 `사용자이름:비밀번호` 값으로 이어진다. 이때, `:` 는 구분자로 사용되므로 빼놓지 말고 사용해야 한다.\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class CustomWebSecurityConfigurerAdapter {\n\n    @Autowired private MyBasicAuthenticationEntryPoint authenticationEntryPoint;\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        auth\n          .inMemoryAuthentication()\n          .withUser(\"user1\")\n          .password(passwordEncoder().encode(\"user1Pass\"))\n          .authorities(\"ROLE_USER\");\n    }\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .antMatchers(\"/securityNone\")\n            .permitAll()\n            .anyRequest()\n            .authenticated()\n            .and()\n            .httpBasic()\n            .authenticationEntryPoint(authenticationEntryPoint);\n        http.addFilterAfter(new CustomFilter(), BasicAuthenticationFilter.class);\n        return http.build();\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n`httpBasic()` 요소를 사용하여 `SecurityFilterChain` 빈 내에서 basic authentication을 정의할 수 있다.\n\n```http\n###### HTTP Request ######\nGET /members/my HTTP/1.1\nauthorization: Basic ZW1haWxAZW1haWwuY29tOjEyMzQ=\naccept: application/json\nhost: localhost:54560\nconnection: Keep-Alive\nuser-agent: Apache-HttpClient/4.5.13 (Java/11.0.19)\naccept-encoding: gzip,deflate\n\n\n###### HTTP Response ######\nHTTP/1.1 200 OK\nTransfer-Encoding: chunked\nKeep-Alive: timeout=60\nConnection: keep-alive\nDate: Tue, 02 May 2023 08:28:03 GMT\nContent-Type: application/json\n```\n\n`authorization` 헤더에 인코딩된 값을 넣어 Request로 전달한다.\n\n### Base64\n\nBase64는 바이너리 데이터를 내용 자체의 손실이나 수정 없이 전송할 수 있는 ASCII 문자 집합으로 인코딩 하는 방식이다.\n\n컴퓨터 간에 데이터를 전송하려면 데이터를 0과 1로 인코딩하여 전송한 다음 다시 디코딩해야 한다. \n문자당 비트 수를 다르게 사용하는 다양한 인코딩이 만들어졌지만, 결국 문자당 7비트를 사용하는 ASCII가 표준이 되었다.\n그러나 대부분의 컴퓨터는 바이너리 데이터를 각각 8비트로 구성된 바이트로 저장하므로, ASCII는 바이너리 데이터 전송에 적합하지 않았다. 이때 Base64 인코딩이 도입되었다. 그러나 Base64를 사용하여 메시지를 인코딩하면 3바이트의 데이터가 4개의 ASCII 문자로 인코딩되기 때문에 전송되는 데이터의 길이가 늘어난다.\n\n또한 Base64 인코딩은 데이터를 인코딩하고 디코딩하는데 추가적인 시간이 필요하다.\n\n결정적으로 Base64 인코딩은 지나치게 간단하다. 따라서 패스워드를 제대로 보호하기 힘들다.\nBase64 인코딩은 암호화가 아닌 인코딩이다. 개발할 때 encoding을 사용하는 이유는 암호화가 아니라 가시성과 보관성을 위해서이다. 따라서 암호화를 위해 Base64 인코딩을 사용하면 취약하다고 할 수 있다.\n\n결론! 중요한 보안 정보를 보호하는 데에 Base64 인코딩을 사용해서는 안 된다.\n\n## Token Authentication\n\nSpring에서 token authentication 은 인증, 권한 부여를 위한 프로토콜인 OAuth2.0을 사용하여 구현할 수 있다.\n\nBearer 토큰은 인증 서버에서 발급하는 보안 토큰으로, OAuth2.0 리소스 서버에 의해 보호되는 리소스에 접근하기 위해 사용된다. 유효한 Bearer 토큰으로 사용자를 인증할 수 있다.\n\n## Session Authentication\n\n## 참고 자료\n- [토니의 인증과 인가](https://www.youtube.com/watch?v=y0xMXlOAfss)\n- https://www.baeldung.com/java-httpclient-basic-auth\n"},{"excerpt":"5/2 인증 일단 인증을 붙이고 생각하는 게 아니라 구현할 기능에 따라서 인증을 붙일지 말지 고민한다. 인증: 누구인가?\n인가: 권한이 있는가? 기능이 어떤 요구사항을 가지는지에 따라 인증/인가 구현이 달라진다 => 테코톡 보고 학습하자 ? 권한이 없는 사용자의 요청 인증 & 인가는 내가 특정 자원을 요청할 때 응답을 받을 수 있는지 없는지 확인하는 것.…","fields":{"slug":"/level2-week3/"},"frontmatter":{"date":"2023년 05월 02일 01:05","title":"레벨2 3주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 5/2\n\n## 인증\n\n일단 인증을 붙이고 생각하는 게 아니라 구현할 기능에 따라서 인증을 붙일지 말지 고민한다. \n\n**인증: 누구인가?\n인가: 권한이 있는가?**\n\n기능이 어떤 요구사항을 가지는지에 따라 인증/인가 구현이 달라진다 => 테코톡 보고 학습하자\n\n## ?\n\n### 권한이 없는 사용자의 요청\n\n인증 & 인가는 내가 특정 자원을 요청할 때 응답을 받을 수 있는지 없는지 확인하는 것.\n\n클라이언트는 서버에 사용자가 누구인지 식별할 수 있는 정보를 보내고, 서버에서 접근 가능한 사용자인지 판단한다.\n\n서버에는 사용자의 정보를 저장하지 않는다. (무상태성)\n모든 서버가 그런 것은 아니다. 앞서 보낸 정보가 누구의 정보인지 알고 있는 서버가 있기도 하다.\n그러나 보편적으로 사용하는 서버에서는 상태가 없다고 생각하면 된다.\n\n### Basic Auth\n\n`Authorization` 헤더에 구분자와 키 값을 넣어서 전송한다.\n인증을 할 수 있는 값을 넣어서 전송하는 것. \n아이디와 패스워드를 계속해서 입력 받아야 한다.\n\n### 인증 정보\n\n인증 정보를 다른 형태의 정보로 저장한다. (쿠키/세션, 토큰 등)\n인증 정보를 매 요청 때마다 보내는 것은 똑같지만, 1차원적으로 아이디/패스워드를 인코딩한 값을 보내는 것과 서버와 약속한 정보를 보내느냐의 차이가 있다.\n\n### Session\n\n1. 사용자 로그인\n2. 서버에서 DB를 통해 사용자 확인\n3. 서버가 회원 정보 세션을 생성하여 세션 저장소에 저장한다.\n4. 세션 저장소에서 서버에게 Session ID를 발급해준다.\n5. 사용자에게 Session ID를 포함한 응답을 전송한다.\n6. 사용자는 다음 요청부터 쿠키에 Session ID를 함께 전송한다. 특정 헤더 값에 포함해서 보내면 된다.\n7. 서버가 쿠키를 검증한다.\n8. 세션 저장소에서 유저 정보(세션)을 획득한다.\n9. 요청 데이터를 응답한다.\n\n## 학습 테스트\n\n- `preemitive()` : 최초에 어떤 인증을 하는지 확인하는 과정을 생략하면 효율적으로 진행할 수 있다.\n\n```java\n@Test  \nvoid basicLogin() {  \n    MemberResponse member = RestAssured  \n            .given().log().all()  \n            .auth().preemptive().basic(EMAIL, PASSWORD)  \n            .accept(MediaType.APPLICATION_JSON_VALUE)  \n            .when().get(\"/members/my\")  \n            .then().log().all()  \n            .statusCode(HttpStatus.OK.value()).extract().as(MemberResponse.class);  \n  \n    assertThat(member.getEmail()).isEqualTo(EMAIL);  \n}\n```\n\n`preemitive()` 를 생략하면 `authorization` 헤더가 없어지게 된다.\n\n```java\n// PreemptiveBasicAuthScheme.java\npublic String generateAuthToken() {  \n  (\"Basic \" + \"$userName:$password\".getBytes(AUTH_ENCODING).encodeBase64()).toString()  \n}\n```\n\nBasic의 경우 :로 구분하는 것을 볼 수 있다.\n\n- Basic을 꼭 붙여야 할까? : https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization#directives\n- `validateToken` 은 토큰이 만료되었는지 아닌지를 판단하기 위해 사용한다.\n\n## Spring Mvc with 다른 구성 요소\n\n- `MethodArgumentResolver`: 특정 요청들을 분리해서 매개변수로 전달하는 것\n"},{"excerpt":"LOG 갑자기 오늘따라 눈이 일찍 떠져서 6시에 일어났다;;; 다시 자려고 했는데 잠이 안 왔다.. 일찍 일어난 김에 오랜만에 아침을 만들어서 먹었다. 집에 스팸이 쌓여서 스팸 김치 볶음밥을 해먹었는데 맛있었다. 빨래도 하고 설거지도 하고 오랜만에 집안일을 좀 했더니 집이 그나마 깨끗해졌다. 포켓몬 전시회에 갔다. 판교에서 하는 줄 알고 판교까지 갔는데 …","fields":{"slug":"/2023-05-01/"},"frontmatter":{"date":"2023년 05월 01일 12:05","title":"2023년 05월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 갑자기 오늘따라 눈이 일찍 떠져서 6시에 일어났다;;; 다시 자려고 했는데 잠이 안 왔다.. 일찍 일어난 김에 오랜만에 아침을 만들어서 먹었다. 집에 스팸이 쌓여서 스팸 김치 볶음밥을 해먹었는데 맛있었다. 빨래도 하고 설거지도 하고 오랜만에 집안일을 좀 했더니 집이 그나마 깨끗해졌다.\n- 포켓몬 전시회에 갔다. 판교에서 하는 줄 알고 판교까지 갔는데 알고보니 잠실에서 하는 전시회였다. 판교 간 김에 규카츠를 먹었다. 구워 먹는 것보다 그냥 먹는 게 더 맛있었다. 포켓몬 전시회 가서 루카리오도 보고 따라큐 핀 같은 걸 샀다. 귀엽다. 내일부터 가방에 달고 다녀야겠다.\n- 네오한테 포켓몬 전시회가 있다고 말했더니 보러 오신다고 했다. 오신 김에 저녁을 같이 먹자고 해서 냉면을 같이 먹었다. TIL에 내내 먹는 얘기 밖에 없네 ㅋㅋ 그래도 되게 재밌었다.\n\n## 배운 것\n- 리뷰어가 int 범위 제한을 어떻게 할 수 있을지 물어봐서 예외 처리를 해야했다. int 범위가 넘는 값이 들어오면 이상하게 `@range` 로도 안 잡히고 `HttpMessageNotReadableException` 이 발생했다. 그래서 `@ExceptionHandler` 로 처리해주었다.\n\n## 궁금한 것\n- 문제는 `HttpMessageNotReadableException` 를 따로 예외 처리하면 예외 메시지를 html에 띄울 수 없다. 어떻게 하면 할 수 있을까? \n\n## 어려웠던 것\n\n## 느낀 것\n- 날씨가 좋았다. (날이 좋아서, 이하 생략) 또 다시 감기에 걸렸다;; 그렇게 안 심했는데 오늘 돌아다니다 보니까 기침이 심해졌다 ㅋㅋㅋ again human disaster... 건강이 최고다.\n- 판교에서 전시회 하는 줄 알고 갔지만 판교에서 노는 것도 재밌었다. 처음으로 판교에 가봤는데 길이 되게 깨끗하고 더 발달된(?) 광명처럼 생겼다. 판교에 취직하고 싶다~ 포켓몬 전시회 그냥 가 본 거였는데 애들도 귀엽고 의외로 볼 게 많았다. 나중에 판교에서 더 큰 포켓몬 전시회가 있으면 가 봐야겠다."},{"excerpt":"2023-05-01 2023-05-02 2023-05-04 2023-05-07 2023-05-08 2023-05-10 2023-05-11 2023-05-12 2023-05-14 2023-05-15 2023-05-16 2023-05-17 2023-05-18 2023-05-20 2023-05-21 2023-05-22 2023-05-26 2023-05-27 2…","fields":{"slug":"/2023-05/"},"frontmatter":{"date":"2023년 05월 01일 12:05","title":"2023년 05월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-05-01]]\n- [[2023-05-02]]\n- [[2023-05-04]]\n- [[2023-05-07]]\n- [[2023-05-08]]\n- [[2023-05-10]]\n- [[2023-05-11]]\n- [[2023-05-12]]\n- [[2023-05-14]]\n- [[2023-05-15]]\n- [[2023-05-16]]\n- [[2023-05-17]]\n- [[2023-05-18]]\n- [[2023-05-20]]\n- [[2023-05-21]]\n- [[2023-05-22]]\n- [[2023-05-26]]\n- [[2023-05-27]]\n- [[2023-05-28]]\n- [[2023-05-29]]\n- [[2023-05-30]]\n"},{"excerpt":"LOG 네오와 커피챗을 했다. 오늘은 네오와 내내 같이 있을 수 밖에 없었다. 점심에 포이, 망고, 토리와 같이 토도로끼에서 점심을 먹었고, 5시부터는 면담을 했다. 6시에는 회식을 하러 갔으니 오늘 내내 네오와 같이 있었던 셈이다. 면담에서는 페어가 어떤 피드백을 남겨주었는지 알려주었다. 아직 페어 회고를 하지 않은 깃짱을 제외하고는 모두 알고 있는 내…","fields":{"slug":"/2023-04-28/"},"frontmatter":{"date":"2023년 04월 28일 16:04","title":"2023년 04월 28일","tags":null},"rawMarkdownBody":"## LOG\n- 네오와 커피챗을 했다. 오늘은 네오와 내내 같이 있을 수 밖에 없었다. 점심에 포이, 망고, 토리와 같이 토도로끼에서 점심을 먹었고, 5시부터는 면담을 했다. 6시에는 회식을 하러 갔으니 오늘 내내 네오와 같이 있었던 셈이다. 면담에서는 페어가 어떤 피드백을 남겨주었는지 알려주었다. 아직 페어 회고를 하지 않은 깃짱을 제외하고는 모두 알고 있는 내용이라 새롭지는 않았다. 그래도 칭찬이 많아서 다행이었다. \n- 네오와 면담을 했다. 주제는 `인생의 목표와 가치관을 어떻게 정할 수 있을까?` 라는 주제였다. 답을 정하고 간 주제는 아니었는데, 생각보다 네오가 좋은 답변을 많이 해줘서 가치관을 정립할 수 있었던 거 같다. 네오 같은 사람을 지금까지 만나본 적이 없었는데, 나와 비슷한 점이 많아서 공감이 잘 됐다. 뭔가 멋진 말이 많이 나왔던 거 같은데 지금 쓰려고 하니까 기억이 안 난다. 어쨌든 결론적으로는 오늘의 롤모델은 네오라는 것이다. 네오가 굉장히 뿌듯해했다. 근데 감명받았던 내용이 기억이 안 난다...\n- 베포헤말 스터디 했는데 오늘 면접이 되게 어려웠다 ㅋㅋㅋ ㅜ 이번에 어려운 내용이 많았는데 그래도 많이 얻어간 것 같아서 좋았다. 내용 더 많이 알아봐야겠다...\n- 네오조 회식이 있었다. 로지, 호이, 테오와 말을 놓았다. 작살치킨에 40명이나 있었는데 꽤 많은 사람들이랑 만난 거 같다 ㅋㅋㅋ 로지도 중간에 만나고 히이로와 하디랑도 이야기해봤다. 처음 보는 사람들이 많아서 재밌었다~ 요즘 사람 만나는 게 즐거워서 하루하루가 즐겁다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 인생의 목표 비슷한 게 생겼다. 오늘의 멘토 네오 덕분이다. 막 살아도 괜찮은 인생을 살자라는 목표가 생겼다. 네오의 인생을 들어봤는데, 분명 막 사는 거 같은데 잘 되는 거 같아서 그게 간지라고 생각했다. 뭔가 목표를 만들고 그걸 지키려고 했는데, 생각해보니 많은 사람들이 목표를 가지고 있어서 그건 힙스터 같지 않다고 생각했다. 나는 힙스터가 좋기 때문에 목표도 안 만들고 뭐할지도 안 정하려고 한다. 정확하게는 아무것도 안 해도 잘 사는 사람이 되고 싶다. 그게 멋이니까 ㅋㅋ 이렇게 적어도 되나 싶지만 네오가 오히려 좋아했다. 네오한테 다윈상 말해줬는데 죽기전에 한 번쯤 달성해보고 싶다고 해서 나도 네오한테 목표를 만들어준 거 아닐까? 하는 긍정적인 생각을 했다. 좋은데요?\n- 네오와 면담을 분명 30분만 하기로 했는데 정신차려 보니까 1시간이나 했다. 굉장히 나랑 비슷한 사람이라고 느꼈다. 근데 포이랑도 비슷하다 ㅋㅋ 네오랑 비슷한 점이 하지말라고 하면 더 하고 싶은 청개구리같은 마인드다. 근데 아무리 생각해도 내가 네오보다 철이 덜 든 것 같다. 아닌가? ㅋㅋ"},{"excerpt":"베포후헤말 스터디 면접 공부를 위한 글입니다. Dispatcher Servlet 이란? 프론트 컨트롤러 디자인 패턴에서 하나의 Controller가 들어오는 HttpRequest를 애플리케이션의 다른 모든 Controller와 Handler에 전달하는 역할을 담당한다. 즉, Spring의 DispatcherServlet 가 Front Controller …","fields":{"slug":"/dispatcher-servlet/"},"frontmatter":{"date":"2023년 04월 28일 02:04","title":"DispatcherServlet","tags":["spring","스터디","개발"]},"rawMarkdownBody":"\n**베포후헤말 스터디 면접 공부를 위한 글입니다.**\n\n## Dispatcher Servlet 이란?\n\n프론트 컨트롤러 디자인 패턴에서 하나의 Controller가 들어오는 HttpRequest를 애플리케이션의 다른 모든 Controller와 Handler에 전달하는 역할을 담당한다. \n\n즉, Spring의 DispatcherServlet 가 Front Controller 역할을 맡고 있다.\n\n## Dispatcher Servlet은 무엇을 하는가?\n\n들어오는 URI를 받아 해당 위치에서 찾아서 하는 페이지나 리소스를 형성하기 위해 결합되는 handler와 view의 올바른 조합을 찾는 역할을 한다.\n\n들어오는 HttpRequest를 처리하고, Request를 위임하고, handler, controller endpoint 와 reponse 객체를 지정하는 어노테이션과 함께 Spring 애플리케이션 내에 구현된 `HandlerAdapter` 인터페이스에 따라 해당 요청을 처리한다.\n\n## 순서\n\nDispatcherServlet은 `getHandler()` 를 사용하여 Dispatcher에 대해 구성한 HandlerAdapter 인터페이스의 모든 구현을 찾는다. \n\nDispatcherServlet은 대상 컨트롤러를 결정하기 위해 다음 mapper 중 하나를 참조하여 대상 컨트롤러를 결정한다.\n\n`BeanNameUrlHandlerMapping`, \n`ControllerBeanNameHandlerMapping`, \n`ControllerClassNameHandlerMapping`, \n`DefaultAnotationHandlerMapping`, \n`SimpleUrlHandlerMapping`\n\nconfiguration을 수행하지 않으면 DispatcherServlet은 기본적으로 `BeanNameUrlHandlerMapping`, `DefaultAnnotationHandlerMapping` 을 사용한다. 대상 컨트롤러가 식별되면 DispatcherServlet이 해당 컨트롤러로 요청을 보낸다. 컨트롤러는 요청에 따라서 몇 가지 작업을 수행한 후, Model과 View의 이름과 함께 DispatcherServlet으로 다시 반환한다.\n\n1. Request를 DispatcherServlet이 받는다.\n2. Request에 맞는 적절한 Controller를 찾는다.\n3. Request를 Controller로 건네줄 HandlerAdapter를 찾아서 전달한다.\n4. HandlerAdapter가 Controller로 Request를 전달한다.\n5. 비즈니스 로직을 처리한다.\n6. 처리된 반환값을 HandlerAdapter한테 전달한다.\n7. HandlerAdapter는 반환값을 DispatcherServlet에게 전달한다.\n8. Response를 응답한다.\n\n## DispatcherServlet 의 동작\n\n### DispatchServlet\n\n`getHandler()` : Request에 맞는 HandlerMapping을 선택하여 HandlerExecutionChain을 가져온다.\n`getHandlerAdapter()` : HandlerExecutionChain에 맞는 HandlerAdapter를 가져온다. \n`handle()` : HandlerAdapter를 실행한다. (컨트롤러 메서드 실행)\n\n### HandlerMapping\n\n`getHandlerAdapter()` : `HandlerExecutionChain` 에는 요청에 맞는 핸들러가 저장되어 있다. `HandlerAdapter` 를 가져오기 위해 `HandlerExecutionChain` 에 있는 핸들러로 판단한다. \n\n## 참고 자료\n- [헤나의 Dispatcher Servlet 둘러보기 블로그 글](https://programming-hyena.tistory.com/38)\n- https://www.baeldung.com/spring-dispatcherservlet\n"},{"excerpt":"LOG 장바구니 미션 1단계 PR을 보냈다.  를 사용해서 에러 처리를 추가했다. 갑자기 예외 나온 이유를 프론트에서 보여주고 싶어서 js, html도 수정했다. 글렌이 만든  를 참고해서 구현했다. 우르 코드도 조금 참고했는데 이렇게 하는 게 best practice인 건지 궁금하다. 럿고의 리뷰 기다리는 중.... 오늘 새벽집에 술을 마시러 갔다. 배…","fields":{"slug":"/2023-04-27/"},"frontmatter":{"date":"2023년 04월 27일 08:04","title":"2023년 04월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 장바구니 미션 1단계 PR을 보냈다. `@ControllerAdvice` 를 사용해서 에러 처리를 추가했다. 갑자기 예외 나온 이유를 프론트에서 보여주고 싶어서 js, html도 수정했다. 글렌이 만든 `ErrorResponse` 를 참고해서 구현했다. 우르 코드도 조금 참고했는데 이렇게 하는 게 best practice인 건지 궁금하다. 럿고의 리뷰 기다리는 중....\n- 오늘 새벽집에 술을 마시러 갔다.\n\n## 배운 것\n- `ControllerAdvice` 에서도 `@ReponseBody` 를 사용할 수 있다.\n- `@NotBlank` 같은 validation 로직에 `message` 속성을 지정하면 예외 메시지 값을 정해줄 수 있다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부할 게 많이 쌓였다. 우르와 같이 페어하면서 궁금한 게 많았는데 그게 그대로 다 기술부채로 갔다. 오늘은 미션을 하느라 딱히 공부한 건 많이 없는 것 같다. 공부할 시간이 필요하다. 그런데 요즘 계속 끝나고 약속 있어서 남아서 공부를 못한다 ㅋㅋㅋ... 다음 주에 좀 더 빡세게 공부해야겠다. 대신 미션에는 시간을 많이 투자했던 게 좋았다. \n- 내일은 네오와 면담이 있다. `인생의 가치관과 목표를 정하는 방법` 이라는 주제로 커피챗을 신청했다. 요즘 많이 고민하던 주제인데 네오와 이야기 하면서 어떤 인사이트를 얻어갈지 궁금하다. 정답을 찾지 못하더라도 앞으로 어떻게 생각할지? 힌트가 주어진다면 좋을 것 같다."},{"excerpt":"LOG 우르와 페어가 됐다. 레벨 인터뷰 때도 같은 조고 같은 데일리 조원이라 사실상 아는 사람이었다. 처음으로 아는 사람과 페어가 되었다! 우르는 아는 게 정말 많다. 김영한님 강의를 다 들었다고 했는데 그래서 그런지 이번 미션하는 게 굉장히 수월했다. 칭찬을 많이 해줘서 뿌듯하게 페어 프로그래밍 할 수 있었다. 중간에 우르와 같이 이해가 안 되는 부분…","fields":{"slug":"/2023-04-25/"},"frontmatter":{"date":"2023년 04월 25일 11:04","title":"2023년 04월 25일","tags":null},"rawMarkdownBody":"## LOG\n- 우르와 페어가 됐다. 레벨 인터뷰 때도 같은 조고 같은 데일리 조원이라 사실상 아는 사람이었다. 처음으로 아는 사람과 페어가 되었다! 우르는 아는 게 정말 많다. 김영한님 강의를 다 들었다고 했는데 그래서 그런지 이번 미션하는 게 굉장히 수월했다. 칭찬을 많이 해줘서 뿌듯하게 페어 프로그래밍 할 수 있었다. 중간에 우르와 같이 이해가 안 되는 부분이 있었는데 납득할 만한 결론이 나온 것도 좋았다. 주장이 부딪힐 때 의견을 접지 않고 설득하려는 부분도 좋았다. 쓰고 나니 칭찬밖에 없네\n- 점심에 우르, 주노, 레오와 연어 식당에 갔다. 연어 식당에서 연어 비빔밥을 먹었다. 레오와 이야기 안 해봤는데 오늘 꽤 이야기한 것 같아서 좋았다.\n- 미션 구현이 빨리 끝났다. 내일 테스트 코드만 작성하면 돼서 조금 여유롭다. 하고 싶은 공부를 할 수 있어서 기쁘다~\n- 박스터와 저녁에 체스해서 졌다. 체스 어렵네;;; 열심히 하지는 않았지만 역시 머리 쓰는 거라 어려운 듯.. 주드에게 체스 실력 삼투압 받았어야 했는데 못 받아서 졌나 보다~\n\n## 배운 것\n- `@Controller` 에서 상태 코드 지정 없이 void를 리턴하게 되면 view를 찾을 수 없다는 예외가 발생한다. 그런데 201 상태 코드를 지정하면 예외가 발생하지 않아서 이상하다고 생각했다. 찾아보니 상태 코드를 지정하지 않으면 자동으로 200 상태 코드가 지정되는데, 200이 반환되면 `DispatcherServlet` 이 뷰를 렌더링 해야 한다고 가정하게 된다. 제공된 view가 없으므로 view를 찾을 수 없다는 예외 메시지를 던지게 된다. 201의 경우에는 `DispatcherServlet` 이 요청이 성공적으로 처리되어 view를 렌더링할 필요가 없는 것으로 간주한다.\n- `@ResponseStatus` 를 사용하여 status code를 지정해 줄 수 있다.\n\n```java\n@Controller\npublic class MyController {\n\n    @PostMapping(\"/my-endpoint\")\n    @ResponseStatus(HttpStatus.CREATED)\n    public void handlePostRequest() {\n        // handle the request and create the new resource\n    }\n}\n```\n\n- `resources/data.sql` 에 insert 문을 적어두면 자동으로 값을 넣어준다. (auto-increment 값도 넣어줘야 한다.)\n\n```sql\ninsert into product(id, name, price, image_url)  \nvalues (1, '피자', 10000, 'https://t1.daumcdn.net/cfile/tistory/241D303357DD2A1404');  \n  \ninsert into product(id, name, price, image_url)  \nvalues (2, '치킨', 20000, 'https://pelicana.co.kr/resources/images/menu/best_menu03_200623.jpg');\n```\n\n애플리케이션이 실행되면 data가 자동으로 삽입 된다.\n\n- validation 코드 작성하기\n\n```\n// build.gradle\nimplementation 'org.springframework.boot:spring-boot-starter-validation'\n```\n\ngradle에 의존성을 작성해준다.\n\n```java\nimport javax.validation.constraints.NotBlank;  \nimport javax.validation.constraints.Positive;  \n  \npublic class ProductModifyRequest {  \n  \n    @NotBlank  \n    private String name;  \n  \n    @Positive  \n    private int price;  \n  \n    @NotBlank  \n    private String imageUrl;  \n  \n    public ProductModifyRequest() {  \n    }  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public int getPrice() {  \n        return price;  \n    }  \n  \n    public String getImageUrl() {  \n        return imageUrl;  \n    }  \n}\n```\n\nvalidation 어노테이션을 사용해서 값 검증을 한다.\n\n## 궁금한 것\n- `@Validated` 와 `@Valid` 의 차이점이 뭘까?\n- axios는 뭘까\n\n## 어려웠던 것\n\n## 느낀 것\n- 친구가 쓴 블로그 글을 보게 되었는데, 가치관 글이었다. 최근에 내 가치관에 대해서 생각해 볼 일이 있었는데 나와 다르게 좀 더 긍정적인 글이라 신기했다. 멋지다고 생각하는 친구인데 가치관도 멋있어서 좀 본받아야겠다고 생각했다. 지금 밝고 긍정적으로 살고 있으니까 이때를 틈타서 긍정적인 가치관을 가져보는 것도 좋을 것 같다.\n- 사람마다 공부의 방식이 다른 것 같다는 생각을 요즘 더 많이 한다. 강의가 정말 잘 맞는 사람도 있고, 책 읽는 게 도움이 많이 되는 사람도 있다. 나는 어떻게 공부하나... 생각해 봤는데, 항상 뭔가를 사용해보고 이해가 안 되거나 궁금한 부분을 알아보는 방식으로 공부하는 게 제일 재밌는 것 같다. 생각해보면 예전부터 뭔가를 먼저 배우고 사용하는 건 너무 재미없었다. 앞으로도 부딪히면서 배워가는 사람이 되고 싶다.\n- 오늘은 많이 공부하고 배웠다. 이번주 시작한 지 2일 되기는 했지만 ㅋㅋ 주간 회고 모임에서 다짐했던 것처럼 이번 주에는 미션에 좀 더 열중하고 있어서 기쁘다. 이번 리뷰어는 럿고인데, 좋은 리뷰 받았으면 좋겠다!\n- 조급하지 않다. 조급하지 않은 게 좋은 걸까 아닌 걸까 싶다. 앞으로 인생이 좀 남았으니 너무 조급하지 않은 게 좋은 것 같다가도 내년에는 취업을 하고 싶은데 그걸 생각하면 좀 더 조급해야 할 것 같다. 내가 모든 걸 챙길 수는 없지만 지금 내가 챙겨야 할 걸 못 챙기고 있는 건 아닐까..? 그런 생각이 갑자기 든다. 뭐든 확신이 없어서 그런 듯. 조만간 뭐 어떻게든 방향을 정해야겠다."},{"excerpt":"4/25 2주차 목표 템플릿 엔진을 이용해 페이지 응답을 경험한다. 웹 애플리케이션에서의 테스트와 전구간 기능 테스트 구현을 경험한다. 인증 방법에 대해 학습하고 직접 구현해본다. Spring MVC Configuration 설정을 경험한다. Spring MVC 에서 MVC는 무엇을 의미하고 활용하는 이유를 궁금해 해보자. 목표와 계획을 제출한 이유 내가…","fields":{"slug":"/level2-week2/"},"frontmatter":{"date":"2023년 04월 25일 01:04","title":"레벨2 2주차","tags":["레벨2","우테코"]},"rawMarkdownBody":"# 4/25\n\n## 2주차 목표\n\n- 템플릿 엔진을 이용해 페이지 응답을 경험한다.\n- 웹 애플리케이션에서의 테스트와 전구간 기능 테스트 구현을 경험한다.\n- 인증 방법에 대해 학습하고 직접 구현해본다.\n- Spring MVC Configuration 설정을 경험한다.\n- Spring MVC 에서 MVC는 무엇을 의미하고 활용하는 이유를 궁금해 해보자.\n\n## 목표와 계획을 제출한 이유\n\n내가 잘 알고 있는 것이 맞는가? 어떻게 하면 더 잘 알 수 있을까? 에 대해 스스로에게 계속해서 질문을 던지자.\n\n## 한 번 세운 목표와 계획은 끝까지 가야 하나?\n\n목표: 레벨2 로드맵에 있는 것들을 제대로 알고 쓰고 싶다.\n방법: 학습 로그 스터디를 하고, 공부하면서 모르는 내용을 계속해서 마인드맵처럼 공부하자.\n\n다음의 질문을 계속하자.\n- 레벨2가 끝날 때 내가 세운 목표를 달성했을 때의 내 모습이 만족스러울 것 같은가?: 만족스러울 것이다. 그러나 더 알았어야 했나라는 생각은 들 것 같다.\n- 목표를 달성하는 것이 진정 내가 원하는 모습인가? 내가 원하는 모습에 도달하기 위한 목표는 아닌가? : 원하는 모습은 내가 쓰는 기술들을 알고 쓰는 것이다. 시간은 많으니 지금은 도달하지 못하더라도 계속해서 목표에 가까워지는 사람이 될 수 있을 것이다.\n- 계획을 달성하면 목표에 도달할 수 있는가?: 도달할 수는 있지만, 완전히 도달할 수 있는지는 알 수 없다.\n- 실행하는 데 어려움은 없었는가? 그 어려움은 해결할 수 없는 어려움은 아닌가?: 아직은 무엇을 모르는지, 어떤 것을 알아야 하는지 알지 못한다. 무언가를 판단하기에 지금은 너무 이른듯하다.\n\n## Spring MVC 어디까지 왔나?\n\nSpring MVC Annotation + Exception -> 오늘\nDispatcher Servlet이 추구하는 패턴 -> 두 번째 피드백 강의\nHTTP & REST, API 설계 -> 금요일 강의\n인증 + Spring MVC Configuration -> 다음 주 화요일 강의\n\nSpring MVC Configuration이나 Spring MVC Annotation 등에서 삽질을 많이 해봐야 Dispatcher Servlet을 이해하기 수월할 것이다.\n\n## Template Engine\n(오늘 토리랑 허브랑 이야기한 내용인데 나와서 신기하다 ㅋㅋ)\n\n![[request-structure.png]]\n\nview는 Dispatcher Servlet에 의해 변환된다.\n템플릿을 가지고 view가 결과물을 만들어서 Web browser에 전달한다.\n\n```java\n@Controller\npublic class SampleController{\n\n\t@RequestMapping(value = ~~)\n\tpublic String SampleMethod(Model model) {\n\t\tmodel.addAttribute(\"~~~~\");\n\t\treturn \"sample\";  // sample 이라는 template를 찾는다.\n\t}\n}\n```\n\n템플릿의 기본 경로는 src/main/resources/templates이다.\n\nSpring MVC는 thymeleaf view를 찾고, thymeleaf는 template으로 렌더링을 한다. 렌더링한 것을 web browser한테 전달한다.\n\n## SpringBootTest\n\n@SpringBootTest\n\n-   ﻿﻿테스트 환경을 손쉽게 설정하도록 도와줌\n-   ﻿﻿ApplicationContext를 자동으로 생성하여 테스트에서 사용할 수 있게 함\n-   ﻿﻿기존 @ ContextConfiguration의 발전된 기능\n\n### webEnvironment\n\n@SpringBootTest의 webEnvironment 속성을 사용하여 테스트 서버의 실행 방법을 설정\n\n-   ﻿﻿MOCK: Mocking된 웹 환경을 제공, MockMvC를 사용한 테스트를 진행 할 수 있음. 가짜 웹 환경을 구성한다.\n-   ﻿﻿RANDOM_PORT: 실제 웹 환경을 구성\n-   ﻿﻿DEFINED_PORT: 실제 웹 환경을 구성, 지정한 포트를 listen\n-   ﻿﻿NONE: 아무런 웹 환경을 구성하지 않음\n\n![[mockmvc.png]]\n\n## RestAssured\n\n![[rest-assured-test.png]]\nRANDOM_PORT를 쓰면 포트 번호를 모르니까 주입을 받아야 한다. \n\n주입 받을 때 `@LocalServerPort` 로 주입을 받아야 한다.\n\n```java\n@LocalServerPort\nint port;\n\n@BeforeEach\npublic void setUp() {\n\tRestAssured.port = port;\n}\n```\n\nRestAssured와 SpringBootTest로 전체 테스트를 경험해보자.\n\n왜 부분이 아닌 전체를 검증할까?   \n부분과 전체 중에 어떤 것이 더 중요할까?  \n\n# 4/28\n\n## 좋은 API 설계란?\n\n### API 설계를 꼭 잘해야 하는가?\n\n그냥 서버와 클라이언트 간의 약속만 잘하면 되는 거 아닌가?\n\nbut...\n- 한 번 정해진 API는 바꾸기 쉽지 않다. API의 변경에 클라이언트가 영향을 받기 떄문이다.\n- 새로운 데이터 요소와 비즈니스 규칙이 계속 추가/변경될 수 있다. 확장성 있는 API를 만들게 되면 앞으로의 시간을 아낄 수 있다.\n- 잘 설계된 API는 커뮤니케이션 비용을 아껴준다.\n\n### API 설계 표준화 시도\n\n- 한 곳에 모아서 비교할 수 있는 서비스가 있었지만 없어졌다.\n- 표준을 만드는 시도들이 있었지만 거의 사용되지 않고 있다.\n- 각 서비스들마다 요구사항이 다르고 환경이 다르다.\n- 자신들만의 설계를 원하는 경향이 있다.\n\n### 좋은 API 특징\n\n- 배우기 쉬울 것\n- 문서가 없어도 사용하기 쉬울 것\n- ﻿﻿잘못 사용하기 어려울 것\n- ﻿﻿읽기 쉽고, API를 사용하는 코드를 유지보수하기 쉬울 것\n- ﻿﻿요구사항을 만족시키기에 충분히 강할 것\n- ﻿﻿확장하기 쉬울 것\n- ﻿﻿사용하는 사람들의 수준에 맞을 것\n\n## REST\n\n미션 권장사항은 아님.\n\n### REST 란?\n\n- ﻿﻿WWW(web)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍 처의 한 형식, 로이 필딩의 2000년 논문을 통해서 공개\n- 당시 웹은 큰 성공을 거두었지만 발전이 너무 빨라 관련 내용에 대한 표준이나 문서가 부족한 시기\n- ﻿﻿웹과 같은 시스템이 어떻게 동작해야 하는지에 대한 구조적 모델을 만들어내고 표준 역할을 하기 위해 몇 가지 제약 조건을 만들어 냄\n- ﻿﻿웹 기반으로 동작하는 대부분의 서비스도 글 뿐이 아닌 다양한 형태로 제공되기 때문에 분산 하이퍼미디어 시스템으로 볼 수 있음\n\n### 요즘 REST 용어의 사용\n\n- 최초 소개되었던 목적 보다 다소 과하게 쓰이기도 함\n- 잘못 사용되는 경우도 많음\n- 역사적인 관점에서 SOAP API와 경쟁관계인 시점에 마케팅 버즈워드로 많 이 사용되면서 SOAP 계열의 반대 슬로건으로 사용됨\n- 그럼에도 리소스와 URI의 개념 등 API 설계 시 중요한 요소로 잘 스며들었다고 평가됨\n- RESTful API 규칙이라고 불리는 것은 참고만 하고, 추상적인 제약 조건을 이해하고 일부 조건의 구체적인 세부 규칙을 직접 정해보자.\n- 이게 어렵다면 굳이 REST를 시도하지 말고 HTTP 프로토콜 사용법에 맞는 정도로만 API를 설계하자.\n\n## 용어 설명\n\n### 리소스\n\n자원과 내부적인 클래스 설계는 다를 수 있다. \n또한 클래스 설계는 데이터베이스와 다를 수 있다.\n\n주소창으로 요청을 보내면 웹 페이지를 응답받을 수 있다.\n페이지나 json 형태의 문자열을 응답으로 받을 수 있다.\n서버로부터 얻을 수 있는 자원이 리소스다.\n\n즉, 리소스란\n- 네트워크 데이터 개체\n- 클라이언트가 얻길 원하는 것\n- URI로 식별할 수 있는 대상\n\n## URI - path와 query\n\n- path: 계층적 형태로 구성된 데이터\n- query: 비계층적 형태로 구성된 데이터\n\n### 리소스의 표현\n\n서버로부터 응답 받는 것은 리소스인가? -> 아니다.\n\n`RacingCar` 를 받는다고 했을 때 실제로 `RacingCar` 를 응답 받는 것이 아니라 표현을 전달받는 것이다.\n\n서버는 리소스의 표현만 내려주는 것이 아니라 해석하는 방법을 알려줘야 한다.\n=> 클라이언트가 리소스에 GET 요청을 보내면 서버는 그 리소스를 나타내는 방법을 제공해야 한다.\n\n```http\nContent-Type: application/json;charset=UTF-8\n```\n\n### 만약 여러 개의 표현이 있는 리소스라면?\n\n- /racingcars/1이라는 리소스를 요청할 때 html 표현과 json 표현이 있다면 어떻게 해야할까?\n\t- html: 1번 레이싱카를 소개하는 페이지\n\t- json: 1번 레이싱카의 정보를 응답하는 JSON\n\n## 많이 사용하는 API 설계\n\n### 리소스 네이밍 가이드\n\n- https://restfulapi.net\n\n```java\n@RestController\npublic class CartApiController {\n\t@PostMapping(\"/cart/add/{productId}\")\n\tpublic ResponseEntity addCart(@PathVariable String productId) {\n\t\tcartService.addCart(autoService.toCart(Long.parseLong(productId)));\n\t\treturn new ResponseEntity(HttpStatus.OK);\n\t}\n}\n```\n\nCart의 add는 계층이라고 보기 어렵다. \nadd를 빼고, POST로 표현하는 것이 더 좋지 않을까.\n\n```java\n@RestController\npublic class HttpMethodController {\n\t@GetMapping(\"/items\")\n\tpublic ResponseEntity<Void> addItem(@RequestBody Item item) {\n\t\tItem item = itemService.addItem(item);\n\t\treturn ResponseEntity.ok().build();\n\t}\n}\n```\n\nGET이 아닌 POST가 되면 좋을 것 같다.\nok 대신 201 (CREATED) 를 사용하면 좋겠다."},{"excerpt":"LOG 네오의 면담 일정이 열렸다. 금요일 5시가 비어있길래 바로 신청했다. 딱 그 때가 가장 널널할 것 같았다. 면담 일정이 열림과 동시에 리뷰어->리뷰이 피드백이 와서 읽어봤다. 다행히(?) 좋은 말이 많아서 기분이 좋았다. 초반에 리뷰어한테 댓글도 안 남기고 그냥 피드백 혼자 반영한 적이 있었는데 그 때 피드백이 있었다. 지금은 고쳐서 다행이다. 그…","fields":{"slug":"/2023-04-24/"},"frontmatter":{"date":"2023년 04월 24일 11:04","title":"2023년 04월 24일","tags":null},"rawMarkdownBody":"\n## LOG\n- 네오의 면담 일정이 열렸다. 금요일 5시가 비어있길래 바로 신청했다. 딱 그 때가 가장 널널할 것 같았다. 면담 일정이 열림과 동시에 리뷰어->리뷰이 피드백이 와서 읽어봤다. 다행히(?) 좋은 말이 많아서 기분이 좋았다. 초반에 리뷰어한테 댓글도 안 남기고 그냥 피드백 혼자 반영한 적이 있었는데 그 때 피드백이 있었다. 지금은 고쳐서 다행이다. 그래도 아직까지는 잘하고 있구나 싶다.\n- 늦게 일어났다. 요즘 계속 피곤해서 그런가 잠을 계속 자게 된다. 잠을 못 자던 옛날보다는 나은 거 같기도 하고..? 점심은 못 먹었지만 잠실 오기 전에 비요뜨를 먹고 와서 그나마 나았다. \n- 토리가 준 비타민 구미 택배를 드디어 뜯었다. 약 한 달 만이다..ㅋㅋㅋ 이제는 비타민을 좀 챙겨먹으려고 한다. 아침 저녁으로 1개씩 먹으려고 비타민 통도 들고 왔다. 앞으로 꾸준히 먹어보자~\n- 요즘 집이 개판이다. 집에 있을 일도 없고 저녁까지 잠실에 있다보니 청소할 시간도 없다...라는 핑계를 대본다. 오늘은 집에 가서 뭐라도 해결을 좀 해봐야겠다. 미루지 말고 뭐라도 하자 😂\n\n## 배운 것\n- 스터디 중에 궁금했던 내용 공부했다 : [[mock-vs-mockbean|@Mock vs @MockBean]]\n- 오늘의 스터디 주제: [[webmvctest|@WebMvcTest]]\n- `@ControllerAdvice` 가 여러 개 있는 경우 `@Order` 를 사용하면 순서를 보장할 수 있다고 한다. 그렇지만 `@Order` 를 쓰는 것보다는 하나의 `@ControllerAdvice` 에 예외 처리를 몰아두는 것을 스프링에서는 더 권장한다고 한다.\n\n## 궁금한 것\n- 계속 서블릿 관련 이야기가 나오는데 서블릿이 뭘까?\n\n## 어려웠던 것\n- Dispatcher Servlet, Auto-Configuration 부분 내용을 배운 적이 없다 보니까 이해하기가 좀 어려웠다.  그 부분 공부하기 전에 이해가 안 됐던 부분을 정리하고 더 파봐야겠다.\n\n## 느낀 것\n\n- 공부에 집중을 많이 했다. 오늘 베포헤말 스터디도 있었고 굉장히 많은 걸 얻어갈 수 있었다. 항상 생각하는 거지만 스터디는 강제성이 생겨서 좋다. 특히 내가 발표해야 하는 스터디다 보니까 더 강제성이 부여되는 게 좋다. 혼자였다면 Dispatcher Servlet이고 Auto-Configuration이든 아무것도 안 찾아봤을 것 같은데 나보다 더 똑똑한 크루들이 설명해주는 내용이라 더 좋은 것 같다 ㅋㅋㅋ 스터디에서 배운 내용 공부를 더 열심히 해보려고 한다. 오늘 한 내용 솔직히 잘 이해는 못한 것 같아서 좀 더 찾아보고 공부하는 시간을 가져야 겠다. 역시 공부하는 게 재밌다.\n- 예전이라면 어려운 내용이 나오고 내용이 잘 이해가 안 됐을 때 자괴감이 들었을텐데, 요즘은 안 그래서 좋다. 오히려 내가 모르겠는 부분이 나오면 주저없이 물어볼 수 있게 되었다는 게 제일 멋진 변화라고 느낀다. 자존심을 내려놓고 (정확하게 말하면 내려놨다기보다는 모르는게 부끄럽지 않다는 걸 알게 됐다...? 가 더 맞을 듯 하다) 질문하는 습관을 들이게 되어 기쁘다. 앞으로도 어제의 나보다 더 나아지는 내가 되자!"},{"excerpt":"Mockito.mock()  메서드를 사용하면 클래스나 인터페이스의 mock 객체를 만들 수 있다.\n 으로 Mock 객체의 행동을 정의할 수 있다. (stub: mock 객체의 기대행위를 작성하는 것) mock 클래스 필드나 메서드의 지역 mock 객체를 생성하는데 사용할 수 있다. @Mock  메서드의 축약어이다. 테스트 클래스에서만 사용해야 한다.\n …","fields":{"slug":"/mock-vs-mockbean/"},"frontmatter":{"date":"2023년 04월 24일 10:04","title":"Mock vs MockBean","tags":["개발","spring"]},"rawMarkdownBody":"\n## Mockito.mock()\n\n```java\n@Test\npublic void givenCountMethodMocked_WhenCountInvoked_ThenMockedValueReturned() {\n    UserRepository localMockRepository = Mockito.mock(UserRepository.class);\n    Mockito.when(localMockRepository.count()).thenReturn(111L);\n\n    long userCount = localMockRepository.count();\n\n    Assert.assertEquals(111L, userCount);\n    Mockito.verify(localMockRepository).count();\n}\n```\n\n`Mockito.mock()` 메서드를 사용하면 클래스나 인터페이스의 mock 객체를 만들 수 있다.\n`Mockito.when(메서드).thenReturn(리턴값)` 으로 Mock 객체의 행동을 정의할 수 있다. (stub: mock 객체의 기대행위를 작성하는 것)\n\nmock 클래스 필드나 메서드의 지역 mock 객체를 생성하는데 사용할 수 있다.\n\n## @Mock\n\n`Mockito.mock()` 메서드의 축약어이다. 테스트 클래스에서만 사용해야 한다.\n`mock()` 메서드와 달리 `MockitoJUnitRunner` 를 사용하여 테스트를 실행하거나 `MockitoAnnotations.initMocks()` 메서드를 명시적으로 호출하여 실행할 수 있다.\n\n단, `@SpringBootTest` 또는 `@SpringMvcTest` 를 사용하여 mock 객체를 생성하는 `@MockBean` 및 테스트하려는 클래스의 인스턴스를 가져오는 `@Autowired` 와 함께 스프링 컨텍스트를 시작하면 mock bean이 autowired 의존성에 사용된다. \n\n데이터베이스와 상호 작용하는 코드에 대한 통합 테스트를 작성하거나, REST API를 테스트하고자 할 때 이 방법을 사용한다.\n\n## @MockBean\n\n스프링 컨텍스트에 mock 객체를 등록하고, 스프링 컨텍스트에 의해 `@Autowired` 가 동작할 때 등록된 mock 객체를 사용할 수 있도록 동작한다.\n\nmock 객체를 애플리케이션 컨텍스트에 추가하기 위해 `@MockBean` 을 사용할 수 있다. mock 객체는 애플리케이션 컨텍스트에서 동일한 유형의 기존 bean을 대체한다. \n\n동일한 유형의 bean이 정의되어 있지 않으면 새로운 bean을 추가한다. 해당 어노테이션은 외부 서비스와 같은 특정 bean을 mocking 해야 하는 통합 테스트에 유용하다.\n\n## 언제 사용하나?\n\nSpring Boot Container가 테스트 시에 필요하고, Bean이 Container에 존재한다면 `@MockBean` 을 사용하고 아닌 경우에는 `@Mock` 을 사용한다.\n\n`@WebMvcTest` 어노테이션을 사용하는 경우, Controller까지는 로드되지만 Controller의 협력 객체인 Service는 로드 되지 않는다. 따라서 Controller에 요청을 보낼 때 Service가 Bean Container에 생성되어 있지 않다면 NPE가 발생하게 된다.\n\n다음 예제로 확인해보자.    \n`RacingCarController` 는 `RacingCarService` 에 의존성을 가지고 있는 `@RestController` 이다.   \n`RacingCarService` 내부에는 `RandomMoveStrategy` 라는 객체를 갖는다. 랜덤하게 값을 생성하여 움직일 수 있는지 없는지 확인하는 `isMovable()` 이라는 메서드를 제공한다.\n\n`RandomMoveStrategy` 의 값이 랜덤하지 않고 항상 true를 리턴하도록 `@Mock` 어노테이션을 사용하여 행위를 정의했다.\n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  \n  \n    @Autowired  \n    private ObjectMapper objectMapper;  \n  \n    @Mock  \n    // @MockBean\n    private RacingCarService racingCarService;  \n  \n    @Mock  \n    RandomMoveStrategy randomMoveStrategy;  \n  \n    @Test  \n    void play_메서드가_적절한_형식을_반환한다() throws Exception {  \n        final PlayRequest playRequest = new PlayRequest(\"브리,토미,브라운\", 1);  \n        final String request = objectMapper.writeValueAsString(playRequest);  \n        Car bri = new Car(\"브리\");  \n        Car tomi = new Car(\"토미\");  \n        Car brown = new Car(\"브라운\");  \n        List<Car> cars = List.of(bri);  \n        final PlayResponse playResponse = PlayResponse.of(  \n                RacingCarWinnerDto.of(cars),  \n                List.of(  \n                        RacingCarStatusDto.from(bri),  \n                        RacingCarStatusDto.from(tomi),  \n                        RacingCarStatusDto.from(brown)  \n                )  \n        );  \n  \n        // given  \n        given(randomMoveStrategy.isMovable()).willReturn(true);  \n        given(racingCarService.play(any(PlayRequest.class)))  \n                .willReturn(playResponse);  \n  \n        // then  \n        mockMvc.perform(post(\"/plays\")  \n                        .content(request)  \n                        .contentType(MediaType.APPLICATION_JSON))  \n                .andExpect(status().isOk())  \n                .andExpect(jsonPath(\"$.winners[0]\").value(\"브리\"))  \n                .andExpect(jsonPath(\"racingCars\", hasSize(3)))  \n                .andExpect(jsonPath(\"$.racingCars[0].name\").value(\"브리\"))  \n                .andExpect(jsonPath(\"$.racingCars[0].position\").value(0));  \n    }  \n}\n```\n\n`@MockBean` 을 사용해야 하는 `RacingCarService` 를 `@Mock` 으로 선언하게 되면, `RacingCarController` 에서 필요한 `RacingCarService` 를 auto-wiring 할 수 없게 된다.\n\n```\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'racingcar.service.RacingCarService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}\n```\n\n그러나 `RandomMoveStrategy` 가 `@MockBean` 어노테이션으로 변경되었을 때는 아무런 예외가 발생하지 않는다.\n`RandomMoveStrategy` 는 bean이 아니지만, Spring Bean Container가 관리해도 아무런 영향이 없기 때문에 예외가 발생하지 않는다.\n\n즉, `@MockBean` 은 Bean Container에 생성되어야만 하는 mock 객체일 때 사용하면 된다.\n\n## 참고 자료\n\n- https://www.baeldung.com/java-spring-mockito-mock-mockbean\n- https://stackoverflow.com/questions/44200720/difference-between-mock-mockbean-and-mockito-mock"},{"excerpt":"WebMvcTest 어노테이션 WebMvcTest 는 Spring MVC controller를 테스트하기 위해 사용되는 Spring Boot의 어노테이션이다.\n이 어노테이션은 전체 auto-configuration을 비활성화하고 대신 MVC 테스트와 관련된 구성만 적용한다.\n즉, Application Context 를 완전하게 Start 하지 않고 Web…","fields":{"slug":"/webmvctest/"},"frontmatter":{"date":"2023년 04월 24일 04:04","title":"WebMvcTest","tags":["spring","레벨2","학습로그","스터디"]},"rawMarkdownBody":"\n## WebMvcTest 어노테이션\n\nWebMvcTest 는 Spring MVC controller를 테스트하기 위해 사용되는 Spring Boot의 어노테이션이다.\n이 어노테이션은 전체 auto-configuration을 비활성화하고 대신 MVC 테스트와 관련된 구성만 적용한다.\n즉, Application Context 를 완전하게 Start 하지 않고 Web Layer를 테스트 하고 싶을 때 `@WebMvcTest` 를 사용하는 것을 고려해볼 수 있다.\n\n단위 테스트를 위해 Spring MVC 인프라를 자동으로 구성하지만, 스캔되는 Bean을 `@Controller`, `@ControllerAdvice`, `@RestController`, `@JsonComponent`, `Filter`, `WebMvcConfigurer`, `HandlerMethodArgumentResolver` 로 제한한다.    \n만약 Service나 Repository의 Dependency가 필요한 경우에는 `@MockBean` 으로 주입 받아 테스트를 진행한다.    \n\n`@WebMvcTest`를 사용할 때, 일반 `@Component`, `@Service`, `@Repository` bean은 스캔되지 않는다.   \n따라서 `@MockBean` 또는 `@SpyBean` 을 사용하여 가짜 객체를 bean으로 등록해주어야 한다.    \n\n## @SpringBootTest\n\n프로젝트 안의 모든 bean을 등록하여 테스트를 한다. 단위 테스트처럼 기능을 테스트할 때보다는 통합 테스트를 할 때 사용한다.\n\n서버를 띄우고 모든 bean을 등록하기 때문에 다양한 테스트 중에서 가장 운영환경과 유사한 테스트이다.\n\n그러나 모든 bean을 로드하기 때문에 테스트 구동 시간이 오래 걸리고, 테스트 단위가 크기 때문에 디버깅이 어려울 수 있다.\n\nController 레이어만 테스트하고 싶을 때에는 `@WebMvcTest` 를 쓰는 것이 유용하다.\n\n## WebMvcTest 사용하기\n\n기본적으로 `@WebMvcTest` 로 주석을 단 테스트는 Spring Security 및 MockMvc도 자동으로 구성한다.\n\n테스트 클래스에 `@WebMvcTest` 어노테이션을 달고 테스트할 컨트롤러를 지정한다.\n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest\n```\n\n이렇게 테스트할 컨트롤러를 지정하게 되면 전체 애플리케이션 컨텍스트가 아닌 `RacingCarController` 만 구성하게 된다.\n\n해당 테스트에 적용해서는 안 되는 auto-configuration 클래스를 제외하도록 `excludeAutoConfiguration` 옵션을 지정할 수도 있다.\n\n```java\n@WebMvcTest(\n    controllers = RacingCarController.class,\n    excludeAutoConfiguration = SecurityAutoConfiguration.class,\n    excludeFilters = {\n        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = SecurityConfig.class)}\n)\n```\n\n`excludeAutoConfiguration`: 해당 테스트에 적용되는 자동 설정들에서 제외할 빈을 등록할 수 있다.   \n`excludeFilters` : 추가되는 bean들 중에 제외하고 싶은 Bean의 필터를 등록한다. 즉, `classes`에 들어갈 Bean을 제외하기 위한 필터를 정의하는 것이다. `ASSIANABLE_TYPE` 속성은 제외할 기준을 클래스로 지정한다.    \n\n```java\n@WebMvcTest(RacingCarController.class)   \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  // 주입 O  \n\n\t...\n}\n```\n\n`@WebMvcTest` 만 선언해주어도, MockMvc 객체가 주입되게 된다.   \n또한 `@MockBean` 을 사용해서 필요한 의존성에 대해 mock 구현을 제공할 수도 있다.\n\nWeb Layer 관련 빈들만 등록하기 때문에, 컨트롤러는 주입이 정상적으로 되지만, `@Component` 로 등록된 Repository와 Service는 주입이 되지 않는다.  \n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  // 주입 가능하다.\n  \n    @Autowired  \n    private RacingCarService racingCarService;  // 주입이 되지 않는다.  \n\t...\n}\n```\n\n따라서, `@WebMvcTest` 에서 Repository와 Service를 사용하기 위해서는 `@MockBean` 을 사용하여 bean으로 등록해주어야 한다.  \n\n`@MockBean` 이란 가짜 객체로, 호출과 결과를 임의로 조작하여 해당 단위 테스트에만 집중할 수 있도록 도와준다.   \n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  \n  \n    @MockBean  \n    private RacingCarService racingCarService;  // 주입이 가능하다.   \n  \n    @Mock  \n    RandomMoveStrategy randomMoveStrategy;   // Service 내부에서 사용하는 RandomMoveStrategy Mocking   \n\n\t...\n}\n```\n\n### 테스트 코드 작성해보기\n\n```java\n    @Test  \n    void play_메서드가_적절한_형식을_반환한다() throws Exception {  \n        final PlayRequest playRequest = new PlayRequest(\"브리,토미,브라운\", 1);  \n        final String request = objectMapper.writeValueAsString(playRequest);  \n        Car bri = new Car(\"브리\");  \n        Car tomi = new Car(\"토미\");  \n        Car brown = new Car(\"브라운\");  \n        List<Car> cars = List.of(bri);  \n        final PlayResponse playResponse = PlayResponse.of(  \n                RacingCarWinnerDto.of(cars),  \n                List.of(  \n                        RacingCarStatusDto.from(bri),  \n                        RacingCarStatusDto.from(tomi),  \n                        RacingCarStatusDto.from(brown)  \n                )        );  \n  \n        // given  \n        given(randomMoveStrategy.isMovable()).willReturn(true);  \n        given(racingCarService.play(any(PlayRequest.class)))  \n                .willReturn(playResponse);  \n  \n        // then  \n        mockMvc.perform(post(\"/plays\")  \n                        .content(request)  \n                        .contentType(MediaType.APPLICATION_JSON))  \n                .andExpect(status().isOk())  \n                .andExpect(jsonPath(\"$.winners[0]\").value(\"브리\"))  \n                .andExpect(jsonPath(\"racingCars\", hasSize(3)))  \n                .andExpect(jsonPath(\"$.racingCars[0].name\").value(\"브리\"))  \n                .andExpect(jsonPath(\"$.racingCars[0].position\").value(0));  \n    }\n}\n```\n\n`given()`, `when()`, `willReturn()`, `thenReturn()` 메서드들은 BDDMockito에 정의되어 있다.\n\n`@MockBean` 으로 등록한 Service의 행동을 `given()` 으로 지정해준다.  \n`willReturn()` 에서는 해당 행동에서 어떤 값을 리턴해야 하는지 지정한다.\n\n`perform()` 에서 컨트롤러에 요청을 전송한다.  \n`andExpect()`에서는 응답을 검증하는 역할을 한다.   \n`status()` 은 상태 코드를 검증한다.\n`content()` 은 응답에 대한 정보를 검증할 수 있다.\n\n### WebMvcTest의 장단점\n\n`@WebMvcTest`를 사용하면 Spring MVC에 집중한 테스트를 할 수 있다.   \nWeb Layer에 필요한 bean들만 등록하기 때문에 상대적으로 빠르고 가벼운 테스트를 할 수 있다.   \n또한 통합 테스트가 어려운 상황에서 Mock으로 테스트할 수 있다는 장점이 있다.   \n\n그러나 요청부터 응답까지 모든 테스트를 Mock 기반으로 테스트하기 때문에 실제 환경에서는 오류가 발생할 수 있다는 단점이 있다.   \n\n이러한 이유로 `@WebMvcTest` 는 컨트롤러 테스트나 단위 테스트 시에 많이 사용한다.   \n\n### 추가 : @RunWith 은 안 써도 될까?\n\n구글링을 하다보면 많은 코드에서 Test를 작성할 때 `@RunWith(SpringRunner.class)` 를 같이 써준 것을 볼 수 있다.\n\n```java\n// 많이 찾아볼 수 있는 코드\n@RunWith(SpringRunner.class) \n@WebMvcTest(RacingCarController.class) \npublic class Test { \n\t... \n}\n```\n\nJUnit4를 사용한다면 `@RunWith(SpringRunner.class)` 를 같이 추가해줘야지만 annotation이 무시되지 않는다.   \nJUnit5를 사용한다면 `@RunWith`을 추가해 줄 필요가 없다. JUnit5에서는 `@WebMvcTest` 에도 `@RunWith` 어노테이션이 내장되어 있다.   \n\n![[junit-dependency.png]]\n\n이번 jwp-racingcar 미션에서는 JUnit5가 의존성에 포함되어 있기 때문에 테스트 코드마다 매번 `@RunWith` 를 써줄 필요가 없다.\n\n## 참고 자료\n\n- [공식 문서](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/web/servlet/WebMvcTest.html)\n"},{"excerpt":"LOG 네오, 에밀, 망고, 토리, 포이, 여우, 주노와 함께 점심을 먹었다. 원래 토도로끼에 갈 생각이었는데 사람들이 너무 많아서 네오가 아는 곳으로 제육을 먹으러 갔다. 네오와 같이 앉아서 이야기를 했는데 영화에 대한 이야기를 하다가 종교에 대한 이야기를 하게 됐다. 나와 가치관이 비슷한 부분이 많아서 되게 재밌게 이야기 했다 ㅋㅋㅋ 박스터, 주드, …","fields":{"slug":"/2023-04-20/"},"frontmatter":{"date":"2023년 04월 21일 00:04","title":"2023년 04월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 네오, 에밀, 망고, 토리, 포이, 여우, 주노와 함께 점심을 먹었다. 원래 토도로끼에 갈 생각이었는데 사람들이 너무 많아서 네오가 아는 곳으로 제육을 먹으러 갔다. 네오와 같이 앉아서 이야기를 했는데 영화에 대한 이야기를 하다가 종교에 대한 이야기를 하게 됐다. 나와 가치관이 비슷한 부분이 많아서 되게 재밌게 이야기 했다 ㅋㅋㅋ\n- 박스터, 주드, 망고, 토리, 포이와 교촌치킨에서 저녁을 먹었다. 살면서 교촌치킨 콤보는 먹어본 적 없는데 처음으로 먹어봤다. 그렇지만 역시 콤보 같이 뼈가 있는 메뉴는 먹기 귀찮아서 많이 먹기 힘들다..ㅋㅋㅋ\n- 어쩌다보니 금요일 약속에 에밀도 끼고 토리도 시간이 된다고 해서 같이 술을 마시기로 했다~~ 감기가 거의 다 나아서 내일 술을 마시는 건 괜찮을 거 같다. 재밌겠다~\n- 머리를 자르려고 미용실을 예약했다. 머리를 기르다가 못해먹겠어서..ㅋㅋㅋ 다시 단발로 돌아간다. 항상 이정도 길이까지 기르고 잘랐다. 생각보다 머리 기르는 게 쉽지 않다. 하는 김에 폰케이스도 샀다. 지금 살 게 많은데 사러 가기 귀찮아서 미루다 보니까 집에 없는 게 굉장히 많다. 토요일에 한 번에 사러가야겠다.\n\n## 배운 것\n- TEXT와 VARCHAR의 차이점에 대해 정리했다: [[text-vs-varchar]]\n- 허브신의 코드를 보고 `@WebMvcTest` 에 대해 배웠다.\n\n`@WebMvcTest(RacingCarController.class)` WebMvcTest 어노테이션을 달아준다.\n\n```java\n@Autowired  \nprivate MockMvc mockMvc;  \n  \n@Autowired  \nprivate ObjectMapper objectMapper;  \n  \n@MockBean  \nprivate RacingCarService racingCarService;  \n  \n@Mock  \nRandomMoveStrategy randomMoveStrategy;\n\n@Test  \nvoid play_메서드가_적절한_형식을_반환한다() throws Exception {  \n    final PlayRequest playRequest = new PlayRequest(\"브리,토미,브라운\", 1);  \n    final String request = objectMapper.writeValueAsString(playRequest);  \n    Car bri = new Car(\"브리\");  \n    Car tomi = new Car(\"토미\");  \n    Car brown = new Car(\"브라운\");  \n    List<Car> cars = List.of(bri);  \n    final PlayResponse playResponse = PlayResponse.of(  \n            RacingCarWinnerDto.of(cars),  \n            List.of(  \n                    RacingCarStatusDto.from(bri),  \n                    RacingCarStatusDto.from(tomi),  \n                    RacingCarStatusDto.from(brown)  \n            )    );  \n  \n    // given  \n    given(randomMoveStrategy.isMovable()).willReturn(true);  \n    given(racingCarService.play(any(PlayRequest.class)))  \n            .willReturn(playResponse);  \n  \n    // then  \n    mockMvc.perform(post(\"/plays\")  \n                    .content(request)  \n                    .contentType(MediaType.APPLICATION_JSON))  \n            .andExpect(status().isOk())  \n            .andExpect(jsonPath(\"$.winners[0]\").value(\"브리\"))  \n            .andExpect(jsonPath(\"racingCars\", hasSize(3)))  \n            .andExpect(jsonPath(\"$.racingCars[0].name\").value(\"브리\"))  \n            .andExpect(jsonPath(\"$.racingCars[0].position\").value(0));  \n}\n```\n\n`given()` 에 어떤 행동을 하면 `willReturn()` 에 어떤 값을 리턴할지를 정한다.\n`RacingCarService` 에서 사용하는 `RandomMoveStrategy` 를 mock 하기 위해 `@Mock` 어노테이션을 붙여준다.\n`RacingCarService` 는 bean으로 등록되어 있는 클래스이기 때문에 `@MockBean` 을 붙여준다.\n\n## 궁금한 것\n- mock으로 테스트하는 게 정말 의미가 있을까?\n\n## 어려웠던 것\n\n## 느낀 것\n- 네오와 이야기를 하면서 내가 왜 살고 있는지에 대해 더 생각해볼 필요가 있다고 느꼈다.\n- 알고리즘을 풀어야 될까, 말아야 할까 고민이 된다. 다들 알고리즘을 풀고 있는데, 내 생각에 알고리즘은 꾸준히 많은 문제를 풀면 많이 풀 수 있는 거 같다. 물론 선배는 문제를 한 번에 많이 푸는 기간이 있어야 한다고 하기는 했지만ㅋㅋ 우테코 내에서 알고리즘을 하는 게 맞을지 아닐지 아직 고민중이다."},{"excerpt":"LOG 이동욱님의 강의가 있었다. 자존감 높이기에 대한 이야기였는데, 내가 기댈 수 있는 기둥을 여러 개 만들어두라는 말이 있었다. 지금의 나의 자존감 기둥에는 뭐가 있을까... 생각해볼 수 있었던 시간이었다. 주노, 포이, 글렌과 함께 한강 공원에 갔다. 생각보다 벌레가 많았다... 오늘 날씨가 좋아서 롯데월드도 가고 싶었고, 보드 게임 카페도 갈까 하…","fields":{"slug":"/2023-04-19/"},"frontmatter":{"date":"2023년 04월 19일 14:04","title":"2023년 04월 19일","tags":null},"rawMarkdownBody":"## LOG\n- 이동욱님의 강의가 있었다. 자존감 높이기에 대한 이야기였는데, 내가 기댈 수 있는 기둥을 여러 개 만들어두라는 말이 있었다. 지금의 나의 자존감 기둥에는 뭐가 있을까... 생각해볼 수 있었던 시간이었다.\n- 주노, 포이, 글렌과 함께 한강 공원에 갔다. 생각보다 벌레가 많았다... 오늘 날씨가 좋아서 롯데월드도 가고 싶었고, 보드 게임 카페도 갈까 하다가 너무 시간이 애매해서 그냥 바람만 쐬다가 왔다. 날씨가 좋아서 그런지 되게 재밌었다. 맥주는 마시지 말 걸 (?) 그랬다... 마시자마자 기침이 났다. 이제 감기가 그만 좀 나았으면 좋겠다.\n\n## 배운 것\n- Spring Core를 정리했다: [[spring-core]]\n- 저번에 Pure Fabrication 관련해서 Factory를 예제로 들었었는데, 올바른 예제였다. [[grasp]] 에서 확인해볼 수 있다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 내일은 MockMvc에 대해 공부해볼 생각이다. 지금 미션에 테스트가 하나도 없는데 단위 테스트를 추가해서 커밋해봐야겠다. "},{"excerpt":"LOG 2단계 미션 PR을 보냈다. PR 보낼 때 질문을 많이 생각해보려다가 브라운이 리뷰어들이 질문에 대답하는 게 오래 걸린다고 해서 그냥 생각난 것 하나만 적었다. Bean을 만드는 기준에 대해서 질문했는데 아마도 답이 없는 질문이라 just 리뷰어의 생각이 궁금하다. 결국 병원에 갔다. 갑자기 깃짱이랑 얘기하다가 목이 간지럽더니 기침을 안 쉬고 20…","fields":{"slug":"/2023-04-18/"},"frontmatter":{"date":"2023년 04월 18일 14:04","title":"2023년 04월 18일","tags":null},"rawMarkdownBody":"## LOG\n- 2단계 미션 PR을 보냈다. PR 보낼 때 질문을 많이 생각해보려다가 브라운이 리뷰어들이 질문에 대답하는 게 오래 걸린다고 해서 그냥 생각난 것 하나만 적었다. Bean을 만드는 기준에 대해서 질문했는데 아마도 답이 없는 질문이라 just 리뷰어의 생각이 궁금하다.\n- 결국 병원에 갔다. 갑자기 깃짱이랑 얘기하다가 목이 간지럽더니 기침을 안 쉬고 20번 정도 했다. 기침을 많이 하면 생리적으로 눈물이 난다는 사실 알고 계셨나요 다들. 왠지 모르게 울고 있는 사람 돼서 토리가 많이 걱정했다. 병원에 갔는데 신속항원검사부터 하라고 해서 혹시나 코로나인가 해서 걱정했다. 다행히 음성이 나와서 나한테 옮은 주드는 그냥 감기인 걸로... ^^ 약을 3일간 먹어야 하는데 금주령이 내려졌다. 금요일에 술을 마셔야겠다.\n- 오늘 강의 실습 시간에 네오, 포이, 주노와 함께 필드 주입과 프록시 객체에 대해 이야기를 나눴다. 역시 책을 읽거나 검색으로 지식을 늘리는 것보다 사람들과 이야기 하면서 지식을 얻는 게 즐거운 거 같다.\n- 포이 테코톡 리허설을 들었다. 제대로 공부하고 많이 알고 있다보니 발표를 잘하는게 느껴졌다. 스크립트 없이 발표하는 게 신기했다.\n\n## 배운 것\n- **필드 주입이 안 좋은 이유? (Easy to add too many dependencies 가 생기는 이유가 무엇일까?)** : 필드가 늘어나면 객체 생성 책임이 늘어나는지 모른다. 그런데 생성자에서는 알 수 있다. 필드 주입을 하게 된다면 의존성이 런타임에서 변경될 수 있다. (트레이드 오프 있음) -> final을 못 쓰는 것과 동일한 이유이다.\n- **생성자 주입이 왜 테스트에 좋은가?**: 이미 우리가 의존성 주입을 잘 구현해놔서 지금은 크게 와닿지 않을 수 있다.\n- **필드 주입과 생성자 주입을 동시에 하면 뭐가 우선일까?**: 생성자 주입이 먼저 실행되고 필드 주입으로 덮어씌워진다.\n- **Repository 의존성 주입을 할 때 프록시 객체가 만들어지는가?**: 만들어진다. DB Vendor마다 다른 예외 변환을 위해서이다.\n- **@Controller는 프록시 객체가 만들어질까?**: 안 만들어진다. (뇌피셜) 스프링 내부에서 통제할 수 있기 때문에 그런 거 아닐까.\n- @Service는 사실상 @Component와 다를 게 없다. 명시적으로 DDD 관점에서 서비스인 걸 알려주기 위해 추가된 기능이다.\n- **스프링 빈을 모두 등록하는 게 좋을까?**: 스프링 빈을 모두 등록할 때 성능상 차이는 크게 고려하지 않아도 된다. 그러나 스프링을 모두 걷어냈을 때 제대로 작동하는 프로그램으로 수정하기 어려워진다. (라이프 사이클이 스프링에 종속되기 때문에) 그렇기 때문에 의존성을 최대한 줄이는 방향으로 설계해야 한다.\n\n## 궁금한 것\n- `Optional` 의 `orElseGet`은 왜 supplier null check를 하지 않는걸까 by 포이\n\n## 어려웠던 것\n\n## 느낀 것\n- 진지하게 몸을 가만히 못 있겠다. 뭐라도 흔들어야 할 것 같은.. 그런 기분이 든다 ㅋㅋㅋㅋㅋ 아니 진짜 진지하다... 에너지가 넘친다기보다는 그냥 뭔가 ... 뭐라도 해야 할 것 같은 느낌이 들어서 가만히 못 있겠다. 실제로 아무것도 못할 수가 없다. 집중력이 낮아지는 거 같다.\n- 왜 느낀 것이 점점 줄어들까 생각해봤다. 역시 요즘 생각 없이 살고 있는 거 같다. 좋게 말하면 긍정적이고 재밌게 살고, 안 좋게 말하면 아무 생각 없이 막 살고 있다. 그런데 굳이 나쁘게 생각할 필요 있나? 좋은 점을 보자 ㅋㅋ"},{"excerpt":"Scan   는 repository(DAO로 알려진) 의 역할을 하는 class에 붙인다.\n 를 사용하면 예외의 자동변환을 가능하게 해준다. (Exception Translation) Spring은 추가적인 어노테이션을 제공한다.\n, ,  는 일반적으로 Spring에서 관리하는 component이다.\n, ,  는  의 특화 버전으로 더 구체적인 사용 ca…","fields":{"slug":"/spring-core/"},"frontmatter":{"date":"2023년 04월 18일 02:04","title":"Spring Core","tags":["레벨2","우테코","개발","spring"]},"rawMarkdownBody":"\n## Scan\n\n### `@Component`\n\n`@Repository` 는 repository(DAO로 알려진) 의 역할을 하는 class에 붙인다.\n`@Repository` 를 사용하면 예외의 자동변환을 가능하게 해준다. (Exception Translation)\n\nSpring은 추가적인 어노테이션을 제공한다.\n`@Component`, `@Service`, `@Controller` 는 일반적으로 Spring에서 관리하는 component이다.\n`@Repository`, `@Service`, `@Controller` 는 `@Component` 의 특화 버전으로 더 구체적인 사용 case를 위해 사용된다. \n\ncomponent 클래스들에 `@Component` 어노테이션을 쓸 수는 있지만, `@Repository`, `@Service`, `@Controller` 를 사용하면 tool로 처리하거나 aspect(비즈니스 로직 외에 다른 기능들이 정의되어 있는 모듈)들과 연결하여 더 적절하게 다뤄질 수 있다.\n`@Service` 는 `@Component` 와 다른 바가 없지만, DDD 관점에서의 사용을 위해 추가된 어노테이션이다.\n`@Repository`, `@Service`, `@Controller` 는 Spring의 이후 release에서 추가적인 의미를 전달할 수도 있다. 따라서 service layer에 `@Component`, `@Service` 둘 중 하나의 어노테이션을 붙여야 한다면, `@Service` 가 더 좋은 선택이다.\n\n마찬가지로 앞서 설명한 것처럼 `@Repository` 는 persistence layer에서 자동 예외 변환을 위한 marker로서 지원되고 있다.\n\n## DI\n\n### Dependencies\n\n일반적인 엔터프라이즈 애플리케이션은 단일 객체(bean)로 구성되지 않는다. 가장 단순한 애플리케이션 조차도 end-user 에게 서비스를 제공할 때 여러 개의 객체들이 협력해서 기능을 제공하게 된다.\n\n### Dependency Injection\n\nDI(의존성 주입)는 객체들이 자신들의 의존성을 무어\n\nContainer는 bean을 만들 때 의존성을 주입해준다. \n이런 과정은 근본적으로 클래스를 직접 생성하여 사용하는 것 또는 Service Locator Pattern을 사용하여 bean 자체가 의존성의 위치와 인스턴스화를 제어하는 IoC(제어의 역전)이다.\n\nDI 원칙을 따르는 코드는 더 깔끔하고, 객체들이 의존성들을 제공받을 때 decoupling(낮은 결합도) 측면에서 더 효과적이다.\n주입받는 객체는 의존성을 찾지 않아도 되고, 의존성의 위치나 클래스를 알지 못한다.\n결론적으로 의존성이 인터페이스나 추상 클래스에 있는 경우 단위 테스트에서 stub 또는 mock 구현을 사용할 수 있어 테스트하기 더 쉽다.\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies)\n\n### Constructor-based Dependency Injection\n\nConstructor-based DI(생성자 주입)는 container가 constructor를 호출하여 수행된다. \n정적 팩토리 메서드를 호출해서 bean을 생성하는 것은 거의 동일한 방법이다.\n\n```java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on a MovieFinder\n    private final MovieFinder movieFinder;\n\n    // a constructor so that the Spring container can inject a MovieFinder\n    public SimpleMovieLister(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n```\n\ncontainer 특정 인터페이스나 base 클래스, 어노테이션에 대한 종속성이 없는 POJO 이다.\n\n**POJO**\nPlain Old Java Object\n어떤 특정 framework이나 convention에 종속되지 않거나 property들과 method의 naming convention에 구속되지 않는 Java 객체다.\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection)\n\n### Setter-based Dependency Injection\n\nSetter-based DI(setter 주입)는 container가 bean을 인스턴스화하기 위해 매개변수가 없는 consturctor를 호출하거나 매개변수가 없는 정적 팩토리 메서드를 호출하고 setter 메서드를 호출하는 것이다.\n\n순수 setter 주입을 사용해서 의존성 주입이 가능한 클래스이다. 해당 클래스는 기존 Java 클래스로, 특정 container 인터페이스, base 클래스, 어노테이션에 대한 종속성이 없는 POJO이다.\n\n```java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on the MovieFinder\n    private MovieFinder movieFinder;\n\n    // a setter method so that the Spring container can inject a MovieFinder\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n```\n\n`ApplicationContext` 는 관리할 bean들을 위해 생성자 주입과 setter 주입을 지원한다.\n몇몇 의존성이 이미 constructor 을 통해 주입된 후에도 setter 주입이 가능하다.\n`BeanDefinition` 의 형태로 의존성을 설정하고, `PropertyEditor` 인스턴스와 함께 사용하여 property들을 하나의 format에서 다른 형태로 변환한다.\n\n그러나 대부분의 Spring 사용자들은 이러한 클래스를 직접 사용하는 것이 아니라 XML의 bean 정의와 `@Component`, `@Controller` 등의 어노테이션이 달린 클래스의 `@Bean` 메서드를 사용하여 작업한다.\n내부적으로 `BeanDefinition` 의 인스턴스로 변환되어 전체 Spring IoC container 인스턴스를 로드하는데 사용된다.\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-setter-injection)\n\n### Constructor-based DI vs Setter-based DI\n\n생성자 주입과 setter 주입은 혼합사용이 가능하기 때문에, 필수 의존성에는 생성자 주입을 사용하고 선택적 의존성에는 setter 메서드나 configuration 메서드를 사용하는 것이 좋다. setter 메서드에 `@Autowired` 어노테이션을 사용하면 필드를 필수 의존성으로 만들 수 있지만 프로그래밍 유효성 검사를 통해 생성자 주입을 사용하는 것이 바람직하다.\n\n일반적으로 생성자 주입을 지지한다. 애플리케이션 컴포넌트를 불변 객체로 구현하고 필요한 의존성이 null이 되지 않도록 보장하기 때문이다. 생성자 주입하는 컴포넌트가 항상 완전히 초기화된 상태로 클라이언트에 반환된다. 생성자 매개변수가 많게 되면 code smell 이고, 클래스에 너무 많은 책임이 있을 수 있어서 적절한 분리를 위해 리팩터링해야 한다는 뜻이다.\n\nsetter 주입은 주로 클래스 내에서 합리적인 default value를 할당할 수 있는 선택적 의존성에만 사용해야 한다. 그렇지 않으면 의존성을 사용하는 모든 곳에서 null이 아닌지 검사를 수행해야 한다. \n\nsetter 주입의 한 가지 이점은 setter 메서드를 사용하면 해당 클래스의 객체를 나중에 재구성하거나 다시 주입할 수 있다는 것이다. (JMX MBeans를 통한 관리에서 setter 주입을 사용한다.)"},{"excerpt":"LOG 월급을 받아서 토리, 망고, 포이랑 저녁에 표현 식당에 가서 고기를 먹었다. 표현 식당 처음 가봤는데 사장님이 우리 명찰을 보시고 예전에 회식 왔던 사람들이랑 같은 회사(?)냐고 물어보셔서 신기했다 ㅋㅋㅋ 2단계 구현을 완료했다. 구현할 게 많지 않아서 금방 끝났다. 그런데 잘한건지는 잘 모르겠다.. 데일리 미팅 때 마피아를 하고 나서 액션 훈민정…","fields":{"slug":"/2023-04-17/"},"frontmatter":{"date":"2023년 04월 17일 14:04","title":"2023년 04월 17일","tags":null},"rawMarkdownBody":"## LOG\n- 월급을 받아서 토리, 망고, 포이랑 저녁에 표현 식당에 가서 고기를 먹었다. 표현 식당 처음 가봤는데 사장님이 우리 명찰을 보시고 예전에 회식 왔던 사람들이랑 같은 회사(?)냐고 물어보셔서 신기했다 ㅋㅋㅋ\n- 2단계 구현을 완료했다. 구현할 게 많지 않아서 금방 끝났다. 그런데 잘한건지는 잘 모르겠다..\n- 데일리 미팅 때 마피아를 하고 나서 액션 훈민정음 게임을 했다. 훈민정음을 몸으로 표현하고 채채한테 패스 받는 거였는데 너무 웃겼다 ㅋㅋㅋㅋ 관중들이 늘어나니까 훈수가 많아져서 더 웃겼다. 아침 데일리가 웃기니까 하루 종일 즐거운 마음으로 지낼 수 있었다. 네오조... 정말 데일리를 열심히 즐기는 거 같다 ㅋㅋㅋ\n- 감기가 여전히 떨어지지 않고 있다. 주노가 약을 사다줬다. **THANKS JUNO...** He is angel. 내일 낫는 건 때려치우고 이번 주 안에 낫는 걸 목표로 하려고 한다. 병원은 가기 싫다.\n\n## 배운 것\n- `@Bean` 을 `@Configuration` 에 등록하지 않고 사용하면 싱글톤이 보장되지 않는다.\n- `groupingBy` 는 매개변수로 classifier라는 함수형 인터페이스가 필요하다. \n```java\nMap<Long, List<Player>> playersGroupingByGameId = allPlayers.stream()  \n        .collect(Collectors.groupingBy(Player::getGameId));\n```\n\n어떤 값으로 grouping 할 지를 매개변수로 넣는다.\n\n## 궁금한 것\n- 자동차 경주 콘솔 애플리케이션을 만들 때도 웹 애플리케이션의 Service를 써도 되는걸까? 서로 별개여야 되는 거 아닐까?\n\n## 어려웠던 것\n\n\n## 느낀 것\n- 조용히 말하기... 실패 중이다. 웃으면 데시벨 조절이 안 돼서 굉장히 먼 곳에서도 내 목소리가 들린다고 한다. 좀 더 조용히 말해보려고 노력은 할 거지만 잘 될 거라는 자신은 없다 ㅋㅋㅋ 그렇지만 최선을 다했으니 오케이입니다.\n- 공부가 잘 됐다. 오늘 목표한 미션 구현을 완료할 수 있어서 다행이다. 집중하고 싶을 때 페어룸으로 폐관수련 가려고 한다. 확실히 공부할 수 있는 조용한 환경이 있으면 공부가 잘 되는 거 같다.\n"},{"excerpt":"DAO Data Access Object의 약자이다. DAO는 data persistence (애플리케이션과 데이터베이스 사이를 추상화한 계층을 제공하는 것) 를 추상화한 것이다.\nDAO는 data mapping과 접근을 관리하고, 애플리케이션으로부터 쿼리의 복잡함을 숨겨준다.\n주로 table 중심적이고, 데이터베이스에 더 가까우며 low level 개념…","fields":{"slug":"/dao-vs-repository/"},"frontmatter":{"date":"2023년 04월 15일 14:04","title":"DAO vs Repository","tags":["개발","spring"]},"rawMarkdownBody":"\n## DAO\n\nData Access Object의 약자이다. \n\nDAO는 data persistence (애플리케이션과 데이터베이스 사이를 추상화한 계층을 제공하는 것) 를 추상화한 것이다.\nDAO는 data mapping과 접근을 관리하고, 애플리케이션으로부터 쿼리의 복잡함을 숨겨준다.\n주로 table 중심적이고, 데이터베이스에 더 가까우며 low level 개념으로 간주된다.\n많은 경우, database 테이블과 일치하게 된다.\n\n## Repository\n\n객체들의 집합을 추상화한 것이다. \ndomain 객체에 더 가까운 개념으로 Aggregate Roots만 다루는 상위 개념이다.\n\n도메인 객체에 접근하기 위한 collection 과 유사한 interface를 사용하여 domain 객체와 \ndata mapping layer 사이를 중재한다. \n즉, Repository는 객체의 Collection을 다루듯이 캡슐화(인터페이스)를 제공한다는 점에서 테이블보다는 객체 중심의 layer라고 할 수 있다.\n\n객체 중심으로 데이터를 다루기 위해 하나 이상의 DAO를 사용할 수 있어 DAO보다 상위 layer라고 할 수 있다.\n\n## DAO vs Repository\n\n프로젝트 요구 사항에 따라 구현은 주관적일 수 있다.\n\nDAO는 간단한 CRUD 작업에 더 적합하며 구현하기 쉽다.\nRepository는 여러 테이블을 포함하는 복잡한 작업에 더 적합하며 더 높은 수준의 추상화를 제공한다.\n\n## 참고 자료\n\n- https://www.baeldung.com/java-dao-vs-repository"},{"excerpt":"LOG 감기 금방 나을 줄 알았는데 진짜 안 낫는다. 말을 많이 하면 기침이 나온다. 그래서 의도치 않은 열혈 마스크 맨이 되었다... 월요일에 잠실 가기 전까지 나았으면 좋겠다. 음식 쓰레기를 버렸다. 일주일간 냉장고에 함께한 치킨이 떠났다. 떠나보내는 김에 이것저것 같이 떠나보냈다. 마음이 후련했다. 하는 김에 설거지도 했다. 집이 깨끗해졌다. 배운 …","fields":{"slug":"/2023-04-15/"},"frontmatter":{"date":"2023년 04월 15일 13:04","title":"2023년 04월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 감기 금방 나을 줄 알았는데 진짜 안 낫는다. 말을 많이 하면 기침이 나온다. 그래서 의도치 않은 열혈 마스크 맨이 되었다... 월요일에 잠실 가기 전까지 나았으면 좋겠다.\n- 음식 쓰레기를 버렸다. 일주일간 냉장고에 함께한 치킨이 떠났다. 떠나보내는 김에 이것저것 같이 떠나보냈다. 마음이 후련했다. 하는 김에 설거지도 했다. 집이 깨끗해졌다.\n\n## 배운 것\n- `@Controller` 와 `@RestController` 의 차이점을 알아보았다: [[controller-vs-restcontroller]]\n- Spring에서는 HikariCP 로 DB Connection을 공유한다. 여러 개의 Connection 을 미리 생성해두고, Connection이 필요할 때마다 할당해준다. 프로그램마다 최적의 Connection 개수는 다르다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 요즘 긴 글은 많이 못 쓰고, 짧은 글을 많이 양산하고 있다. 그래도 아무것도 안 쓰는 것보다는 낫다고 생각한다. "},{"excerpt":"네트워크 HTTP/2.0 Server Push HTTP/2.0 Binary Framing HTTP/2.0 Multiplexing 어떤 페이지에서는 왜 HTTP 버전이 다른 리소스가 존재할까? 소켓 쿠키와 세션 CORS 에러 HTTPS 웹서버와 WAS 서버 무상태성이란? Spring bean Filter Servlet Dispatcher Servlet  v…","fields":{"slug":"/technical-debt/"},"frontmatter":{"date":"2023년 04월 15일 04:04","title":"기술 부채","tags":["기술부채"]},"rawMarkdownBody":"\n## 네트워크\n- HTTP/2.0 Server Push\n- HTTP/2.0 Binary Framing\n- HTTP/2.0 Multiplexing\n- 어떤 페이지에서는 왜 HTTP 버전이 다른 리소스가 존재할까?\n- 소켓\n- 쿠키와 세션\n- CORS 에러\n- HTTPS\n- 웹서버와 WAS\n\n## 서버\n- 무상태성이란?\n\n## Spring\n- bean\n- Filter\n- Servlet\n- Dispatcher Servlet\n- `@Validated` vs `@Valid` -> TIL에 정리해둔 거 글로 정리하기\n- objectmapper의 역직렬화 과정 -> dto 기본 생성자가 private이 가능한 이유\n- Spring Validation\n\n## SQL\n- outer join vs inner join\n- cascade\n\n## 아키텍처"},{"excerpt":"는  클래스가 특화된 것으로, classpath scanning 을 통해 구현 클래스들을 자동으로 감지하도록 해준다. 보통  와  어노테이션이 함께 쓰인다.  어노테이션은 리턴되는 객체를  로 자동 직렬화하도록 한다.  Spring 4.0 에서 RESTful 웹서비스 생성을 단순화 하기 위한  가 소개되었다.\n 는  와  를 합친 어노테이션이다.\n 가 존…","fields":{"slug":"/controller-vs-restcontroller/"},"frontmatter":{"date":"2023년 04월 15일 02:04","title":"Controller vs RestController","tags":["개발","spring"]},"rawMarkdownBody":"\n## `@Controller`\n\n`@Controller` 는 `@Component` 클래스가 특화된 것으로, classpath scanning 을 통해 구현 클래스들을 자동으로 감지하도록 해준다.\n\n보통 `@Controller` 와 `@RequestMapping` 어노테이션이 함께 쓰인다.\n\n```java\n@Controller\n@RequestMapping(\"books\")\npublic class SimpleBookController {\n\n    @GetMapping(\"/{id}\", produces = \"application/json\")\n    public @ResponseBody Book getBook(@PathVariable int id) {\n        return findBookById(id);\n    }\n\n    private Book findBookById(int id) {\n        // ...\n    }\n}\n```\n\n`@ResponseBody` 어노테이션은 리턴되는 객체를 `HttpResponse` 로 자동 직렬화하도록 한다.\n\n## `@RestController`\n\nSpring 4.0 에서 RESTful 웹서비스 생성을 단순화 하기 위한 `@RestController` 가 소개되었다.\n`@RestController` 는 `@Controller` 와 `@ResponseBody` 를 합친 어노테이션이다. \n`@RestController` 가 존재하는 클래스의 모든 메서드에는 `@ResponseBody` 어노테이션이 존재하는 것과 같다. \n\n`@RestController` 는 controller의 특화 버전이다.\n\n```java\n@RestController\n@RequestMapping(\"books-rest\")\npublic class SimpleBookRestController {\n    \n    @GetMapping(\"/{id}\", produces = \"application/json\")\n    public Book getBook(@PathVariable int id) {\n        return findBookById(id);\n    }\n\n    private Book findBookById(int id) {\n        // ...\n    }\n}\n```\n\n`@RestController` 어노테이션이 붙은 클래스들은 `@ResponseBody` 가 필요하지 않다.\n모든 Controller의 Request Handling method는 리턴되는 객체들을 `HttpResponse` 로 자동적으로 직렬화한다.\n\n## 두 어노테이션의 차이점\n\n`@Controller` 는 reponse가 주로 HTML 페이지인 UI 기반의 애플리케이션에서 사용된다. \n메서드가 view name을 리턴하면 view resolver 가 해당하는 view를 찾아 응답한다.\n\n`@RestController` 는 데이터를 HTML로 변경하는 server-side rendering을 수행하지 않고, HTTP response를 JSON 또는 XML로 전달한다.\n\n## 참고 자료\n\n- https://www.baeldung.com/spring-controller-vs-restcontroller\n"},{"excerpt":"포이가 TEXT와 VARCHAR의 차이점이 무엇인 것 같냐고 물어봐서 알아보게 되었다. TEXT 긴 문자열을 저장할 수 있는 가변 길이 데이터 유형이다. 고정된 최대 크기 문자 개수는 2^16 - 1 이다. TEXT(M) 은 M <= 255 에서 2 + c 바이트의 디스크 공간을 차지한다. (c는 저장된 문자열의 길이) index의 완전한 일부가 될 수 …","fields":{"slug":"/text-vs-varchar/"},"frontmatter":{"date":"2023년 04월 14일 11:04","title":"TEXT와 VARCHAR의 차이점은 무엇일까?","tags":["개발"]},"rawMarkdownBody":"\n포이가 TEXT와 VARCHAR의 차이점이 무엇인 것 같냐고 물어봐서 알아보게 되었다.\n\n## TEXT\n\n- 긴 문자열을 저장할 수 있는 가변 길이 데이터 유형이다.\n- 고정된 최대 크기 문자 개수는 2^16 - 1 이다.\n- TEXT(M) 은 M <= 255 에서 2 + c 바이트의 디스크 공간을 차지한다. (c는 저장된 문자열의 길이)\n- index의 완전한 일부가 될 수 없고, prefix length를 지정해야 한다.\n\n## VARCHAR\n\n- 최대 크기 M에 대해 2^16-1 의 가변 크기를 갖는다.\n- TEXT보다 더 적은 공간을 차지한다.\n- VARCHAR(M) 은 1 + c 바이트 (M <= 255 인 경우) 또는 2 + c 바이트 (256 <= M <= 65535) 의 디스크 공간을 차지한다.\n- index의 일부가 될 수 있다.\n- 8비트 code page로 제한되는 non-Unicode character data type이다.\n- NVARCHAR 보다 디스크 공간을 덜 차지한다.\n\n## NVARCHAR\n- 모든 Unicode data를 저장할 수 있는 Unicode character data type이다.\n- VARCHAR 대신 NVARCHAR를 사용하면 데이터베이스에서 읽거나 쓸 때마다 인코딩 변환을 수행하지 않아도 된다. 변환에는 시간이 걸리고 오류가 발생하기 쉽다. 발생한 변환 오류로부터 값을 복구하는 것은 어렵다.\n\n## Index\n\n테이블에 효율적으로 접근하기 위한 데이터 구조이다.\n필수는 아니지만 인덱스가 없으면 쿼리 응답 시간이 느려질 수 있다.\n\n인덱스는 테이블과 연관되어 있고, 하나 이상의 테이블 column으로 구성된 키를 갖는다.\n데이터베이스에서 검색 속도를 높이는 데 사용할 수 있다.\n\n## 예제\n\n테이블에 몇 단어에서 몇 단락에 이르는 사용자의 자기소개가 저장된다고 하자.\n이 경우에는 TEXT를 사용하는 것이 좋다. 자기소개는 길이가 매우 다양할 수 있고, index화 하거나 외래 키 제약 조건에 사용될 필요가 없기 때문이다. \n또한 사용자 테이블에 다른 열이 있을 가능성이 높기 때문에 bio 열에 VARCHAR를 사용하여 최대 행 크기인 65535 바이트를 초과하지 않으려는 것이다. TEXT를 사용하면 bio를 행 외부에 저장하고 행에 해당 bio에 대한 포인터만 가질 수 있으므로 행의 크기가 줄어든다.\n\n```sql\nCREATE TABLE user (\n  id INT PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  email VARCHAR(50) NOT NULL,\n  bio TEXT\n);\n```\n\n전자 상거래 웹사이트용 테이블이 있다고 가정하자.\n하나의 column에는 몇 단어에서 몇 문장에 이르는 제품 설명이 저장된다. 이 경우에 description column에는 VARCHAR를 사용한다. 설명이 비교적 짧고, column을 index화하여 외래키 제약 조건에서 사용할 수 있기를 바라기 때문이다. 또한 product 테이블에 다른 column이 있을 가능성이 높으므로 설명 열에 TEXT를 사용하여 최대 행 크기인 65535 바이트를 초과하지 않기 위해서이다. \n\n```sql\nCREATE TABLE product (\n  id INT PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  category VARCHAR(50) NOT NULL,\n  description VARCHAR(255),\n  price DECIMAL(10,2) NOT NULL\n);\n```\n\n즉, 많은 양의 텍스트를 저장해야 하는 경우 TEXT를 사용하고, 비교적 짧은 텍스트를 저장해야 하는 경우에는 VARCHAR를 사용한다. (라는 말 밖에 안 나온다...)\n\n## 그럼 왜 TEXT를 쓸까?\n\n베로 피셜: 엄청 큰 문자열을 저장할 거 아니면 TEXT를 딱히 쓸 이유가 없는 거 같다.\n\n## 결론\n\n몇 단어 또는 문장을 저장하고, (전체) column을 index로 만들거나 외래 키 제약 조건이 있는 column을 사용하려는 경우 VARCHAR를 사용해야 한다.\n\n단락 이상의 텍스트를 저장하려는 경우, column을 index로 만들 필요가 없거나 테이블 column 크기 제한에 도달한 경우 TEXT를 사용해야 한다.\n\n단, VARCHAR 또는 TEXT 필드에 필요한 실제 바이트 수는 column (또는 콘텐츠의 인코딩)에 따라 달라진다는 것을 유의해야 한다.\n"},{"excerpt":"LOG 학습로그 스터디에 말랑이 합류했다! 베포후헤말 스터디가 되었다 ㅋㅋ 이번에 같이 스터디했는데 아는 게 정말 많아서 잘 몰랐던 부분에 대해 많이 도움받을 수 있었다. 역시 스프링 컨트리뷰터 말랑 👍 슬랙에 matzip 서비스 같이 개발할 5기를 모집한다고 해서 주드, 체인저와 같이 신청하기로 했다. 나는 실제 사용자가 있는 서비스를 배포해본 적이 없…","fields":{"slug":"/2023-04-14/"},"frontmatter":{"date":"2023년 04월 14일 11:04","title":"2023년 04월 14일","tags":null},"rawMarkdownBody":"## LOG\n- 학습로그 스터디에 말랑이 합류했다! 베포후헤말 스터디가 되었다 ㅋㅋ 이번에 같이 스터디했는데 아는 게 정말 많아서 잘 몰랐던 부분에 대해 많이 도움받을 수 있었다. 역시 스프링 컨트리뷰터 말랑 👍\n- 슬랙에 matzip 서비스 같이 개발할 5기를 모집한다고 해서 주드, 체인저와 같이 신청하기로 했다. 나는 실제 사용자가 있는 서비스를 배포해본 적이 없어서 만약 참가할 수 있게 된다면 정말 좋은 경험이 될 것 같다. 질문 답변을 열심히 생각해 봐야겠다!! 4기 오리가 matzip 서비스 관리하시는 줄은 몰랐는데 너무 재밌겠다~~\n\n## 배운 것\n- 드디어 spring-jdbc 정리 완료: [[spring-jdbc]]\n- 베포후헤말 스터디에서 준비한 학습로그: [[grasp|GRASP 원칙이란 무엇일까?]]\n\n## 궁금한 것\n- Argument Resolver 를 따로 정의해서 사용하는 방법이 있을까?\n\n## 어려웠던 것\n- 오늘 헤나가 발표했던 argument resolver 내용이 아직 잘 이해가 안 된다. 좀 더 공부해봐야겠다. 앞으로 Argument Resolver를 구현해서 쓸 일이 있을까?\n\n## 느낀 것\n- 요즘 조용히 말하기를 하고 있는데 잘 되고 있는지는 모르겠다..ㅋㅋ 자리를 옮겨볼까 생각도 했는데 이제 다들 자리가 고정된 것 같아서 어디로 이동하는 게 쉽지 않다.\n- 말하는 거에 자신이 없으면 어, 이제, 그, 라는 말을 많이 쓴다는 걸 알게 되었다. 내가 준비한 내용, 준비한 말에 자신이 있고 확신이 있어야 말하기를 잘할 수 있는 거 같다. 후추처럼 말에 군더더기가 없었으면 좋겠다. 좀 더 많이 조사하고, 많이 준비해보자."},{"excerpt":"GRASP General Responsibility Assignment Software Patterns 의 약자로, 일반적인 책임 할당을 위한 소프트웨어 패턴이다. 모든 예제는 체스 미션을 예시로 들 예정이다. Information Expert Pattern (정보 전문가 패턴) 정보 전문가에게 책임을 할당하라.\n객체에게 책임을 할당할 때는 책임을 수행할…","fields":{"slug":"/grasp/"},"frontmatter":{"date":"2023년 04월 14일 00:04","title":"GRASP는 무엇인가요?","tags":["스터디","우테코","학습로그"]},"rawMarkdownBody":"## GRASP\n\n**G**eneral **R**esponsibility **A**ssignment **S**oftware **P**atterns 의 약자로, 일반적인 책임 할당을 위한 소프트웨어 패턴이다.\n\n모든 예제는 체스 미션을 예시로 들 예정이다.\n\n### Information Expert Pattern (정보 전문가 패턴)\n\n**정보 전문가에게 책임을 할당하라.**\n객체에게 책임을 할당할 때는 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당해야 한다.\n\n체스 미션의 Board와 Board를 구성하는 Square와 Piece를 생각해보자.\n\n사용자로부터 move a2 a4 라는 입력을 받은 경우, a2에 있는 말을 a4로 움직여야 한다.\n그렇다면 이 메시지를 수신할 적합한 객체는 무엇일까?\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> ???\n```\n\n객체는 상태와 행동을 통합한 캡슐화의 단위이다.\n따라서, 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.\n\n아마 Board라는 객체가 말을 움직이는 것이 적합해보인다.\nBoard는 말과 현재 턴을 알고 있다. 말을 움직이는 것을 위한 정보 전문가라고 할 수 있다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board\n```\n\n그렇지만 a2에 있는 말이 a4에 갈 수 있는지는 Board가 알 수 없다. 이럴 때는 외부에 도움을 요청해야 한다.\n외부 객체에게 요청해서 말이 움직일 칸으로 이동할 수 있는지를 알아내야 한다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> ???\n```\n\n말이 움직일 칸으로 이동할 수 있는지 계산하는 데 필요한 정보를 알고 있는 전문가는 Piece이다. \n따라서 Information Expert 패턴에 따라 메시지를 수신할 적당한 객체는 Piece가 된다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> Piece\n```\n\n단, 정보 전문가가 데이터를 반드시 저장하고 있을 필요는 없다.\n객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나, 필요한 정보를 계산해서 제공할 수도 있다.\n\nInformation Expert Pattern은 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있으므로 객체가 자율적인 존재가 되도록 돕는다. 필요한 정보를 가진 객체들로 책임이 분산되어 더 응집력 있고, 이해하기 쉬워진다. 따라서 응집도는 올라가고, 결합도가 낮아져서 간결하고 유지보수하기 쉬운 시스템을 구축할 수 있다.\n\n### 높은 응집도와 낮은 결합도\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> Piece\n```\n\n```mermaid\nflowchart LR\n\tPiece -- 해당 칸이 나이트 이동으로 갈 수 있는지 확인해라 --> Direction\n```\n\n이런 식의 설계가 되어 있을 때, Board가 Direction에게 직접 나이트 이동으로 갈 수 있는지 확인해도 되지 않을까?\n\n즉, 다음과 같은 설계를 말한다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> Piece\n\tBoard -- 해당 칸이 나이트 이동으로 갈 수 있는지 확인해라 --> Direction\n```\n기능적인 측면에서는 차이가 없는 것처럼 보인다. \nDirection이 Board와 협력하는 것이 좋을까, Piece와 협력하는 것이 좋을까?\n\n#### Low Coupling (낮은 결합도)\n\n**의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시키도록 책임을 할당하라.**\n\n첫 설계에서는 Board와 Piece가 이미 결합되어 있다.\n이때 Piece와 Direction이 협력하게 하면 설계 전체적으로 결합도를 추가하지 않고도 협력을 완성할 수 있다.\nBoard와 Direction이 협력할 경우에는 새로운 결합도가 추가된다.\n\nLow Coupling 패턴의 관점에서는 새로운 결합도를 추가하지 않는 방향으로 설계하는 것이 좋다.\n\n#### High Cohesion (높은 응집도)\n\n**복잡성을 관리할 수 있는 수준으로 유지하기 위해 높은 응집도를 유지하는 방향으로 책임을 할당하라.**\n\nBoard의 중요한 책임은 말을 움직이는 것이다. 이때, Direction과 협력하게 되면 거리 계산과 관련된 책임을 갖게 될 수 밖에 없다.\n그렇다면 이후 말을 움직이는 방식이 변경되는 경우, Board도 같이 변경되어야 한다. 이런 경우 응집도가 낮아질 수 밖에 없다.\n\n그러나 Piece의 주된 책임은 해당 칸으로 이동할 수 있는지에 대한 것이다.\n따라서 필요한 조건을 확인하기 위해 Direction과 협력하는 것은 응집도에 해를 끼치지 않는다.\n\nHigh Cohesion 패턴 관점에서는 객체들이 서로 관련되도록 설계하는 것이 좋다.\n\n### Creator Pattern (창조자 패턴)\n\n**협력에 참여하는 어떤 객체에게는 인스턴스를 생성할 책임이 있다.\n다음 조건을 최대한 만족하는 객체에게는 객체 생성 책임을 할당하라.**\n\n- B가 A 객체를 포함하거나 참조한다.\n- B가 A 객체를 기록한다.\n- B가 A 객체를 긴밀하게 사용한다.\n- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (B가 A에 대한 정보 전문가이다.)\n\n### Polymorphism (다형성)\n\n**타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라.**\n\nBoard 입장에서 생각했을 때, 말을 움직일 때 말이 어떤 말인지는 상관 없다. 어떤 말이든지 움직일 수 있어야 한다.\n즉, Board가 구체적인 클래스는 알지 못하고 '말'이라는 역할에 대해서만 결합되도록 의존성을 제한할 수 있다.\n\n```mermaid\nclassDiagram\n\tPiece <|-- Knight\n\tPiece <|-- Queen\n\tPiece <|-- King\n```\n\nPiece라는 클래스를 추상화하고, 해당 클래스를 상속하는 Knight, Queen, ... 등의 말을 추가한다.\nBoard는 각 말들 (Queen, Knight...) 의 구현이 바뀌거나 추가되어도 Piece의 추상화된 메서드로만 기능을 수행하기 때문에, 구체적인 타입을 몰라도 괜찮다.\n\n객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당한다. 이를 Polymorphism 패턴이라고 한다.\n\n구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스를 사용한다.\n역할을 대체할 클래스들 사이에서 구현을 공유해야 할 필요가 있다면 추상 클래스를 사용하면 된다.\n\n### Protected Variations (변화에 대한 보호)\n\n객체를 변경으로부터 분리하고, 추상화 타입을 통해 캡슐화한다.\n**변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.**\n\n갑자기 체스의 룰이 크게 바뀌어서 Vero Piece가 추가된다고 하자.\n그렇지만 추상화된 Piece를 사용하면, Board 입장에서 Piece가 추가된다고 해서 Board에게는 영향을 주지 않는다. 오직 VeroPiece라는 클래스를 추가하는 것으로 말을 추가할 수 있다.\n\n이처럼 변경을 캡슐화하도록 책임을 할당하는 것은 Protected Variations 패턴이라고 한다.\n\n추상화 타입을 사용하므로 변경에 더 유연하게 대응할 수 있지만, 코드의 복잡성이 올라간다는 단점이 있다.\n\n### Pure Fabrication (순수 조립)\n\nInformation Expert 패턴을 적용하면 Low Coupling과 High Cohesion의 원칙이 깨어진다면, 기능적인 역할을 별도로 한 곳으로 모으자.\n\n도메인의 개념을 나타내지 않고 낮은 결합도, 높은 응집도, 높은 재사용 가능성을 달성하기 위해 만들어진 클래스를 의미한다. 도메인 중심 설계에서는 'service' 라고 부른다. \n도메인과 직접 관련이 없는 기능이나, 기능을 구현하기 위해 별도의 클래스나 객체를 만드는 것이다.\n**공통적인 기능을 제공하는 역할을 한 곳으로 모아서 가상의 객체, 서브시스템을 만들어라.**\n\nBoard를 생성하는 로직은 보통 하드코딩이 필요하다. \n이런 생성로직을 분리해 놓은 BoardFactory가 존재한다고 생각해보자.\n\nFactory는 도메인 모델에 속하지 않으며, 순수하게 기술적으로 추가된 것이다.\n전체적으로 결합도와 재사용성을 높이기 위해 객체 생성 책임을 가공의 객체로 이동시킨 것이다.\n\n책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 Pure Fabrication이라고 한다.\n\n클래스와 객체가 급증하여 코드가 더 복잡하고 이해하기 어려워질 수 있다는 단점이 있다. 또한 공통 함수와 기능을 수정해야 하는 경우, 여러 클래스와 객체를 변경해야 하므로 시간이 많이 걸리고 오류가 발생할 수 있다.\n또한 Information Expert 원칙을 위배할 수 있다. 특정 정보나 동작에 대한 책임은 해당 정보나 동작에 대한 정보를 가장 많이 보유한 객체에 할당되어야 한다. 그러나 Pure Fabrication 객체가 생성되면 해당 정보 또는 동작에 대한 가장 많은 정보를 가진 객체로부터 책임을 빼앗는 격이 되므로 Information Expert 원칙을 위반할 수 있다.\n\n어떤 객체가 책임을 수행하는 데 필요한 많은 정보를 가졌지만, 해당 책임을 할당한 경우 응집도가 낮아지고 결합도가 높아지는 건 다른 가공의 객체를 추가해서 책임을 옮기는 것을 고민해보자.\n\n### Controller Pattern (컨트롤러 패턴)\n\n**시스템 이벤트를 처리할 객체를 만들어라.**\n\n직접적으로 각 객체에 접근하게 되면, 서브 시스템과 외부간의 Coupling이 증가된다.\n서브시스템의 어떤 객체를 수정할 경우, 외부에 주는 충격이 커진다.\n서브시스템을 사용하는 입장에서 보면, Controller 객체만 알고 있으면 되므로 사용하기 쉽다.\n\nController는 요청을 받고 적절한 행위를 하는 객체에게 지시하는 행위 관점의 패턴이다.\n내부적으로 별도의 비즈니스 로직을 가져서는 안 되고, 요청을 전달하고 위임하는 것에 중점을 두어야 한다.\n\nController 패턴을 사용하면 View와 Model이 서로 영향 없이 쉽게 변경할 수 있게 된다.\nView와 Model이 서로를 직접적으로 알고 있게 되면 각 클래스가 변경이 일어날 때마다 다른 클래스에 변경이 일어나게 된다.\n\nMVC의 컨트롤러는 메서드가 사용자 입력에 응답하는 시스템 이벤트를 나타내는 경향이 있으므로, 일종의 GRASP 컨트롤러라고 할 수 있다.\n\n### Indirection (간접 참조)\n\n**두 객체 사이의 직접적인 `Coupling`을 피하고 싶으면, 그 사이에 다른 객체를 사용하라.**\n\n다른 구성 요소 간에 중재할 책임을 중간 객체에 할당하여 직접 연결이 되지 않도록 한다.\n\nModel 과 View를 중재하기 위해 Controller component를 추가한 것은 간접 참조의 한 예시이다.\nController 객체는 시스템 이벤트를 수신하거나 처리하는 역할을 담당하고, 수행해야 하는 작업을 다른 객체에 위임하고 활동을 조정하거나 제어한다. \nController를 사용하여 View와 Model가 간접 참조를 하게 되면 의존도를 낮추고 변화의 영향을 줄일 수 있다.\n\n중재자 패턴을 사용하여 두 객체 사이에 또 하나의 객체를 추가하여 복잡한 관계를 단순화할 수 있다.\n중간에 인터페이스를 두면 Protected Variation 패턴에 해당한다.\n\n느슨한 연결이 되지만, 시스템의 가독성과 분별력을 떨어뜨린다는 단점이 있다.\n\n## 참고 자료\n\n- [오브젝트](http://www.yes24.com/Product/Goods/74219491?pid=123487&cosemkid=go15597183843649229&gclid=CjwKCAjw0N6hBhAUEiwAXab-TZjHYK2AP78T13MA3x-XoWv8GF71zhDrEzXV3MvFT6ZWEGgDC83C0xoCnPIQAvD_BwE) 5장"},{"excerpt":"LOG 웹 자동차 경주 미션 PR을 보냈다. 조금만 리팩토링하려고 했는데 너무 커져버렸다... DB 설계도 바뀌고 코드도 많이 바뀐 거 같다. 이번에도 리뷰어는 다니인데 어떤 리뷰를 받게 될 지 궁금하다. 키아라의 생일파티에 참여했다. 원래 토리랑 채채랑 같이 간맥할 생각이었는데 초대를 받게 돼서 (사실 초대해달라고 했음) 6시에 범맥주에 갔다. 역시 재…","fields":{"slug":"/2023-04-13/"},"frontmatter":{"date":"2023년 04월 13일 05:04","title":"2023년 04월 13일","tags":null},"rawMarkdownBody":"## LOG\n- 웹 자동차 경주 미션 PR을 보냈다. 조금만 리팩토링하려고 했는데 너무 커져버렸다... DB 설계도 바뀌고 코드도 많이 바뀐 거 같다. 이번에도 리뷰어는 다니인데 어떤 리뷰를 받게 될 지 궁금하다.\n- 키아라의 생일파티에 참여했다. 원래 토리랑 채채랑 같이 간맥할 생각이었는데 초대를 받게 돼서 (사실 초대해달라고 했음) 6시에 범맥주에 갔다. 역시 재밌었고 나름대로(?) 절제하면서 마신 것 같다. 키아라 생일 축하했어~~\n\n## 배운 것\n- **`assertAll()`로 해당 함수들을 묶을 시 중간에 `assert함수`가 실행이 되지 않더라도 assert의 모든 함수를 실행할 수 있다.**\n- `@Repository`에 final을 쓰면 안 된다. 스프링 내부적으로 Respository를 생성할 때 프록시 객체를 생성하기 때문에 Repository는 final이나 invisible한 클래스면 안 된다.\n- `SqlParameterSourceUtils.createBatch()` 로 NamedParameter를 한 번에 매핑해줄 수 있다.\n- `@SpringBootTest` 의 webEnvironment 옵션을 넣은 테스트 클래스와 넣지 않은 테스트 클래스를 동시에 실행할 때만 데이터베이스가 중복 생성되는 이유: webEnvironment 옵션을 사용하지 않은 테스트 클래스는 자바 애플리케이션의 일반적인 테스트를 수행하는 것이다. 이 경우에는 스프링 애플리케이션 컨텍스트가 단 하나만 생성되어 모든 테스트에서 공유된다. 그러나 webEnvironment 옵션을 사용한 테스트 클래스는 스프링 부트 애플리케이션을 실행하는 것으로, 이 경우 각각의 테스트에서 새로운 스프링 애플리케이션 컨텍스트가 생성된다.\n- `@SpringBootTest` 와 `@SpringBootTest(webEnvironment = WebEnvironment.NONE)` 가 달려있는 두 개의 테스트 클래스를 동시에 수행하면 데이터베이스가 중복 생성되는 이유: `@SpringBootTest(webEnvironment = WebEnvironment.NONE)` 는 스프링 애플리케이션을 실행하지 않고, 내장 서버를 사용하지 않도록 설정한다. 따라서 스프링 애플리케이션 컨텍스트는 생성되지만, 웹 환경에서 실행되지 않는다. 반면, `@SpringBootTest` 는 스프링 부트 애플리케이션을 실행하고 내장 서버를 사용한다. 이 경우에는 웹 환경에서 애플리케이션을 실행하므로, 스프링 애플리케이션 컨텍스트와 함께 웹 환경에서 데이터베이스가 생성된다. 따라서 스프링 부트 애플리케이션 컨텍스트가 생성되면서 DB가 중복 생성되게 된다. (아마도 내장 DB는 단 하나 존재하는 모양이다.)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 술을 안 마시려고 했는데 역시 즐거운 자리를 참기 힘들다. 그래도 일주일에 1회만 술을 마신 생각이다. 술 마시고 잠만 어느 정도 잘 수 있다면 그 다음 날 컨디션이 안 좋은 건 아니라서 괜찮을 것 같다.\n- chat-GPT 생각보다 진짜 좋다. 배운 것 중에 Repository에 final을 쓰면 안 되는 이유나, SpringBootTest에 대한 내용도 chat-GPT 한테 물어본 내용이다. 질문을 어떻게 해야 할 지 모를 때, 어떻게 설명해야 할 지 모를 때 그냥 아무렇게나 써도 잘 이해해준다는게 되게 좋은 것 같다. 문제는 얘가 이상한 말을 할 때 내가 알 수 없다는 거? 확실한 지식을 쌓을 수 있을지는 잘 모르겠다. 가끔 얘가 거짓말을 해서 믿어야 될 지 말아야 할 지... 키워드를 얻는 용도로는 확실히 좋은 거 같다."},{"excerpt":"LOG 깃짱이랑 자동차 API 미션을 완료했다!! 미션 완료는 항상 뿌듯하다. 깃짱은 스프링을 처음 해봤다고 했는데 이번 미션동안 잘 이해한 것 같아서 대단하다. 컨디션이 안 좋았다. 아침에 일어날 때부터 목감기 걸린 것처럼 목이 아팠는데 낮에는 열이 났다. 주노가 타이레놀 주니까 좀 나았다. THANK YOU, JUNO... 그렇게 여기 있을 때까지는 …","fields":{"slug":"/2023-04-12/"},"frontmatter":{"date":"2023년 04월 13일 00:04","title":"2023년 04월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 깃짱이랑 자동차 API 미션을 완료했다!! 미션 완료는 항상 뿌듯하다. 깃짱은 스프링을 처음 해봤다고 했는데 이번 미션동안 잘 이해한 것 같아서 대단하다.\n- 컨디션이 안 좋았다. 아침에 일어날 때부터 목감기 걸린 것처럼 목이 아팠는데 낮에는 열이 났다. 주노가 타이레놀 주니까 좀 나았다. ***THANK YOU, JUNO***... 그렇게 여기 있을 때까지는 좀 나았는데 집에 가니까 귀신같이 다시 열이 나서 약을 먹고 잤다. 열은 떨어진 것 같아 다행이다. 어제보다는 몸 상태가 나아졌다.\n\n## 배운 것\n- `JdbcTemplate` 의 `batchupdate`\n\n```java\npublic void insertPlayer(List<RacingCarStatusResponse> responses) {\n    List<Object[]> players = responses.stream()  \n            .map(response -> new Object[]{  \n                    response.getName(), response.getPosition()  \n            }).collect(Collectors.toList());  \n    String sql = \"INSERT INTO player (name, position) VALUES (?, ?)\";  \n    jdbcTemplate.batchUpdate(sql, players);  \n}\n```\n\n`List<Object[]>` 로 객체 리스트를 만든 후, `batchUpdate` 를 실행하면 된다.\n\n- `GeneratedKeyHolder`\n\n```java\n    KeyHolder generatedKeyHolder = new GeneratedKeyHolder();  \n    String sql = \"INSERT INTO player(name, position) VALUES(:name, :position)\";  \n  \n    for (RacingCarStatusResponse response : responses) {  \n        SqlParameterSource parameterSource = new BeanPropertySqlParameterSource(response);\n        jdbcTemplate.update(sql, parameterSource, generatedKeyHolder);  \n  \n        if (winnerNames.contains(response.getName())) {  \n            int playerId = generatedKeyHolder.getKey().intValue();  \n            winnerInsertDao.insertWinner(gameId, playerId);  \n        }  \n    }\n```\n\nupdate할 때 `GeneratedKeyHolder` 를 같이 넣으면 auto-increment 된 id를 가져올 수 있다.\n\n## 궁금한 것\n- 현업에서는 GET을 거의 쓰지 않고 POST만 쓰는 경우가 많다고 하는데(by 포이) 왜일까? GET의 장점은 없을까?\n\t- GET이 되면 정보가 다 노출이 되니까 POST는 정보가 노출되지 않으니까 그런 거 아닐까 by 우가\n\t- 근데 body 암호화 하지 않으면 GET이랑 큰 차이 없다. URL에 노출되지 않을 뿐. 암호화해서 보내는 것이 좋다.\n\n## 어려웠던 것\n- 컨디션 관리해야겠다.\n\n## 느낀 것\n- 목소리를 작게 하자...ㅋㅋㅋㅋ 목소리 작게... 어제 오늘 계속 혼나니까 앞으로는 좀 더 조용한 사람으로 살아봐야겠다...\n- 집에 가면 역시나 공부를 안 한다. 그냥 잠실에 오래 남아있는 걸 목표로 해야겠다. 어제 날이 너무 춥고 컨디션도 안 좋아서 빨리 갔는데 집에서 아무것도 안 했다."},{"excerpt":"내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요! 👍 JDBCTemplate Querying Dao 하나의 객체를 query할 때 사용한다. 첫 번째 인자: sql, 두 번째 인자: 리턴 타입 하나의 객체를 query할 때 with placeholder (가 placeholder임) 첫 번째 인자: sql, 두 번째 인자: 리턴 타…","fields":{"slug":"/spring-jdbc/"},"frontmatter":{"date":"2023년 04월 11일 10:04","title":"Spring JDBC","tags":["레벨2","우테코","개발","spring"]},"rawMarkdownBody":"\n**내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요!** 👍\n\n## JDBCTemplate\n\n### Querying Dao\n\n- 하나의 객체를 query할 때 사용한다.\n\t- 첫 번째 인자: sql, 두 번째 인자: 리턴 타입\n\n```java\nint rowCount = this.jdbcTemplate.queryForObject(\"select count(*) from t_actor\", Integer.class);\n```\n\n- 하나의 객체를 query할 때 with placeholder (`?`가 placeholder임)\n\t- 첫 번째 인자: sql, 두 번째 인자: 리턴 타입, 세 번째 인자: ?에 들어갈 값\n\n```java\nint countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(\n        \"select count(*) from t_actor where first_name = ?\", Integer.class, \"Joe\");\n```\n\n- query 결과가 필드 여러 개일 때\n\t- sql, mapper, ?에 들어갈 값\n\n```java\nActor actor = jdbcTemplate.queryForObject(\n        \"select first_name, last_name from t_actor where id = ?\",\n        (resultSet, rowNum) -> {\n            Actor newActor = new Actor();\n            newActor.setFirstName(resultSet.getString(\"first_name\"));\n            newActor.setLastName(resultSet.getString(\"last_name\"));\n            return newActor;\n        },\n        1212L);\n```\n\n- query 결과 행이 여러 개일 때\n\t- sql, mapper, (?에 들어갈 값)\n\n```java\nList<Actor> actors = this.jdbcTemplate.query(\n        \"select first_name, last_name from t_actor\",\n        (resultSet, rowNum) -> {\n            Actor actor = new Actor();\n            actor.setFirstName(resultSet.getString(\"first_name\"));\n            actor.setLastName(resultSet.getString(\"last_name\"));\n            return actor;\n        });\n```\n\n- RowMapper를 분리해서 사용할 때\n\t- sql, mapper, (?에 들어갈 값)\n\n```java\nprivate final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {\n    Actor actor = new Actor();\n    actor.setFirstName(resultSet.getString(\"first_name\"));\n    actor.setLastName(resultSet.getString(\"last_name\"));\n    return actor;\n};\n\npublic List<Actor> findAllActors() {\n    return this.jdbcTemplate.query(\"select first_name, last_name from t_actor\", actorRowMapper);\n}\n```\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate-examples-query)\n\n### Updating Dao\n\n- insert, update, delete query를 하나의 메서드로 사용 가능\n\t- sql, ? 값 가변인자\n\n```java\nthis.jdbcTemplate.update(\n        \"insert into t_actor (first_name, last_name) values (?, ?)\",\n        \"Leonor\", \"Watling\");\n```\n\n```java\nthis.jdbcTemplate.update(\n        \"update t_actor set last_name = ? where id = ?\",\n        \"Banjo\", 5276L);\n```\n\n```java\nthis.jdbcTemplate.update(\n        \"delete from t_actor where id = ?\",\n        Long.valueOf(actorId));\n```\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate-examples-update)\n\n### Named Parameter\n\nNamedParameterJdbcTemplate 클래스는 `?` 인수만 사용하여 JDBC 문을 프로그래밍하는 것과 달리 이름이 있는 매개변수를 사용하여 JDBC 문을 프로그래밍할 수 있게 한다.\n\n`MapSqlParameterSource` 를 사용하면 다음과 같이 쓸 수 있다.\n\n```java\n// some JDBC-backed DAO class...\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\n    String sql = \"select count(*) from T_ACTOR where first_name = :first_name\";\n\n    SqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);\n\n    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n만약 SQL에 값을 여러 개 넣어야 하는 경우는 `addValue()` 로 값을 추가해줄 수 있다.\n\n```java\nString sql = \"SELECT :a + :b\";\n\nSqlParameterSource param = new MapSqlParameterSource()\n\t\t\t\t\t\t\t\t.addValue(\"a\", 100)\n\t\t\t\t\t\t\t\t.addValue(\"b\", 200);\n```\n\nMap을 사용하여 `String` 형의 매개변수 이름과 값을 `NamedParameterJdbcTemplate` 에 전달할 수 있다.\n\nMap을 사용하는 방법의 예제이다.\n\n```java\n// some JDBC-backed DAO class...\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\n    String sql = \"select count(*) from T_ACTOR where first_name = :first_name\";\n\n    Map<String, String> namedParameters = Collections.singletonMap(\"first_name\", firstName);\n\n    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);\n}\n```\n\n** `Collections.singletonMap` 은 단 하나의 키를 갖는 맵을 나타낼 때 사용한다.\n\n### `BeanPropertySqlParameterSource` 클래스\n\n아래와 같은 Actor 클래스가 있다고 가정하자.\ngetter는 필수적으로 필요하고, Actor의 필드 이름들은 자동으로 카멜 케이스에서 스네이크 케이스로 변환된다.\n\n```java\npublic class Actor {\n\n    private Long id;\n    private String firstName;\n    private String lastName;\n\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    public Long getId() {\n        return this.id;\n    }\n\n    // setters omitted...\n\n}\n```\n\n`:` 의 뒤에는 Actor 클래스의 필드 이름을 넣는다. (카멜 케이스 그대로)\n`BeanPropertySqlParameterSource` 의 인자로 필드 이름과 같은 값을 갖는 객체를 넣어주면 자동으로 JdbcTemplate이 인식하여 쿼리가 수행된다.\n\n```java\n// some JDBC-backed DAO class...\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActors(Actor exampleActor) {\n\n    // notice how the named parameters match the properties of the above 'Actor' class\n    String sql = \"select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName\";\n\n    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);\n\n    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n`NamedParameterJdbcTemplate` 은 JdbcTemplate을 래핑한 클래스이다.\n래핑된 JdbcTemplate 에 접근하기 위해서는 `getJdbcOperations()` 를 사용하여 JdbcTemplate 에 접근할 수 있다.\n\n-  참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-NamedParameterJdbcTemplate)\n\n## SimpleJdbcInsert\n\nData access layer의 초기화 메서드에서 `SimpleJdbcInsert` 클래스를 인스턴스화 해야 한다.\n`setDataSource()` 메서드에서 dataSource를 초기화하고, 테이블 이름을 설정할 수 있다.\n\n`SimpleJdbcInsert` 의 `execute()` 를 실행하기 위해서는 Map 객체를 만들어서 인자로 넘겨준다.\nMap의 key는 테이블의 column 이름과 정확하게 일치해야 한다.\n\n```java\npublic class JdbcActorDao implements ActorDao {\n\n    private SimpleJdbcInsert insertActor;\n\n    public void setDataSource(DataSource dataSource) {\n        this.insertActor = new SimpleJdbcInsert(dataSource).withTableName(\"t_actor\");\n    }\n\n    public void add(Actor actor) {\n        Map<String, Object> parameters = new HashMap<>(3);\n        parameters.put(\"id\", actor.getId());\n        parameters.put(\"first_name\", actor.getFirstName());\n        parameters.put(\"last_name\", actor.getLastName());\n        insertActor.execute(parameters);\n    }\n\n    // ... additional methods\n}\n```\n\n### Auto-generated key 를 얻는 방법\n\nauto-increment 되는 id가 있는 경우, 다음과 같은 방법을 사용해야 한다.\n\n`SimpleJdbcInsert` 선언 시 `usingGeneratedKeyColumns(\"auto-increment 되는 컬럼 이름\")` 을 설정해준다.\n\n```java\npublic class JdbcActorDao implements ActorDao {\n\n    private SimpleJdbcInsert insertActor;\n\n    public void setDataSource(DataSource dataSource) {\n        this.insertActor = new SimpleJdbcInsert(dataSource)\n                .withTableName(\"t_actor\")\n                .usingGeneratedKeyColumns(\"id\");\n    }\n\n    public void add(Actor actor) {\n        Map<String, Object> parameters = new HashMap<>(2);\n        parameters.put(\"first_name\", actor.getFirstName());\n        parameters.put(\"last_name\", actor.getLastName());\n        Number newId = insertActor.executeAndReturnKey(parameters);\n        actor.setId(newId.longValue());\n    }\n\n    // ... additional methods\n}\n```\n\n`executeAndReturnKey` 메서드로 auto-increment 된 ID의 값을 가져올 수 있다.\n\n### insert에 필요한 column 제한하기\n\n`usingColumns` 메서드를 사용하면 column 이름 목록을 지정해서 insert할 column을 제한할 수 있다.\n\n```java\npublic class JdbcActorDao implements ActorDao {\n\n    private SimpleJdbcInsert insertActor;\n\n    public void setDataSource(DataSource dataSource) {\n        this.insertActor = new SimpleJdbcInsert(dataSource)\n                .withTableName(\"t_actor\")\n                .usingColumns(\"first_name\", \"last_name\")\n                .usingGeneratedKeyColumns(\"id\");\n    }\n\n    public void add(Actor actor) {\n        Map<String, Object> parameters = new HashMap<>(2);\n        parameters.put(\"first_name\", actor.getFirstName());\n        parameters.put(\"last_name\", actor.getLastName());\n        Number newId = insertActor.executeAndReturnKey(parameters);\n        actor.setId(newId.longValue());\n    }\n\n    // ... additional methods\n}\n```\n\n실제로 코드에서는 이렇게 사용했다.\n\n```sql\n// 데이터 구조\nCREATE TABLE GAME  \n(  \n    id          BIGINT   NOT NULL AUTO_INCREMENT,  \n    trial_count INT      NOT NULL,  \n    time        DATETIME NOT NULL default current_timestamp,  \n    PRIMARY KEY (id)  \n);  \n  \nCREATE TABLE PLAYER  \n(  \n    id        BIGINT      NOT NULL AUTO_INCREMENT,  \n    game_id   BIGINT      NOT NULL,  \n    name      VARCHAR(10) NOT NULL,  \n    position  INT         NOT NULL,  \n    is_winner BOOL     NOT NULL,  \n    PRIMARY KEY (id),  \n    FOREIGN KEY (game_id) references GAME (id) on update cascade  \n);\n```\n\n내가 웹자동차 미션에서 사용했던 코드는 다음과 같다. \n\n```java\n@Repository  \npublic class GameRepository {  \n  \n    private final SimpleJdbcInsert insertGame;  \n  \n    public GameRepository(final DataSource dataSource) {  \n        this.insertGame = new SimpleJdbcInsert(dataSource)  \n                .withTableName(\"game\")  \n                .usingColumns(\"trial_count\")  \n                .usingGeneratedKeyColumns(\"id\");  \n    }  \n  \n    public long save(final int trialCount) {  \n        HashMap<String, Object> parameters = new HashMap<>();  \n        parameters.put(\"trial_count\", trialCount);  \n        return insertGame.executeAndReturnKey(parameters).longValue();  \n    }  \n}\n```\n\ntime이 default 값을 가지고 있기 때문에 사용하는 column을 넣어주지 않으면 null이 들어가게 된다.\ntime은 not null 이므로, `usingColumns` 를 사용하지 않으면 예외가 발생한다.\ndefault 값을 갖는 column의 경우에는 `usingColumns` 를 사용하면 필요한 column만 지정할 수 있어 좋다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-simple-jdbc-insert-1)"},{"excerpt":"내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요 👍 Mapping Request Mapping Request Mapping은 Controller의 메서드에 Request를 매핑하기 위해 사용한다.\nclass level에서 사용하면 shared mapping을 표현할 수 있다. method level에서 사용하면 특정 endpoint…","fields":{"slug":"/spring-mvc/"},"frontmatter":{"date":"2023년 04월 11일 10:04","title":"Spring MVC","tags":["레벨2","우테코","개발","spring"]},"rawMarkdownBody":"\n**내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요 👍**\n\n## Mapping\n\n### Request Mapping\n\nRequest Mapping은 Controller의 메서드에 Request를 매핑하기 위해 사용한다.\nclass level에서 사용하면 shared mapping을 표현할 수 있다. method level에서 사용하면 특정 endpoint mapping 으로 좁혀서 표현할 수 있다.\n\nHTTP 메서드 별로 `@RequestMapping` 의 변형은 다음과 같다.\n\n-   `@GetMapping`\n-   `@PostMapping`\n-   `@PutMapping`\n-   `@DeleteMapping`\n-   `@PatchMapping`\n\n```java\n@RestController\n@RequestMappping(\"/customers\")\nclass CustomerController {\n\n\t@GetMapping(\"/{id}\")\n\tpublic Customer getCustomer(@PathVariable Long id) {\n\t\t// ...\n\t}\n}\n```\n\n`@RequestMapping` 어노테이션을 Controller 상단에 적어주면, Controller 내부의 모든 메서드가 같은 URL을 공유하게 된다.\n\n`@GetMapping` 같은 specific annotation은 메서드 상단에 적는다. \n해당 메서드가 어떤 URL에서 불려야할 지를 범위를 좁혀 특정지을 수 있다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping)\n\n### URI Patterns\n\n`@RequestMapping` 은 URL 패턴을 이용해서 mapping 될 수 있다.\n\n- `PathPattern` : URL 경로와 매칭되는 사전 구문 분석된 패턴을 `PathContainer` 로 사전 구문 분석한다. \n\t- `AntPathMatcher` 와 달리 `**` 가 패턴 끝에서만 지원된다. `/pages/{**}` 는 가능하지만, `/pages/{**}/details` 는 안 된다.\n\t- 참고: [공식문서](https://docs.spring.io/spring-framework/docs/6.0.7/javadoc-api/org/springframework/web/util/pattern/PathPattern.html)\n- `AntPathMatcher` : 문자열 패턴을 문자열 경로와 일치시킨다. 덜 효율적이고, 문자열 경로 입력은 URL과 관련된 인코딩, 기타 문제를 효과적으로 처리하는데 어려움이 있다.\n\t- 참고: [공식문서](https://docs.spring.io/spring-framework/docs/6.0.7/javadoc-api/org/springframework/util/AntPathMatcher.html)\n\n`PathPattern` 을 사용하는 것을 권장한다.\n\n### Media Types - produces\n\nRequest Header와 Controller Method가 생성하는 콘텐츠 유형 목록을 기반으로 Request Mapping의 범위를 좁힐 수 있다.\n\n```java\n@GetMapping(path = \"/pages/{id}\", produces = \"application/json\")\n```\n\n위 예제에서 `/pages/{id}` 로 들어오는 요청 중 \"application/json\" 속성을 갖는 요청만 해당 메서드로 mapping 된다.\n\n`!text/plain` 같은 부정 표현도 지원된다.\n\nclass level에서 `produces` 을 사용하면 class level에서 `produces` 가 공유된다.\n그러나 method level에서 `produces` 를 사용하면 class level에서 설정이 확장되는 것이 아니라 method level의 `produces` 로 설정이 덮어 씌워진다.\n\n> `MediaType` 중에 빈번하게 사용되는 media type을 상수로 제공한다.\n> Ex. `APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE` \n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-produces)\n\n### Media Types - consumes\n\nRequest Header와 Controller Method가 생성하는 콘텐츠 유형 목록을 기반으로 Request Mapping의 범위를 좁힐 수 있다.\n\n```java\n@PostMapping(path = \"/page\", consumes = \"application/json\")\n```\n\n위 예제에서 `/pages/{id}` 로 들어오는 요청 중 \"application/json\" 속성을 갖는 요청만 해당 메서드로 mapping 된다.\n\n`!text/plain` 같은 부정 표현도 지원된다.\n\nclass level에서 `consumes` 을 사용하면 class level에서 `consumes` 가 공유된다.\n그러나 method level에서 `consumes` 를 사용하면 class level에서 설정이 확장되는 것이 아니라 method level의 `consumes` 로 설정이 덮어 씌워진다.\n\n> `MediaType` 중에 빈번하게 사용되는 media type을 상수로 제공한다.\n> Ex. `APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE` \n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-consumes)\n\n### Parameters, headers\n\nRequest Parameter 조건에 따라 Request Mapping의 범위를 좁힐 수 있다.\nRequest Parameter가 존재하는지, 아닌지, 특정 값을 갖는지 테스트할 수 있다.\n\n```java\n@GetMapping(path = \"/pages/{pageId}\", params = \"myParam=myValue\")\n```\n\n`myValue` 값을 갖는 `myParam` 인 경우에만 해당 메서드가 실행된다.\n\nContent-Type, Accept를 체크할 수도 있지만, consumes나 produces를 사용하는 것이 더 낫다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-params-and-headers)\n\n## Handler\n\n### Method Arguments\n\n종류가 너무 많으므로, 학습 테스트에서 다룬 `@RequestBody` , `@RequestParam` 만 살펴보겠다.\n\n#### `@RequestParam`\n`@RequestParam` 은 Multipart file을 포함해서 Request Parameter에 접근할 수 있게 한다. Parameter 값은 선언된 메서드 매개변수로 바인딩 된다.\n\n기본적으로는 `@RequestParam` 을 사용하는 메서드의 매개변수가 필수이지만, `required` 를 `false` 로 선언하면 메서드 매개변수가 선택 사항이라는 것을 지정할 수 있다.\n\n```java\n@GetMapping\npublic String setupForm(@RequestParam(\"petId\") int petId, Model model) {\n\t// ...\n}\n```\n\nParameter 타입이 String이 아닌 경우에는 타입 변환이 자동으로 일어난다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestparam)\n\n#### `@RequestBody` \n\n```java\n@PostMapping(\"/accounts\") \npublic void handle(@RequestBody Account account) { // ... }\n```\n\n`@Valid` annotation과 같이 조합되어 사용될 수 있다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestbody)\n\n### Return Values\n\n### `@ResponseBody`\n\n자바 객체를 HTTP Request body로 전송할 수 있다.\nclass level을 지원한다. class level에서 사용하면 모든 controller method에서 사용할 수 있다.\n\n```java\n@GetMapping(\"/account/{id}\")\n@ResponseBody\npublic Actor handle() {\n\t// ...\n}\n```\n\n`@ResponseBody` 어노테이션이 적용된 메서드는 `HttpMessageConverter` 를 사용해서 변환을 처리한다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types)\n\n### `ResponseEntity<B>`\n\n`@ResponseBody` 와 비슷하지만 HttpStatus와 HttpHeaders, HttpBody가 있다.\n\n```java\n@GetMapping(\"/something\")\npublic ResponseEntity<String> handle() {\n\tString body = ... ;\n\tString etag = ... ;\n\treturn ResponseEntity.ok().eTag(etag).body(body);\n}\n```\n\n`ResponseEntity` 가 제네릭 타입\n\n## Exception\n\n`@ExceptionHandler` 로 Controller 메서드의 예외를 처리하는 메서드를 가질 수 있다.\n\n```java\n@ExceptionHandler \npublic ResponseEntity<String> handle(IOException ex) { // ... }\n```\n\n일치시킬 예외 유형을 좁힐 수도 있다.\n\n```java\n@ExceptionHandler({FileSystemException.class, RemoteException.class}) public ResponseEntity<String> handle(IOException ex) { \n\t// ...\n}\n```\n\n`IOException` 중에 `FileSystemException`, `RemoteExceptoin` 을 처리한다.\n\n주어진 예외 인스턴스를 원래 형식으로 다시 throw 하여 처리하지 않도록 선택할 수도 있다. 특정 context의 일치에만 관심있는 때에 유용하다. \n\n`@ExceptionHandler`는 `@Controller` 클래스에서만 적용된다. \n\n그러나 `@ControllerAdvice`가 적용되면 `@ControllerAdvice` 내부에 있는 모든 ExceptionHandler는 모든 컨트롤러에 적용될 수 있다."},{"excerpt":"LOG 깃짱이랑 페어가 됐다 😎 오늘은 이번 Spring 미션 하기 전에 학습 테스트 두 개를 했다. 내가 느끼기에는 꽤 어려운 내용이었는데, 솔라가 공식문서 보면서 하는 게 좋다고 해서 오늘 내내 열심히 공부했다. 공식문서가 영어로 되어 있기는 했지만 깃짱이랑 같이 보면서 하니까 금방 끝낼 수 있었다. 많이 배운 것 같아서 뿌듯했다. 레벨2 데일리 조는…","fields":{"slug":"/2023-04-11/"},"frontmatter":{"date":"2023년 04월 11일 10:04","title":"2023년 04월 11일","tags":null},"rawMarkdownBody":"## LOG\n- 깃짱이랑 페어가 됐다 😎 오늘은 이번 Spring 미션 하기 전에 학습 테스트 두 개를 했다. 내가 느끼기에는 꽤 어려운 내용이었는데, 솔라가 공식문서 보면서 하는 게 좋다고 해서 오늘 내내 열심히 공부했다. 공식문서가 영어로 되어 있기는 했지만 깃짱이랑 같이 보면서 하니까 금방 끝낼 수 있었다. 많이 배운 것 같아서 뿌듯했다.\n- 레벨2 데일리 조는 네오조였다. 하마드, 채채, 우르, 오잉, 홍실과 같이 점심을 먹었다. 먹다보니까 너무 호칭이 정리가 안 돼서 그냥 다 말을 놔버렸다~ 생각해보니 깃짱, 허브와도 말을 놓게 되었는데 오늘은 말 놓는 날인가 싶다 ㅋㅋㅋ\n- 모던 자바 인 액션 람다 부분을 읽고 있다. 아직 덜 읽었지만(ㅋㅋ), 확실히 람다를 사용해보고 이론을 공부하니 더 이해가 잘 됐다. 일단 써보고 공부하는 방법이 틀리지 않았다는 생각을 했다.\n\n## 배운 것\n- [[spring-mvc]]\n- [[spring-jdbc]] : 시간이 없어서 못 썼다... 😭 내일은 완성해보자.\n\n## 궁금한 것\n- POST는 항상 Consumes을 사용하고, GET이 항상 Produces를 사용할까?\n- header를 읽는 순서가 궁금해졌다. URL을 먼저 확인하고, 그 다음에 조건을 확인하는 건지..?\n\n## 어려웠던 것\n- 나도 공식문서를 찾아보는 게 가장 질 좋은 정보라고 생각하지만 역시 언어의 장벽.. 쉽지 않다. 영어 공부를 해야겠다고 느꼈다.\n\n## 느낀 것\n- 오랜만에 잠실에 가서 그런가 굉장히 기분이 좋은 날이었다. 보고 싶었던 사람들도 보고, 같이 공부도 해서 하루 종일 업된 상태였다. 기분이 좋은 건 좋은 거니까 좋다~\n- 집에 돌아오니 역시 아무것도 하기 싫은 거 같다. 최대한 잠실에 있는 시간을 늘리려고 한다. 그렇지만 아무리 늦어도 9시... 가 최대다. 오늘 아침은 잠도 그렇게 적게 자지는 않았는데 졸려서 중간에 트랙룸에서 자버렸다 ㅋㅋ.. 컨디션 관리를 제대로 해야겠다.\n- 다들 미션이 쉽다고 했다. 스프링을 한 사람들이 많아서 그런지 빨리 끝난 조가 많았다. 내일은 열심히 해서 미션을 끝내고 집에 가고 싶다.\n"},{"excerpt":"4/11 레벨2를 슬기롭게 소화하기 학습해야하는 내용의 범위가 넓으니, 깊이를 제한한다. 얼마까지 해야 할까? -> 프롤로그 참고하기 다른 웹 서비스를 유심히 살펴보자. 평소 자주 사용하거나 내가 만드는 것과 비슷한 서비스를 뜯어본다. 현재 상태에 따라서 목표를 설정하자. 나는 스프링을 접해본 적이 있지만 얕은 지식을 가지고 있다. 내가 쓰고 있는 기술들…","fields":{"slug":"/level2-week1/"},"frontmatter":{"date":"2023년 04월 11일 01:04","title":"레벨2 1주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 4/11\n\n## 레벨2를 슬기롭게 소화하기\n\n- 학습해야하는 내용의 범위가 넓으니, 깊이를 제한한다.\n- 얼마까지 해야 할까? -> 프롤로그 참고하기\n- 다른 웹 서비스를 유심히 살펴보자. 평소 자주 사용하거나 내가 만드는 것과 비슷한 서비스를 뜯어본다.\n- 현재 상태에 따라서 목표를 설정하자. 나는 스프링을 접해본 적이 있지만 얕은 지식을 가지고 있다. 내가 쓰고 있는 기술들을 알고 쓰고 싶다!\n- 꾸준함을 잃지 말자.\n- 레벨2의 나의 목표는 무엇인가? 내가 쓰는 기술들이 무엇인지, 왜 좋은지, 어떤 점에서는 안 좋을 수 있는지 알고 사용하고 싶다. '알고 쓰자!'가 이번 레벨2의 목표다.\n- 왜 스프링을 학습해야할까? 그건 아직 모르겠다... 그냥 자바로 웹 애플리케이션을 만들어보고 싶어서?\n- 처음 하는 사람보다는 이미 알고 있는 사람이 동작 원리에 대해서 학습했으면 좋겠다.\n\n# 4/14\n\n## Spring MVC\n\n### `@RestController` vs `@Controller`\n\n- `@RestController` 는 `@ResponseBody`를 포함하는 것으로, 그냥 객체를 리턴해도 `@ResponseBody` 를 한 것과 동일하다.\n- `@Controller` 에서 String을 리턴하면 view 파일을 찾는다. `@RestController` 는 String을 리턴하면 `@ResponseBody` 로 감싸진 String 이 리턴된다.\n\n### `@ResponseEntity`\n\nstatus와 header를 포함한다. status를 설정해줄 수 있다.\n컨벤션을 통일하는 것이 좋다.\n내 생각: 차라리 모든 응답에 `ResponseEntity`로 감싸는 게 나을 것 같다. (status 설정하고 쓰는 것)\n\n`ResponseEntity` raw type으로 사용하지 말자.\n\n## Spring JDBC\n\nconnection을 열고 닫는 과정이 필요 없다.\n나는 간단하게 쿼리만 작성하면 되어서, 도메인 로직에만 집중할 수 있다.\n\n`JdbcTemplate`, `NamedParameterJdbcTemplate`, `SimpleJdbcInsert` 를 사용하는 기준을 잡으면 좋겠다. DB에 조회에 그치지 말고, 해당 template 들의 차이점을 알고 썼으면 좋겠다.\n\n# 4/18\n\n## 의존성\n\n```mermaid\nflowchart LR\n\tclass1 -- 사용 생성 호출 --> class2\n```\n\n### 객체 내부에서 객체를 생성하고, 사용한다면\n\n협력의 문맥이 고정된다.\n사용하는 객체가 변경되었을 때 변경이 필요하게 된다. \n\n```mermaid\nflowchart LR\n\t클래스 -- 사용 --> 인터페이스\n\t클래스 -- 호출 --> 팩토리\n\t팩토리 -- 생성 --> 구현클래스\n\t인터페이스 -- 구현 --> 구현클래스\n```\n\n```mermaid\nflowchart LR\n\t조립기 -- 생성 --> 구현클래스\n\t조립기 -- 의존성 삽입 --> 클래스\n\t클래스 -- 사용 --> 인터페이스\n\t구현클래스 -- 구현 --> 인터페이스\n```\n다음과 같은 코드가 된다.\n\n```java\npublic RacingCarService(PlayerResultDao playerResultDao) {\n\tthis.playResultDao = playerResultDao;\n}\n```\n\n이런 역할을 Spring이 해준다.\n\nSpring IoC Container는 의존성을 주입하는 방식으로 객체를 생성, 관리한다. 객체 간의 연결 관계, 의존성을 관리해준다.\n\nSpring이 모든 객체를 관리하는 것은 아니다. 개발자가 설정한 특정 객체들만 관리한다.\n\n## 설정의 방식\n\n1. XML\n2. Annotation-based configuration\n3. Java-based configuration\n\n`@Service`, `@Component`, `@Repository` ... 등등\nService, Repository가 아니지만 Bean으로 설정하기 위해 `@Component` 를 사용할 수 있다.\n\n`@Service`, `@Controller`, `@Repository` 는 모두 `@Component` 를 포함한다. \n위의 어노테이션은 해당 클래스를 Spring bean으로 만들라는 뜻이다.\n\n`@ComponentScan` 어노테이션을 통해 등록할 빈을 스캔할 classpath를 지정한다.\n`@SpringBootApplication` 의 내부에 `@ComponentScan` 이라는 어노테이션이 존재해서, 자동으로 bean을 생성할 수 있다.\n\n# 4/21\n\n## 계층화\n\n이번 미션 때 Console 기반의 애플리케이션을 Web에서도 제공하는 프로그램을 작성했다.\nConsole과 Web의 비즈니스 로직과 데이터 로직은 어느정도 중복되는 부분이 있다. \n중복 로직을 `Service` 라는 것으로 분리하게 되면, `RacingCarDao` 가 추상화된다.\n-> 자연스럽게 계층이 나눠지게 된다. 이전부터 사용한 보편적인 구조이다.\n\n```mermaid\nflowchart TD\n\tPresentation --> Domain\n\tDomain --> Data\n```\n\n관심사를 분리(단일 책임 원칙)해서 계층이 나눠지게 된다. 변경이 잘 되지 않는 도메인 로직을 보호하기 위해 계층화를 사용하게 된다. 변경으로부터 보호하기 위해 단방향으로 진행한다. \n\n## Validation\n\n검증해야 할 입력 값이 존재한다. 그렇다면 입력 값의 검증은 어떤 계층에서 확인해야할까?\n사람마다 규칙은 다를 수 있다.\n\n## 스프링을 사용하지 않는 환경을 고려해야 할까?\n\n브리: 프레임워크의 큰 변동이 있는 경우에는 보통 다시 만든다. 그래서 그 부분은 큰 문제가 되지 않는다고 생각한다.\n\n솔라: 현업에서는 같은 기능을 하는데 아예 새로운 프로그래밍 언어로 하도록 변경하거나, 아예 새로운 웹 프레임워크를 쓸 정도의 작업은 ‘리팩토링’ 보다는 ’porting’ 에 해당하는 작업으로 정의합니다. 보통 포팅에서는 기존 코드를 최대한 재활용하는 이점보다 새로운 언어나, 프레임워크를 선택하는 이점이 더 크다고 판단해 선택하는 경우가 많아서, 기존코드의 언어적, 프레임워크적 특징이 담긴 코드를 못 가져가는 것은 당연히 감수해야하는 것으로 생각하긴 했습니다.\n\n=> 나의 결론: 스프링 프레임워크 열심히 활용하자!"},{"excerpt":"LOG 박스터, 여우, 주노와 함께 한강 코딩하러 갔다. 사실 나는 거기 가서 딱히 할 게 없었기 때문에... 얼마 안 남아 있던 class 3 에센셜 문제를 풀었다. 오랜만에 문제 푸는 거라 기분이 희한했다. 배운 것 궁금한 것 어려웠던 것 느낀 것 마음이 싱숭생숭하다. 일단 내일 잠실을 간다는 게 믿기지 않는다. 나는 방학이 끝나기를 기다려온 사람이라…","fields":{"slug":"/2023-04-10/"},"frontmatter":{"date":"2023년 04월 10일 13:04","title":"2023년 04월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 박스터, 여우, 주노와 함께 한강 코딩하러 갔다. 사실 나는 거기 가서 딱히 할 게 없었기 때문에... 얼마 안 남아 있던 class 3 에센셜 문제를 풀었다. 오랜만에 문제 푸는 거라 기분이 희한했다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 마음이 싱숭생숭하다. 일단 내일 잠실을 간다는 게 믿기지 않는다. 나는 방학이 끝나기를 기다려온 사람이라 당연히 가는 건 좋다. 예전에는 내일 새로운 사람들을 만나게 되어서 좋았는데, 지금은 또 그 정도는 아니다. 그냥 내 마음이 이상하다~\n"},{"excerpt":"LOG 미루던 빨래를 했다. 팔에 근육이 생긴 거 같다...ㅋㅋㅋ 집안일은 미루면 계속 늘어난다. 방학 끝나면  또 집안일 하기 싫을 거니까 미리 좀 해두려고 하는 중이다. 배운 것 궁금한 것 어려웠던 것 느낀 것 벌써 방학이 끝나고 화요일에는 다시 잠실에 간다. 진짜 방학 너무 길었다.. 방학 때에 뭐라도 하고 싶은 날이 계속됐는데 같이 할 사람이 없으…","fields":{"slug":"/2023-04-08/"},"frontmatter":{"date":"2023년 04월 08일 10:04","title":"2023년 04월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 미루던 빨래를 했다. 팔에 근육이 생긴 거 같다...ㅋㅋㅋ 집안일은 미루면 계속 늘어난다. 방학 끝나면  또 집안일 하기 싫을 거니까 미리 좀 해두려고 하는 중이다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 벌써 방학이 끝나고 화요일에는 다시 잠실에 간다. 진짜 방학 너무 길었다.. 방학 때에 뭐라도 하고 싶은 날이 계속됐는데 같이 할 사람이 없으니 더 많이 못했다. 좀 아쉽긴 하지만 오히려 그냥 푹 쉬었다고 생각하자~\n"},{"excerpt":"LOG 드디어 RSS를 등록할 수 있게 되었다! graphql query가 문제여서 데이터가 안 가져와졌다는 걸 오늘에서야 깨달았다. 역시 개츠비든 graphql이든 잘 모르니 간단한 블로그 커스텀도 어렵다... RSS 등록하고 싶으신 분들은 (https://cyma-s.github.io/rss.xml) 등록해주시면 됩니다~ 스터디 면접 하는 날인줄 알았…","fields":{"slug":"/2023-04-07/"},"frontmatter":{"date":"2023년 04월 07일 02:04","title":"2023년 04월 07일","tags":null},"rawMarkdownBody":"## LOG\n- 드디어 RSS를 등록할 수 있게 되었다! graphql query가 문제여서 데이터가 안 가져와졌다는 걸 오늘에서야 깨달았다. 역시 개츠비든 graphql이든 잘 모르니 간단한 블로그 커스텀도 어렵다... RSS 등록하고 싶으신 분들은 (https://cyma-s.github.io/rss.xml) 등록해주시면 됩니다~\n- 스터디 면접 하는 날인줄 알았는데 아니었다... 서로의 소통 미스 ㅋㅋㅋ 슬랙을 미리미리 확인하자\n- 포이랑 종각에서 만났다. 중간에 나갈 시간을 생각하면서 놀았어야 했는데 그냥 놀다 보니 결국 집에 못 들어갔다.. 😂 앞으로는 시간 보면서 집에 좀 들어가자 🥺 나중 가서는 너무 졸려서 헛소리했다.\n\n## 배운 것\n- [[stack-unwinding|스택 풀기]]\n- [[simultaneously-throw-exception|예외가 여러 개 발생한다면?]]\n\n## 궁금한 것\n\n## 어려웠던 것\n- 새로운 루틴에 적응하기. 내가 세웠던 계획 지키기\n- 요즘 잠을 많이 못 자는데, 잠을 더 잘 수가 없다는 게 문제다. 한 3주째인 거 같은데 아침마다 심장이 두근거린다. 기분 나쁜 두근거림이라 몸이 긴장 상태가 된다. 근데 술 마시고 일어나니 안 그런다. 뭐가 문제지?\n\n## 느낀 것\n- 앞으로 공부를 열심히 해야겠다. 우테코 끝나고 멋진 사람이 되는 게 목표가 됐다. 궁금한 것은 끝까지 찾아보고 끈질기게 배우자!\n- 내 주위에는 생각보다 상냥한 사람들이 많은 것 같다. 주변에 좋은 사람들이 많아서 좋다.\n"},{"excerpt":"문에서  와 가 동시에 예외를 던지는 경우를 조사하다 stack unwinding을 알게 되었다. 스택 풀기, 스택 되감기 등 여러 가지 이름을 사용한다. Stack Unwinding란? 예외가 발생한 함수에서 예외 처리가 되지 않았을 때 함수 호출 스택을 풀면서 함수가 호출되었던 부분으로 돌아가 예외 처리를 시도하는 것 예외를 catch하지 않은 메서드…","fields":{"slug":"/stack-unwinding/"},"frontmatter":{"date":"2023년 04월 07일 01:04","title":"스택 풀기 (Stack Unwinding)","tags":["Java","개발"]},"rawMarkdownBody":"\n`try-catch` 문에서 `finally` 와 `catch`가 동시에 예외를 던지는 경우를 조사하다 stack unwinding을 알게 되었다.   \n\n스택 풀기, 스택 되감기 등 여러 가지 이름을 사용한다.\n\n## Stack Unwinding란?\n\n- 예외가 발생한 함수에서 예외 처리가 되지 않았을 때 함수 호출 스택을 풀면서 함수가 호출되었던 부분으로 돌아가 예외 처리를 시도하는 것\n- 예외를 catch하지 않은 메서드가 종료되고, 해당 메서드의 모든 로컬 변수들이 scope를 벗어나 원래 해당 메서드를 호출한 문으로 제어가 반환되는 것을 의미한다.\n- 호출한 곳에서 `try` 블록이 해당 statement를 감싸고 있다면, 예외를 `catch` 하는 것을 시도한다.\n- `try` 블록이 해당 statement를 감싸고 있지 않은 경우, stack unwinding이 다시 일어난다.\n- 해당 예외를 처리하는 `catch` 블록이 없고, 예외가 `checked exception` 인 경우, 프로그램 컴파일이 에러를 일으킨다.\n\n## 예제\n\n```java\npublic class Main {  \n    public static void main(String[] args) {  \n        function1();  \n    }  \n  \n    private static void function1() {  \n        function2();  \n    }  \n  \n    private static void function2() {  \n        function3();  \n    }  \n  \n    private static void function3() {  \n        throw new IllegalArgumentException(\"Unchecked exception 발생\");  \n    }  \n}\n```\n\n프로그램을 실행하면 다음과 같은 메시지가 뜬다.\n\n```\nException in thread \"main\" java.lang.IllegalArgumentException: Unchecked exception 발생\n\tat Main.function3(Main.java:15)\n\tat Main.function2(Main.java:11)\n\tat Main.function1(Main.java:7)\n\tat Main.main(Main.java:3)\n```\n\n예외 메시지 출력 아래에 어떤 함수에서 불렸는지 trace가 함께 출력된다.\n\n## 참고 자료\n\n- [참고자료](https://luckygg.tistory.com/372)\n- [참고자료2](http://underpop.online.fr/j/java/help/stack-unwinding-exception-handling.html.gz)"},{"excerpt":"예외가 동시에 발생하는 경우 새로운 예외가 ,  블록에서 발생하는 경우, 현재 예외가 이전 예외를 무시하고 외부로 전파된다. (메서드는 단 하나의 예외만 던질 수 있으므로) 새로운 예외는 다른 예외와 동일하게 스택을 풀기 시작한다. (stack unwinding)  블록에서 새 예외가 발생하는 경우, 해당 예외는 의  블록의 영향을 받는다. 즉  에  가…","fields":{"slug":"/simultaneously-throw-exception/"},"frontmatter":{"date":"2023년 04월 07일 00:04","title":"try, finally에 모두 예외가 발생하는 경우에는 어떻게 될까?","tags":["Java","개발"]},"rawMarkdownBody":"\n## 예외가 동시에 발생하는 경우\n\n- 새로운 예외가 `catch`, `finally` 블록에서 발생하는 경우, 현재 예외가 이전 예외를 무시하고 외부로 전파된다. (메서드는 단 하나의 예외만 던질 수 있으므로)\n- 새로운 예외는 다른 예외와 동일하게 스택을 풀기 시작한다. (stack unwinding)\n- `catch` 블록에서 새 예외가 발생하는 경우, 해당 예외는 `catch`의 `finally` 블록의 영향을 받는다.\n- 즉 `try/catch` 에 `finally` 가 존재하는 경우, `finally` 는 예외를 catch한 후에 실행된다. 그러나  예외를 던지기 전에 `finally` 까지 실행한 후에 가장 마지막 예외가 던져진다. \n- [[stack-unwinding|스택 풀기]]\n\n## 참고 자료\n- [stack-overflow-참고자료](https://stackoverflow.com/questions/3779285/exception-thrown-in-catch-and-finally-clause)\n"},{"excerpt":"LOG 유정, 정민과 롯데월드에 갔다. 나이가 드니 놀이기구가 별로 재미없었다. 그냥 롯데월드 놀이기구가 재미없었을지도? ㅋㅋㅋ 그래도 오랜만에 만나서 논 거는 재밌었다~ 유정, 정민한테 LCK 결승전 티켓팅 같이 해달라고 했는데 S석 잡았다... 🥹 작년 스프링도 갔는데 이번 스프링도 가게 되어서 너무 기쁘다. 작년에도 이겼으니까 올해도 이기자~ 배운 …","fields":{"slug":"/2023-04-06/"},"frontmatter":{"date":"2023년 04월 07일 00:04","title":"2023년 04월 06일","tags":null},"rawMarkdownBody":"## LOG\n- 유정, 정민과 롯데월드에 갔다. 나이가 드니 놀이기구가 별로 재미없었다. 그냥 롯데월드 놀이기구가 재미없었을지도? ㅋㅋㅋ 그래도 오랜만에 만나서 논 거는 재밌었다~\n- 유정, 정민한테 LCK 결승전 티켓팅 같이 해달라고 했는데 S석 잡았다... 🥹 작년 스프링도 갔는데 이번 스프링도 가게 되어서 너무 기쁘다. 작년에도 이겼으니까 올해도 이기자~\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 너무 놀았더니 이제 공부가 하고 싶다. 모던 자바 인 액션을 읽을 생각이다. 저번에 레벨 인터뷰 때 제이슨이 Java 8 람다와 stream 관련해서 질문했었는데 진짜 처음 듣는 내용이었다. 앞으로 Java를 깊게 팔 일이 없을 것 같아서, 방학 때라도 (얼마 안 남았지만..) 모던 자바 인 액션을 읽어보자. 이제 레벨2 때 아침에 오면 독서를 할 생각이다.\n- 근데 왜 RSS 달았는데 작동을 안 할까. 개인 슬랙에 연동해봤는데 알림 1도 안 와서 진짜 속상하다...ㅋㅋㅋㅋ RSS 파일 바뀌는 것까지 봤는데 왜 알림이 안 가지?\n- 열심히 해야겠다. 나는 몰라서 허둥대는 모습보다 내가 많이 아는 모습이 더 좋다. 질문할 때는 부끄러움 없이 물어보고, 알게 된 내용은 남에게 부끄러움 없이 대답할 수 있을 정도로 공부하자."},{"excerpt":"LOG 블로그에 rss를 추가했다. 잘 작동하는지 확인하는 중이다. 배운 것 궁금한 것 어려웠던 것 느낀 것","fields":{"slug":"/2023-04-05/"},"frontmatter":{"date":"2023년 04월 05일 06:04","title":"2023년 04월 05일","tags":null},"rawMarkdownBody":"## LOG\n- 블로그에 rss를 추가했다. 잘 작동하는지 확인하는 중이다.\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"LOG 그 전날 5시까지 술을 마시는 바람에.. ㅎ 9시에 일어나게 돼서 40분 지각했다. 앞으로는 잠을 좀 더 많이 자자~ 레벨1 방학식이었다. 체인저가 우지컬 우승했다. 내가 그 전날 알코올 이슈로 지각하는 바람에 참여하진 못했지만 차라리 못한게 다행인 거 같다 ㅋㅋㅋ 그날 입은 옷으로 우지컬을 할 수는 없었다... 체인저의 기타를 빌려서 리오와 제이…","fields":{"slug":"/2023-03-31/"},"frontmatter":{"date":"2023년 04월 01일 14:04","title":"2023년 03월 31일","tags":null},"rawMarkdownBody":"## LOG\n- 그 전날 5시까지 술을 마시는 바람에.. ㅎ 9시에 일어나게 돼서 40분 지각했다. 앞으로는 잠을 좀 더 많이 자자~\n- 레벨1 방학식이었다. 체인저가 우지컬 우승했다. 내가 그 전날 알코올 이슈로 지각하는 바람에 참여하진 못했지만 차라리 못한게 다행인 거 같다 ㅋㅋㅋ 그날 입은 옷으로 우지컬을 할 수는 없었다... 체인저의 기타를 빌려서 리오와 제이, 민트가 기타 메들리?를 해줬다. 앉아서 노래부르고 기타치는 모습들이 낭만 그 자체여서 분위기가 되게 좋았다. 왠지 나도 기타를 쳐보고 싶다는 생각이 들었다 ㅋㅋ 일렉 기타 배워보고 싶었는데 아직도 도전 못하고 있다.\n- 내가 사연에 체인저, 박스터를 적었는데 그 두 명이 다 사연 선정돼서 상 받게 될 줄은 몰랐다... 그럴 줄 알았으면 좀 더 정성스럽게 쓸 걸 ㅋㅋㅋ 중간에 주노도 상을 받았는데 이름 퀴즈 대상자(?)로 선정돼서 망고랑 같이 앞에 나가게 됐다. 솔라.. 저희 5시까지 같이 있었는데... ㅋㅋㅋㅋ 다행히도 주노가 내 닉네임 맞춰줘서 좋았다~\n- 박스터, 주드, 주노, 포이, 글렌이랑 건대에서 방탈출했다. 근데 방에 들어가자마자 2명씩 격리돼서 ㅋㅋㅋ 웃겼다. 이렇게 서로 떨어져서 하는 방탈출은 처음해봤는데 재밌었다. 방탈출 끝나고 닭갈비 집에서 술을 마셨다. 중간에 다른 크루들도 보드게임하다가 그 닭갈비 집에서 밥을 먹어서 만나게 됐다 ㅋㅋ 헤나, 성하, 썬샷, 코코닥은 남아서 같이 마셨다. 성하랑 글쓰기 같은 조여서 얘기해보고 싶었는데 우연히 거기서 만나게 돼서 좋았다 ㅋㅋ\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 배운 게 없는 TIL... 그냥 일기가 됐다. Today I Felt 이런 걸로 바꿔야 되는거 아닌가 싶다..\n- 술을 좋아하는 건지 술자리를 좋아하는 건지 ... 이번 주는 수요일 빼고 (레벨 인터뷰 전날) 4일을 술마셨다. 원래 그렇게 마시면 속도 안 좋고 그래야 하는 게 맞는데 요즘에는 숙취가 없어졌다. 친구 말대로 너무 많이 마시면 숙취가 사라진다더니 진짜인가.\n"},{"excerpt":"LOG 새싹교실 수업을 했다. 진행하다보니까 너무 쉬웠나 싶었다. 좀 더 어렵게 가도 될지 아닐지 고민했는데 오늘 수업 회고 보니 적당한 거 같다. 제발 질문을 해줬으면 좋겠다 ㅋㅋㅋ 그냥 내용은 대충하고 질문으로 수업하는 시간이 됐으면 좋겠다. 그렇지만 이렇게 3년 말해본 결과 절대 질문 안 나올거라는 건 잘 안다... ㅋㅋㅋ 투썸 스트로베리 피치 프라…","fields":{"slug":"/2023-04-01/"},"frontmatter":{"date":"2023년 04월 01일 13:04","title":"2023년 04월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 새싹교실 수업을 했다. 진행하다보니까 너무 쉬웠나 싶었다. 좀 더 어렵게 가도 될지 아닐지 고민했는데 오늘 수업 회고 보니 적당한 거 같다. 제발 질문을 해줬으면 좋겠다 ㅋㅋㅋ 그냥 내용은 대충하고 질문으로 수업하는 시간이 됐으면 좋겠다. 그렇지만 이렇게 3년 말해본 결과 절대 질문 안 나올거라는 건 잘 안다... ㅋㅋㅋ\n- 투썸 스트로베리 피치 프라페 맛있었다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 과외하면서 내가 선생하면 안 된다는 것만 느끼고 있다.. 어떻게 하면 잘 설명하고, 잘 이해시킬 수 있을까?\n\n## 느낀 것\n- 벌써 4월이다. 새롭게 TIL 페이지를 만들면서, 기분이 이상했다. TIL을 이렇게까지 열심히 쓰게 될 줄 몰랐는데. 오히려 TIL을 봐주는 사람들이 있어서 더 열심히 적었던 것 같다. 구독자 여러분 감사합니다~\n- 갑자기 회고 모임 댓글이 달려서 봤는데 글렌이 멋진 글을 달아줬다. 이 사람... 감동이다 🥹 내가 처음에 우테코에 붙게 되었을 때 그냥 휴학 때 할 거 없었는데 잘 됐다는 생각만 있었다. 혼자 공부하면 금방 슬럼프가 올 걸 알았기 때문이다. 마침 친구들도 인턴에 학부 연구생에 바빠서 진짜 혼자 공부했어야 했다. 그런데 이렇게 우테코에 와서 같이 공부할 사람도 생기고, 같이 놀 사람도 생기고, 프로그래밍 고민, 내 고민을 진지하게 들어줄 사람들이 생겨서 정말 좋다. 그래서 나는 우테코에서 좋은 사람들을 많이 만나고 싶다. 주노처럼 100명과 모두 알게 되기는 힘들겠지만, 그냥 앞으로도 사람을 챙기는데 열중할 것 같다. 그냥 그렇게 하고 싶다~ 내가 하고 싶은 게 얼마 없으니까 하고 싶은 게 생겼을 때 진심으로 할 수 있다.\n- 나를 돌아보는 오글거리는 말을 많이 써보자. 지금 생각했던 고민들은 나중에 하나도 기억 안 나니까 지금만 쓸 수 있는 글이다. 거의 반 일기가 되어 가는 TIL 정말 괜찮은가?\n"},{"excerpt":"2023-04-01 2023-04-05 2023-04-06 2023-04-07 2023-04-08 2023-04-10 2023-04-11 2023-04-12 2023-04-13 2023-04-14 2023-04-15 2023-04-17 2023-04-18 2023-04-19 2023-04-20 2023-04-24 2023-04-25 2023-04-27 2…","fields":{"slug":"/2023-04/"},"frontmatter":{"date":"2023년 04월 01일 13:04","title":"2023년 04월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-04-01]]\n- [[2023-04-05]]\n- [[2023-04-06]]\n- [[2023-04-07]]\n- [[2023-04-08]]\n- [[2023-04-10]]\n- [[2023-04-11]]\n- [[2023-04-12]]\n- [[2023-04-13]]\n- [[2023-04-14]]\n- [[2023-04-15]]\n- [[2023-04-17]]\n- [[2023-04-18]]\n- [[2023-04-19]]\n- [[2023-04-20]]\n- [[2023-04-24]]\n- [[2023-04-25]]\n- [[2023-04-27]]\n- [[2023-04-28]]\n"},{"excerpt":"LOG 레벨 인터뷰 했다. 내가 첫 번째였는데, 아침 8시 30분까지 왔어야 해서 좀 많이 졸렸다. 이걸 쓰고 있는 지금도 너무 졸리다. 생각보다 덜 떨어서 생각보다 잘 말한 거 같다. 사실 제이슨이 말한 것처럼 내가 말하고 싶은 주제를 유도했었는데 알아채셔서 역시 코치구나 싶었다 ㅋㅋㅋ 첫 타자라 그런지 칭찬을 많이 받아서 기분이 좋았다. 내가 말할 때…","fields":{"slug":"/2023-03-30/"},"frontmatter":{"date":"2023년 03월 30일 06:03","title":"2023년 03월 30일","tags":null},"rawMarkdownBody":"## LOG\n- 레벨 인터뷰 했다. 내가 첫 번째였는데, 아침 8시 30분까지 왔어야 해서 좀 많이 졸렸다. 이걸 쓰고 있는 지금도 너무 졸리다. 생각보다 덜 떨어서 생각보다 잘 말한 거 같다. 사실 제이슨이 말한 것처럼 내가 말하고 싶은 주제를 유도했었는데 알아채셔서 역시 코치구나 싶었다 ㅋㅋㅋ 첫 타자라 그런지 칭찬을 많이 받아서 기분이 좋았다. 내가 말할 때 어,그,저 라는 말을 많이 쓰는 편인데 우르가 그 부분 지적해줘서 고마웠다. 소중한 피드백 감사합니다 👍 다음 레벨로그때는 잘 모르는 거 써도 될 거 같다. 오히려 질문을 받는게 좋았다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 내가 질문을 잘하고 있는 것 같지 않았다. 인터뷰 때 너무 쉬운 내용만 물어봤나? 싶어서 인터뷰이한테 좀 미안했다. 여우, 우르 미안합니다 😂\n\n## 느낀 것\n"},{"excerpt":"LOG 아침부터 대청소를 했다. 방점검이 있어서 9시부터 12시까지 청소만 했다. 밀린 일들을 한 번에 해결하니 기분은 좋았다. 근데 청소하는 게 너무 힘들어서 하루 끝까지 기운이 없었다. 토리와 같이 레벨 인터뷰 준비를 했다. 청소 끝나고 검사 받아야 돼서 잠깐 카페에서 공부하고 있었는데 토리가 같이 준비하자고 해서 구디단에서 만났다. 각자 상대 레벨로…","fields":{"slug":"/2023-03-29/"},"frontmatter":{"date":"2023년 03월 30일 06:03","title":"2023년 03월 29일","tags":null},"rawMarkdownBody":"## LOG\n- 아침부터 대청소를 했다. 방점검이 있어서 9시부터 12시까지 청소만 했다. 밀린 일들을 한 번에 해결하니 기분은 좋았다. 근데 청소하는 게 너무 힘들어서 하루 끝까지 기운이 없었다.\n- 토리와 같이 레벨 인터뷰 준비를 했다. 청소 끝나고 검사 받아야 돼서 잠깐 카페에서 공부하고 있었는데 토리가 같이 준비하자고 해서 구디단에서 만났다. 각자 상대 레벨로그를 읽어보고 질문을 준비해줬다. 하나씩 대답하는 시간을 가졌는데 진짜 도움이 많이 됐다. 예전에도 그렇게 떨리진 않았지만 질문까지 준비하고 대비(?)하다보니 훨씬 더 잘 준비할 수 있었던 것 같다.\n- 그 분에게 메일을 보냈다. 최근에 메일이 왔었는데 예전 생각이 많이 났다. 보낼까 말까 하다가 그냥 보내버렸다. 답장은 안 와도 괜찮다. 답장을 바라고 쓴 게 아니었으니까.\n\n## 배운 것\n- `System.lineseperator()`는 시스템에 저장된 개행 문자를 읽어와서 리턴한다. 각 OS마다 개행 문자가 다르기 때문에 `\\n`보다 lineseparator를 사용하는 것이 좋다.\n\n## 궁금한 것\n- 어떤 경우에는 디미터의 법칙을 위반해도 괜찮을까?\n- 보편적으로 확장이 예상되는 경우에도 구현하지 않아야 할까? (YAGNI 원칙을 지켜야 할까?)\n\n## 어려웠던 것\n- 질문에 정확하게 대답하는 게 어렵다. 질문에 꼬리 질문이 계속되면 원래 질문을 잃어버린다. 배경을 열심히 설명하다보니 어떤 걸 말하고 있는지 까먹는다... 계속 질문이 뭐였는지 생각하면서 말해야겠다.\n- 하나에 집중하는 게 어렵다. 금방 집중이 분산된다. 레벨로그 주제가 여러 개 있었는데 하나 쓰다가 갑자기 다른 거 쓰고 싶어서 다른 거 쓰다가 다시 돌아오고 무한 반복이었다. 진짜 집중력 부족이다..\n\n## 느낀 것\n- 그때 나는 정말 아무것도 없었구나 싶다. 지금은 정말 많이 나아졌는데, 그때는 그냥 깜깜했다. 해야 하는 게 있는데도 아무것도 손에 안 잡히고, 그냥 누워있고 싶었던 날들이었다. 그렇지만 그때도 이겨냈다. 지금의 내가 있으니까. 만약 앞으로 그런 때가 다시 온다고 하더라도, 지금의 기억이 힘든 날들을 무사히 보내게 도와줄 것 같다. 정말로 감사하다.\n- 예전보다 생각을 덜한다. 좋게 말하면 걱정이 없고, 나쁘게 말하면 생각이 없다. 이런 때가 예전에도 종종 있었는데 그럴 때마다 바보같은 결정을 해버렸다. 그래서 지금도 조심해야 한다. 걱정이 없는 건 좋은 건데 생각이 없는 건 안 좋은거다. 지금보다는 좀 더 생각을 하면서 살아보자.\n\n"},{"excerpt":"디미터의 법칙 객체의 내부 구현에 대한 정보를 외부로 노출하지 않는 것이다. 객체의 결합도를 낮출 수 있고, 변경에 유연하고 유지보수하기 쉬운 코드를 작성할 수 있다. IllegalStateException vs IllgalArgumentException : 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알린다. : 메서드에 잘못되거나 …","fields":{"slug":"/level1-level-log/"},"frontmatter":{"date":"2023년 03월 28일 04:03","title":"레벨1 레벨로그","tags":["우테코","레벨1","레벨로그"]},"rawMarkdownBody":"\n## 디미터의 법칙\n\n- 객체의 내부 구현에 대한 정보를 외부로 노출하지 않는 것이다.\n- 객체의 결합도를 낮출 수 있고, 변경에 유연하고 유지보수하기 쉬운 코드를 작성할 수 있다.\n\n## IllegalStateException vs IllgalArgumentException\n\n- `IllegalStateException`: 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알린다.\n- `IllegalArgumentException`: 메서드에 잘못되거나 부적절한 매개변수가 전달되었음을 알린다.\n\n## YAGNI (You are not gonna need it)\n\n- 필요가 생기기 전에는 구현하지 않는다.\n- 현재는 사용하지 않지만 확장성을 고려해서 미리 작업하는 것은 자제하자.\n\n## 상속과 조합\n\n- 상속: 기존 클래스를 재활용하여 새로운 클래스를 작성하는 것. 중복된 코드를 줄이고 기능 확장이 가능하다.\n- 조합: 새로운 클래스를 만들고 필드로 기존 클래스의 인스턴스를 참조하는 것\n- 상속의 경우 하위 클래스가 상위 클래스의 구현에 의존하기 때문에 상위 클래스의 변경에 모든 하위 클래스가 영향을 받는다.\n\n## 불변 객체\n\n- 생성 후 내부 값을 바꿀 수 없는 객체이다. 사용되지 않고 버려지는 객체는 메모리 관리와 성능에 부담을 끼칠 수 있다.\n- 객체의 상태를 변경할 수 없도록 하고, 클래스를 final로 선언하여 클래스의 확장을 막는다. 클래스의 상태가 가변 객체일 경우 방어적 복사를 적용한다.\n- 장점: 생성자, 접근 메소드에 대한 방어적 복사가 필요 없다. 멀티 스레드 환경에서 동기화 처리 없이 객체를 공유할 수 있다.\n- 단점: 메모리 누수 문제가 존재한다. 사용해야 하는 값의 가짓수가 많으면 그만큼 많은 객체가 생성되어야 하여 성능에 부담을 줄 수 있다.\n\n## VO\n- 도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.\n- aliasing 문제 때문에 불변 객체로 만들어야 한다.\n- 속성 값이 동일할 때 같은 객체로 만들기 위해 `equals()`와 `hashCode()` 를 재정의해야 한다.\n\n## 함수형 인터페이스\n\n- 1개의 추상 메서드를 갖는 인터페이스\n- 구현 클래스, 익명 클래스, 람다로 구현할 수 있다.\n- 동시성 side effect를 없앨 수 있다. 구조적으로 유연하고 간결하다.\n\n## DTO\n\n- 계층 간 데이터 교환을 하기 위해 사용하는 객체\n- `getter`, `setter`를 포함하며, 비즈니스 로직은 포함하지 않는다. 그러나 굳이 값을 변경할 필요가 없는 경우 `setter`를 만드는 것보다 생성자에서 값을 할당하는 것이 좋다.\n\n## 디폴트 메서드\n\n- 인터페이스에 있는 구현 메서드.\n- 기존의 구현을 고치지 않고 이미 공개된 인터페이스를 변경하기 위해 고안되었다.\n- 선택형 메서드: 기존 인터페이스에서 잘 사용되지 않는 메서드를 디폴트 메서드로 작성하여 인터페이스 구현 클래스에서 빈 메서드 구현을 하지 않도록 한다.\n- 동작 다중 상속: 인터페이스는 여러 개를 구현할 수 있어 인터페이스를 조합하여 다양한 클래스를 만들 수 있다.\n\n## 우르 질문\n\n- 원시 값 포장의 단점\n- **모든 원시값을 포장하시는 편이신가요? 기준이 따로 있으신가요? 원시 값 포장을 할 때 드는 비용과 하지 않을 때의 비용 차이는 어떨까?**\n- VO가 불변성을 지원해야 하는 이유는 뭐라고 생각하는가?\n- 설계에 얼마나 시간을 쏟는 편인가?\n- 설계는 계속해서 변경되지 않나? 얼마나 완벽한 설계를 추구하는가?\n- **일급 컬렉션을 사용하지 않았을 때 발생하는 사이드 이펙트란 무엇을 의미하는가? 일급 컬렉션을 사용해서 어떻게 막을 수 있는가?**\n- **`unmodifiableList`  는 어떤 때 사용하면 좋을까?**\n- 설계하면서 객체지향적 설계가 안 좋은 점이 있었나요?\n- 설계에서 가장 중요하게 생각하는 부분은?\n- **역할과 책임을 적절하게 할당이 되었는지 어떻게 확인할 수 있을까?**\n- **어떤 경우에 일급 컬렉션을 사용하면 좋을까?**\n- 코드를 구현하다 보면 어느 정도 확장성을 고려해서 구현해야 하는 부분도 있다고 느껴지는데, 아예 확장성을 제외하고 미션을 진행하셨나요? 그것이 아니라면 어느 기준까지 확장성을 고려해야 한다고 생각하시나요?\n- 메모리 누수 문제가 단점이라고 하셨는데 어느 기준까지 사용해도 된다고 생각하시나요?\n- 어째서 VO를 사용해야겠다고 생각하셨나요?\n- TDD 커밋 단위는 어떻게 하는 게 좋다고 생각하시나요?\n\n### 우르 피드백\n\n자신의 생각을 자신감 있게 말하는 모습이 좋았다.   \n솔직하게 답변하는 모습이 좋다.   \n경직되지 않고 여러 제스처를 사용해서 답변이 어색하지 않았다.   \n답변에서 자신만의 철학이 느껴져서 좋았습니다.   \n\n\n## 제나\n\n### 질문\n\n- `private` 메서드도 테스트 하는가? 왜 그렇게 쓰는가?\n- domain과 view의 의존은 어떤 경우에 의존한다고 할 수 있을까?\n- 프로덕션 출력용으로 사용하지 말아야 하는 이유가 무엇일까?\n- `toString()`  을 정의해서 좋았던 점이 있나?\n- 어느 정도의 개수까지 캐싱해도 된다는 기준이 있나?\n- 캐싱을 하게 되면 접근 시간이나 계산이 없게 되는 것인가?\n- 어떤 경우에 캐싱을 주로 사용하면 좋을까? (얼마나 자주 사용될 때?)\n- TDD를 할 때 힘들었던 점은 없나?\n- 정의한 `toString()` 은 어디서 쓰는가?\n- 캐싱할 때 주로 어떤 자료구조로 구현하는가?\n- 방어적 복사를 안 해도 되는 경우가 있을까?\n- view에서 모델 객체를 받아서 출력해도 된다고 생각하시나요? 아니면 DTO 객체를 따로 두는 것이 좋다고 생각하시나요?\n- 모델에서 view에서 출력하기 위한 로직이 있어도 된다고 생각하시나요?\n- 모든 경우에 일급 컬렉션을 사용하는 게 좋은가요?\n\n## 테오\n\n### 속기\n\n- 모든 도메인 속성들에 대해 커스텀 예외를 만들었나? : 예외 객체가 지금은 작은 시스템이지만 큰 시스템이라고 한다면 예외 객체가 관리 대상이 되기 때문에 비용이 클 수 밖에 없다. 예외 객체도 도메인이 수정될 때 같이 수정되어야 하기는 하지만 관리가 어렵다.\n- 예외 필드로 무엇을 가질 수 있는지가 중요하다. 예외 객체가 추상화 레벨을 파괴할 수 있다. 원시 타입 정도는 가져도 될 거 같다.\n- 예외 객체가 도메인에 의존된다는 느낌이 있는 경우 사용하면 안 될 거 같다.\n- 자료구조는 값이 중심이 될 수 밖에 없어서 디미터의 법칙이 적용되지 않아도 된다고 생각한다.\n- 일급 컬렉션에서는 디미터의 법칙을 덜 지켜도 되나? : 일급 컬렉션 객체를 반환하는 것에 대해 큰 문제라 생각하지 않는다. 상태와 행위를 동시에 관리하기 위한 객체라고 생각한다. 굳이 일급 컬렉션에서는 디미터의 법칙을 준수하지 않아도 된다고 생각한다.\n- 모든 과정에서 TDD 했는가? : 모든 과정에서 하지는 못했다. 시간적 압박 때문에 초반에는 TDD를 하게 되었지만 마감일이 다가올 때는 프로덕션 코드만 작성하고 테스트는 검증용으로만 사용했다.\n- TDD가 시간이 오래 걸리는 이유? : 만들어지지 않은 것에 대한 행위를 작성하기 때문에.\n- 이상적으로는 안정적인 코드. 현실적으로 생각했을 때 버려야 할 때가 있다. \n- TDD에서 신경쓰는 것?: 인간의 인지 능력을 제어하는 것이라고 생각한다. 베이비 스텝으로 진행하려고 의식적으로 노력했다. 그런 과정을 통해 예측하고 있던 자신만의 기준이 사라지는 듯한 느낌을 받았다.\n- TDD를 잘하지 않는 환경에서 TDD 하자고 설득한다면?: 테스트 코드가 하나의 문서가 될 수 있다. 테스트 코드는 변경에 대처할 수 있는 하나의 수단이 될 수 있다.\n- TDD를 왜 해야 하는가?: 테스트 코드를 잘 짜고, 좋은 프로덕션 코드를 만드는 수단으로서 TDD를 사용하는 것이 좋을 거 같다.\n- TDD가 어떻게 좋은 프로덕션 코드를 만들 수 있는가? : 가독성 측면에서 이점이 있을 거 같다.\n- TDD 사이클 중에서 가장 중요한 것: 실패한 테스트를 만드는 것. 실패한 테스트이면서 클라이언트가 원하는 정보인가? 이 객체에 해당하는 행위인지를 생각해봐야 한다. 실패한 테스트를 선별하는 작업이 중요하다.\n- 실패하는 요구사항을 작성하면 되지 않을까? TDD 만의 장점인가?: TDD는 하나의 구현 과정이기 때문에 요구사항 분석보다는 잘 사용하는 것이 좋을 것 같다.?\n- 테스트 코드 작성함에 있어서 검증 코드를 만드는데 있어서 본인만의 신경쓰는 부분이 있는가?: 모든 테스트가 당연히 통과할 수 밖에 없는 코드로 만들어졌다. 이것을 검증으로 볼 수 있을까에 대한 고민을 많이 했다. 예측하는 행동인가? 예측할 수 없는 부분에 대한 테스트를 만들기 위해 의식적인 생각을 많이 하게 된다.\n- 테스트에 대한 기법이 뭐가 있을까? : 테스트를 작성할 때 이것이 과연 클라이언트가 원하는 정보인가?에 대한 생각을 하게 된다. 모든 유스케이스를 생각해보고 필요한 행동이라고 생각될 때 구현한다.\n- 유스케이스 작성??: 어떤 시나리오가 존재할지 생각해보는 것. 프로덕션 코드와 테스트 코드 작성자를 분리하는 것도 좋은 방법이다.\n- 테스트 코드가 부정적인 영향을 준 적은 없는가?: 설계 반영에 대한 테스트는 실패하는 것이 맞다. 그에 따른 오버헤드가 발생할 수 밖에 없다. \n- 테스트 코드가 없는게 확인하기 편하지 않을까? : 테스트가 있으면 변경했을 때 이게 아니다 라는 것을 알게 되기 때문에 필요하다.\n- 테스트 코드를 작성하면서 유의했던 점?: 국소적인 부분을 테스트하고 있나?라는 생각을 하고 있다. 프로덕션 코드와 연결해서 생각해서 해당 부분에 대한 테스트가 정말 이 부분에 대한 테스트가 \n- 데이터 베이스 연동 부분 테스트는 했는가? : 데이터베이스는 테스트하지는 못했다. 작성을 해야 한다면 테스트용 툴을 사용할 것 같다. mock이나 spy 같은 것을 사용할 것 같다.\n- 데이터 베이스는 테스트를 안 해도 되나?: 해야 하기는 하지만 데이터베이스의 값을 확인하기 위한 테스트는 필요 없다고 생각한다. 테스트 해야 할 부분은 서비스 계층, DAO 비즈니스 로직 부분이라고 생각한다.\n- 쿼리는 따로 검증의 대상이 되어야 한다고 생각한다.\n- 죄송해요 이 이후부터는 잘 못 적었어요 ㅋㅋ ㅜㅜ\n\n### 피드백\n\n말을 적당한 속도로 차분하게 잘 말했다.   \n개발에 대한 확실한 자기 주관이 있다는 생각이 들어서 좋았다.   \n말을 더듬는 부분이 없이 명확한 답변을 해주셔서 좋았다.    \n대답을 하다 보면 질문에 대한 답이 아닌 다른 답을 할 때가 있었다. 꼬리 질문을 하다보면 원래 질문에서 멀어진 답을 한 적이 있어서 그 부분을 신경 써주시면 좋을 것 같다 ˙ᵕ˙   \n\n## 필립\n\n### 속기\n\n- 이전에는 기능적으로 할 수 있는 단위로 커밋했었는데 실행 가능한 단위로 커밋하는 것이 좋아보인다.\n- 언제 hashcode, equals를 하거나 하지 않나요? : 단순 기능 구현을 위해 사용한다기보다는 같은 것으로 확인하는 경우에는 동등하다고 생각한다. 그 외의 경우에는 ...\n- 인덱스만 같으면 동등한가요?\n- 자바의 hashcode 내부 알고리즘은 알고 계신가요?\n- 미션 수행 하시면서 null 반환을 하셨나요 아니면 Optional을 반환하셨나요?: 굳이 해야 한다면 Optional을 리턴하거나 예외를 반환하는 방식으로 구현했다.\n- Optional을 굳이 쓰는 이유가 있나요? : null을 반환하게 되면 실행 결과를 받는 곳에서 null 체크를 하는지 확인해야 한다. Optional을 사용하면 빈값인지 아닌지 확인하는 것을 명시적으로 할 수 있어서 좋다.\n- 이번 미션에서 상속과 조합을 어떻게 적절하게 사용하셨나요? : 체스 미션의 기물에서는 상속을 사용했습니다. 킹, 퀸이라는 각자의 기물들 종류가 기물에 포함 관계가 확실하기 때문에 사용했습니다. 조합의 경우는 블랙잭 때 사용했다. Money를 만들고 BettingMoney가 Money를 인스턴스로 사용했었다.\n- 모든 동등성을 가진 객체가 캐싱이 필요한가요?: 반복적으로 생성하는 일이 많을 때 하는것이 좋다.\n- 그런 경우가 어떤 경우가 있을까요?: 체스 판에서의 위치 정보를 표현할 때. 매 이동마다 시작점과 끝점, 사이의 점을 계속 생성해야 해서, 이런 경우 캐싱을 사용하면 좋을 거 같다.\n- 캐싱을 할 때 고려할 점이 있을까요?: \n- 캐싱을 할 때 문제가 발생할 수 있는 점이 있을까요? : 캐싱을 한 객체가 불변 객체가 아닌 경우 다른 곳에서 값이 변경되면 캐싱 내부의 객체 값이 변경되어 사용하는 다른 곳도 값이 변경되게 된다.\n- 상태 패턴을 어떻게 쓰셨나요?: 체스에서 게임 상태를 표현할 때 사용했다. 각각의 경우에 따라 체스의 말을 움직이거나 명령을 내렸을 때 기능을 수행할 수 있는지 없는지 구분이 필요할 때 사용했다.\n- 전략 패턴에 대해서 아시나요?: 정확하게는 잘 모른다. 행위를 해야 할 때 행위에 대한 의미나 행위를 통해 나와야 할 결과물이 정해졌을 때, 결과물을 만드는 방법이 다른 경우 다양한 전략들을 생성해두고 필요에 따라 구현된 전략을 사용할 수 있는 것이 전략 패턴인 것 같다.\n- 상태 패턴과 전략 패턴을 비교해서 설명해주세요.: 전략은 한 번 정해진 전략을 잘 바꾸지 않는 것 같다. 상태 패턴은 진행되면서 유연한 변화가 가능하다는 차이가 있다. 변경된 상태를 반환하는 방법으로 새로운 상태를 반환할 수 있다.\n- DTO를 생성할 때 도메인을 전달 받도록 하셨나요? : 도메인이 내부에 포함되게 되면 뷰에서 받을 때 도메인 객체를 그대로 가져올 수 있게 되어서 숨기고 싶은 정보들도 공개될 수 있다. 그래서 DTO를 생성할 때 풀어서 주는 편이다.\n- 파라미터가 너무 많아지지 않나요? : 도메인의 정보를 숨기는 것이 우선시 되어야 한다고 생각한다.\n- 도메인의 정보를 어떤 이유로 숨겨야 할까?\n- 이번 미션에서 숨겨야 하는 경우가 존재했나요?: 체스에서 기물에 대한 정보를 꺼내서 사용했는데, 기물 자체가 자신이 이동한 위치의 기물을 반환하는 기능을 갖고 있었다. 기물 정보를 그대로 보내면 뷰에서 기물을 조작할 수 있기 때문에 이를 막기 위해 사용했다.\n- 도메인과 뷰를 개발한 사람이 달랐나요?: 혼자서 개발한다고 하면 굳이 DTO를 쓸 필요가 없다고 생각한다. 연습하고 공부하는 입장에서 언젠가 함께 일하는 상황을 연습하려고 사용해보고 있습니다. \n- 프로젝트가 길어지게 되면 유지보수를 하고 다음에 사용할 때도 어떤 목적을 위해 전달했는지 확실히 하기 위해 썼다는 걸 명시해줄 수 있다. 그런 경우 DTO를 사용하는 것이 좋아보인다.\n- 도메인 하나만 전달하면 값을 전달하는 것보다 유지 보수가 편하지 않을까요? : 도메인이 변하거나 뷰가 변하는 사항이 있을 때 도메인에 대한 변화까지 전파될 수 있어서 좋지 않다고 생각한다.\n- 방어적 복사를 사용하게 되면 굳이 DTO를 사용하지 않아도 되지 않을까요? 훼손이 문제라면?: 훼손만 문제가 된다면 내부적으로 변화에 대한 것은 막을 수 있지만 ... ()\n- 모델 뷰 컨트롤러는 레이어인가요?: 목적이 다르니까 레이어라고 봐도 된다고 생각합니다.\n- 일단 뷰에서 컨트롤러로 올 때는 원시 타입으로 받을 수 있을 때는 그대로 받고 연관이 되는 데이터를 받아서 합쳐서 보낼 때에는 DTO를 사용했습니다. 컨트롤러에서 도메인으로 넘길 때도 단순한 하나의 원시값이나 문자열로 보낼 때는 그냥 보내지만 연관된 정보가 있는 경우에는 DTO를 리턴합니다.\n- 본질적으로 DTO라는 것은 왜 생겼을까요?: 제가 생각했을 때 어떤 한 쪽의 변화가 다른 한 쪽으로 전파되는 것을 최대한 막기 위해서입니다.\n- 도메인에 DTO는 왜 필요할까요?: 도메인 객체에 대한 것을 다른 곳에서 모르게 하기 위해서.\n\n### 피드백\n\n꼬리질문이 계속해서 이어졌는데 최대한 열심히 대답하려고 하는 모습이 좋았습니다.   \n미션에서 직접 사용한 내용에 대해서 작성한 것이 느껴져서 좋았습니다.   \n모르는 부분에 대해서 미리 인정하는 것이 좋았습니다. 잘 모르겠는 부분을 인정해주셔서 좋았습니다.   \n꼬리 질문이 이어질 때 약간 당황하는 모습이 보였는데 답변 잘 이어나갔던 것 같습니다.   \n'이제' 라는 단어가 당황할 때 자주 언급되는 것 같습니다.   \n\n## 달리\n\n### 속기\n\n- 미션 하면서 TDD로 개발했는데, TDD의 장점과 힘든 점이 있었을까요?: 여러 가지 객체들이 이런 기능을 갖겠다, 라는 일종의 방향성을 갖는 장점이 있었습니다. 프로덕션 코드가 변경이 될 때마다 테스트 코드를 고쳐주는 과정에서 오히려 시간이 오래걸렸다.\n- 프로덕션 코드를 고치면서 테스트가 깨졌던 경험이 있었나요? : 처음에 TDD를 하면서 이런 방향성을 갖고 작성했지만, 이후 놓쳤던 부분이 발견되기도 하여서 변경 사항이 생겼습니다. 설계적인 부분에서 문제가 발생한 경우에도 문제가 생겼었다.\n- 달리가 생각하는 리팩토링의 정의란 무엇인가요?: 기능적인 면이나 프로덕션 코드를 구현했음에도 유지보수 측면에서 좋은 방향으로 만들거나 변경할 때가 리팩토링이라고 생각합니다.\n- 테스트 코드를 고치는 것도 리팩토링일까요? : 같은 기능을 하되 설계적 측면에서 변경이 될 수도 있기 때문에 유지보수 측면에서 코드 추가적인 수정이 필요할 때는 필요하다면 리팩토링이라고 할 수도 있을 거 같다.\n- 객체에 물어보지 말고 일을 시키는 것을 지양해야 하는 이유가 무엇인가요?: 자동차 미션 때 왜 getter를 지양해야 하는가에 생각해야 했다. 책임을 객체에게 주라는 뜻으로 이해했다.\n- JUnit5와 JUnit4의 차이?: 모르겠다.\n- 원시값 포장, 값 객체 모두 값을 포장하는 것인데 차이점이 뭐가 있을까요?: 원시값 포장은 어떤 값을 포장함으로써 유효성 검사를 내부에서 할 수 있기 때문에 사용한다. 다른 값들과의 비교가 필요한 경우 값 객체를 사용한다.\n- extracting 메서드를 사용한 이유는 무엇인가요?: 체스 미션에서 64개의 칸을 갖고 있는지 확인하기 위해 사용했다. 테스트로 제대로 확인하기 위해 extracting을 사용했습니다.\n- private을 테스트 하는 이유는 무엇인가요?: 테스트를 위해 public을 사용하지 않기 위해서 사용했다.\n- private으로 막아두는 이유는? : 외부에서 값을 감추기 위해서\n- 테스트에서는 열어서 검증할 필요가 있을까?: 특수한 상황이었다. 생성과 관리를 내부에서 하기 때문에 프로덕션에서는 감춰져 있지만 테스트에서는 해야 할 거 같다.\n- 다른 방법으로 해결할 수 있는 방법이 있을까?: 찾지 못했다.\n- equals를 사용해서 해시코드를 비교하는 방법도 있었을 것 같은데 어떤가요?: 테스트를 위해 equals, hashcode를 만드는 것은 getter를 만드는 것과 차이가 없다고 생각한다.\n- getter를 안 만들어야 하는 이유가 있나요? : 캡슐화를 깨는 것이고, 프로덕션 로직에도 필요 없어서 테스트에서 해결하는 방법인 extracting을 사용하였다.\n- extracting을 사용해서 생기는 문제점이 있을까요?: 하드코딩이기 때문에 문제가 될 것이라고 생각했다. getter를 추가하거나 프로덕션 코드를 바꾸느니 extracting을 사용하는 것이 나은 거 같다.\n- 책임 연쇄 패턴과 상태 패턴을 어떤 경우에 사용하셨나요?: 책임 연쇄 패턴은 같은 요청에 따라 자동적으로 구현체가 정해지고 고르게 되어 어떤 움직임을 하는지 알기 위해 사용했다. 상태 패턴을 통해 체스 게임의 상태를 관리했다.\n- 다형성에 대해 설명해주세요.: 추상적인 것을 통해 어떤 것을 추상화하고 입력을 했을 때 추후에 입력할 것을 정의해서 유지보수 차원에서 유연하게 한다.\n- 어떤 부분에서 유지보수가 좋나요?\n- 좋은 객체지향은 무엇일까요?: 객체가 응답과 요청을 통해서 객체 스스로가 일을 시키게 하는 것이 좋은 객체 지향인 것 같다. 객체의 상태를 변하게 함으로써 시스템이 돌아가게 하는 것이 객체지향이라고 생각한다.\n- SOLID 중에서 인상 깊었던 원칙이 있을까요?: open-closed 원칙.\n- 본인 미션에서 그런 부분을 지키고자 노력했던 순간이 있었나요?: 단일 책임 원칙을 지키려고 노력했다. 가장 작은 단위를 갖도록 노력했다. 각 객체들이 하나의 책임만을 가질 수 있게 유도할 수 있어서 최대한 단일 책임 원칙을 지키려고 했다.\n- 하나의 책임을 정의하는 본인만의 기준점이 있을까요?: 정확한 단계나 선이 없어서 찾기 힘들었다. 자신에게 꼬리 질문을 하면서 최대한 줄이려고 노력했다.\n- 체스 미션 구현 중에 단일 책임 원칙을 지키지 못한 부분이 있는 것 같습니다.\n- 체스 미션 중에 데이터 베이스 연동하면서 인상 깊었던 부분, 신경 쓴 부분이 있을까요?\n- MVC 패턴과 레이어는 어떤 차이가 있을까요?\n- 서비스를 테스트할 때 어떻게 하셨나요?\n- 컨트롤러는 테스트 하지 않은 이유가 있을까요? : 도메인과 뷰를 분리해주는 역할이라 생각해서 뷰의 테스트를 하지 않기 때문에 컨트롤러도 하지 않았다. 컨트롤러가 뷰로 보내주는 데이터들을 확인하는 테스트를 작성했다. 그러나 하면 할수록 큰 로직이 없어서 테스트를 하지 않아도 될 것 같았다.\n- 뷰를 테스트 하지 않은 이유가 있을까요? : 현업에서는 협업을 하게 되기 때문에 뷰를 구현하는 부분은 확인하지 않아도 된다고 생각했습니다.\n- 큰 로직이 아니면 테스트를 하지 않아도 되나요?\n\n### 피드백 \n\n전체적으로 말이 빨라서 말이 밀리는 경우가 있었습니다.   \n본론이 앞에 나오면 좋을 것 같다.   \n\n질문자와 눈을 맞추려고 하는 모습이 집중하고 있다는 인상을 주는 것 같습니다.   \n모르는 부분을 말하고 알고 있는 부분을 최대한 말하는 모습이 좋았습니다.   \n미션 내용과 연관지어서 말해주셔서 어떤 부분에서 사용하셨는지 이해하기 쉬웠습니다.   \n\n## 제나\n\n### 속기\n\n- 모든 하위 클래스에서 재정의했을 때 문제가 발생하신적이 있나요?: 디버깅할 때 쓰면 유용하다고 해서 작성했습니다. toString은 디버깅 용도입니다. 프로덕션 요구사항이 변경되면 도메인의 toString을 고쳐야 하기 때문입니다.\n- 왜 뷰가 변할 때 도메인이 변하면 안 될까요? : 뷰는 변화가 잦은 곳이라서 도메인도 함께 변경되면 안정적인 도메인이 아니게 됩니다.\n- 도메인이 변할 확률이 굉장히 적은 경우에서는 변경될 여지가 없는데, 도메인이 뷰에 대한 정보를 가지고 있더라도 괜찮지 않을까요?: 도메인에서 꺼내기보다는 도메인을 뷰로 전달할 때 매핑 객체를 만드는 것이 좋아보인다.\n- 기계적으로 toString을 정의하게 되면 프로덕션 코드가 변경되는 경우 디버깅 시에 오류가 생길 수 있다. 언제쯤 toString을 오버라이딩 하는 것이 좋을까?: 객체 생성시에 toString을 오버라이딩 한다.\n- Object 클래스에 있는 메소드들에 어떤 것들이 있을까요?: clone, toString, equals, hashcode 정도 알고 있습니다.\n- A가 B를 가지고 있고, B가 A를 가지고 있으면 toString 시에 문제가 생기지 않을까요?: A가 변경되었을 때 B도 재정의를 해줘야 해서 문제점이 있을 것 같습니다. \n- 실제로 테스트 코드를 도입함으로써 어떻게 시간 절감을 실감하셨나요?: 나중에 리팩토링 과정을 거치면서 코드가 안정적으로 동작하는지 테스트 코드로 검증할 수 있어서 시간이 절약되는 것을 실감할 수 있었습니다.\n- 원시값 포장과 VO의 차이는 무엇이 있을까요?: 원시값 포장은 값을 포장한 것이고, VO는 동등성과 자기 유효성 검사도 할 수 있고, 불변이어야 한다는 특징이 있습니다. \n- 원시값 포장은 동등성이 보장되지 않나요?: 동등성 주소값이 다를 때 값이 같으면 같은 것으로 판단하는 것으로 알고 있습니다.\n- 사다리 미션에서 원시값 포장을 어떻게 하셨을까요?: 사다리의 높이, 플레이어 이름 등을 원시값 포장을 해줬습니다.\n- 그 객체들은 VO는 아닌가요?: Name은 VO로 바꿔주었습니다.\n- 불변 객체로 만드는 것과 가변 객체를 나누는 기준이 있으셨나요?: 보통은 불변 객체로 만들었다. 가변 객체는 계속 바뀌는 것들을 선언했습니다.\n- 일급 컬렉션을 가변이 아닌 불변으로도 선언하실 수 있으셨을텐데 그 부분에 대해 고민해보셨나요?\n- 객체를 한 번 생성하는데 비용이 많이 드나요?: JVM을 믿고 맡기면 된다고 생각하지만, 객체 생성에 대한 오버헤드는 많이 고려하지 않아도 된다고 생각합니다. \n- Java8에 추가된 큰 변화는 어떤 것이 있을까요?\n- 기존의 for문과 stream은 어떤 차이가 있을까요? stream에 대해서 설명해주세요: 파이프라인을 지나가듯이 돌리면서 요소 하나하나에 적용하고 싶은 operator들을 적용 시켜서 원하는 것들을 만들어줍니다. 중간 operator가 있고 종단 operator로 완료해 주어야 합니다. 종단 operator가 들어오면 그때 연산이 일어나서 stream을 할 수 있습니다. 사용하는 장점은 Collection을 돌면서 필터를 걸거나 match를 사용하는 경우 편리합니다.\n- 해당 기능은 단순 for문으로도 할 수 있지 않나요?: 가독성 측면에서 stream으로 구현하는 것이 좋을 때가 있다고 생각합니다.\n- stream이 for문보다 가독성이 좋다는 근거가 있을까요?: for 문은 어떤 컬렉션 안의 객체를 정의해주고 하나씩 돌려야 하는데, stream은 stream으로만 변환해주면 알아서 실행해주니까 더 편하다고 생각합니다.\n- 속도 측면에서는 어떻게 생각하시나요?\n- 일단은 for문이 더 빠르다는 건가요?\n- 충분히 메소드 분리를 통해 개선 여지가 있지 않나요?: 이중 for문을 사용하는 경우는 메소드 분리를 진행했습니다. 학습 목적과 가독성 측면에서 stream을 많이 사용했습니다.\n- for문의 가독성이 더 좋다고 생각하는 페어라면 어떻게 하실건가요?: 가독성과 성능 비교를 해보고 페어의 의견에 맞춰줄 것 같습니다.\n- 페어에 맞춰주지 못하는 부분이 있나요?: 메서드 중간에 공백을 두는 부분은 소신을 지키고 있습니다.\n- 테스트 하실 때도 공백을 두지 않으시나요?: 프로덕션에서만 두지 않는 편입니다.\n- view가 도메인에 의존하지 않아야 하는 이유는 무엇일까요?: 도메인 객체에 접근할 수 있기 때문에 뷰에 필요하지 않은 정보에도 접근할 수 있습니다.\n- 뷰에서 값을 보여줘야 하는데 도메인에서 가져오지 않으면 어떻게 가져오나요?: 도메인의 값을 원시값으로 풀어서 전달합니다.\n- 종단 연산에 관련된 함수 몇 개만 말씀해주세요. : foreach, count, sum\n- findAny, findFirst도 종단 연산일까요?\n- findAny, findFirst는 어떤 차이가 있나요?\n- shuffle이 된다는 것은 어떤 의미인가요?\n- stream을 사용하게 되면 리스트를 구성하는 순서가 바뀌게 되나요?\n- stream에서 중간 연산을 사용할 때 주의해야 할 점이 있을까요?: 실행이 안 되고 있다가 종단 연산이 오면 실행하는 거라서 단일 스트림이 아닌 병렬로 진행하면 고려해줘야 한다.\n- map, sorted, filter가 있을 때 어떤 순서로 배열해야 효율적일까요?\n- stream을 반환값으로 사용하면 안 된다고 하는데 왜 반환값으로 사용하면 안 되는지 설명해주실 수 있나요?\n- stream의 forEach를 지양해야 하는 이유가 무엇인지 말씀해주세요.\n\n### 피드백\n\n말을 더듬지 않고 차분한 어조로 말해주셔서 하고 싶은 말이 무엇인지 잘 전달됐습니다.   \n어려운 질문이 많았는데 꼬리 질문에 잘 대답하는 부분이 좋았습니다.   \n질문 답변이 간결해서 좋았습니다. 정확하게 질문에 대한 답변이 주어져서 좋았습니다.   \n\n인터뷰어의 페이스에 말리는 부분이 있어서 조금 아쉬웠습니다.   \n준비했던 말보다 페이스에 말린 질문을 많이 받은 것 같아서 안타까웠습니다.   \n\n\n## 여우\n\n### 질문\n\n- **in-out 설계와 out-in 설계 중에서 현재는 어떤 것을 선호하시나요? out-in 방식이 좋은 경우에는 어떤 때가 있을까요?**\n- 단위 테스트를 작성하는 자신만의 기준이 있으신가요?\n- **생성자 주입을 하지 않고 내부에서 값을 생성하는 경우가 좋았던 적이 있으신가요?**\n- getter는 어떤 경우에 사용해야 한다고 생각하시나요?\n- **서비스 레이어가 필요한 경우는 어떤 경우라고 생각하시나요? 현재 미션에서 서비스 레이어를 사용해야 하는 경우가 있으셨나요?**\n- 현재는 void 메서드를 테스트하시나요?\n- 현재는 예외 발생 이유를 구분해서 테스트하고 계신가요? 보완하는 방법으로는 어떤 방법이 있을까요?\n- **어느 정도까지 단위 테스트를 작성해야 한다고 생각하시나요?**\n- **블랙잭 미션에서 생성자 주입 이야기가 나왔는데, 현재는 고정적이지만 값이 변경되는 경우의 확장성을 고려해서 생성자 주입을 하는 것이 좋지 않을까요?**\n- 딜러와 참가자 객체 사이에 유의미한 차이가 없어지도록 어떻게 하셨는지 알려주실 수 있으실까요?\n- tdd의 필요성에 대해 어떻게 생각하시나요?\n- **static은 언제 사용하는 것이 좋을까요? 객체 인스턴스 생성과 static을 사용하는 여우만의 기준이 있을까요?**\n\n### 피드백\n\n눈을 마주치면서 말한 부분이 좋았습니다.    \n쉽게 풀어서 이야기 하는 부분이 좋았고, 어떤 경험으로부터 이런 생각을 하게 되었는지 말해주셔서 좋았습니다.    \n\n제 기준에서는 말이 조금 느렸던 것 같습니다.    \n질문에 대한 대답이 뒤쪽에 있어서 아쉬웠습니다.    "},{"excerpt":"함수형 인터페이스란? 함수형 인터페이스는 1개의 추상 메소드를 갖는 인터페이스를 말한다.\nSAM(Single Abstract Method) 인터페이스라고도 한다. default method, static method는 포함되어도 상관 없다. 함수형 인터페이스 생성하기 이렇게 추상 메서드를 하나만 갖도록 만들면 된다.  어노테이션은 없어도 되지만, 인터페이…","fields":{"slug":"/functional-interface/"},"frontmatter":{"date":"2023년 03월 28일 00:03","title":"함수형 인터페이스는 무엇이고, 람다와 어떤 관계가 있나요?","tags":["우테코","레벨1","학습로그"]},"rawMarkdownBody":"\n## 함수형 인터페이스란?\n\n함수형 인터페이스는 1개의 추상 메소드를 갖는 인터페이스를 말한다.\nSAM(Single Abstract Method) 인터페이스라고도 한다.\n\ndefault method, static method는 포함되어도 상관 없다.\n\n### 함수형 인터페이스 생성하기\n\n```java\n@FunctionalInterface\npublic interface Calculator {\n\tint sum(int x, int y);\n\tpublic default void defaultMethod();\n\tpublic static void staticMethod();\n}\n```\n\n이렇게 추상 메서드를 하나만 갖도록 만들면 된다.\n\n`@FunctionalInterface` 어노테이션은 없어도 되지만, 인터페이스 검증과 유지보수를 위해 붙여주는 게 좋다. 어노테이션을 사용하면 해당 인터페이스가 1개의 함수만을 갖도록 제한하게 된다. 여러 개의 함수를 선언하면 컴파일 에러가 발생한다.\n\n## 함수형 인터페이스와 람다의 관계\n\n### 람다란?\n\n함수를 하나의 식으로 표현한 것이다. 메소드의 이름이 필요 없어 익명 함수의 한 종류로 볼 수 있다.\n\n```java\npublic void printHello() {\n\tSystem.out.println(\"Hello\");\n}\n```\n\n위의 함수를 람다식으로 변환하면 다음과 같다. \n\n```java\n() -> System.out.println(\"Hello\");\n```\n\n함수형 인터페이스의 인스턴스를 만드는 방법으로 사용될 수 있고, 코드를 줄일 수 있다.\n\n### 함수형 인터페이스 구현\n\n함수형 인터페이스를 구현하는 방법에는 클래스를 이용하는 방법과 람다를 이용한 방법이 있다.\n\n인터페이스는 구현 클래스를 만들고 만든 클래스의 인스턴스를 생성해서 사용하는 과정을 거칠 수 있다.\n\n```java\nclass NormalCalculator implements Calculator {\n\t@Override\n\tint sum(int x, int y) {\n\t\treturn x + y;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tNormalCalculator normal = new NormalCalculator();\n\t\tint value = normal.sum(2, 3);\n\t}\n}\n```\n\n다만 이 방법은 구현 클래스가 한 번만 사용되고, 다른 곳에서는 사용되지 않는 경우 클래스 파일이 계속해서 생성되는 문제가 있다.\n\n클래스를 생성하지 않고 익명 클래스를 생성하여 구현하는 방법도 있다.\n\n```java\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tCalculator anonymousCalculator = new Calculator() {\n\t\t\t@Override\n\t\t\tint sum(int x, int y) {\n\t\t\t\treturn x + y;\n\t\t\t}\n\t\t};\n\t\tint value = anonymousCalculator.sum(2, 3);\n\t}\n}\n```\n\n익명 클래스를 생성하면 클래스를 명시적으로 정의하지 않고 바로 구현체를 정의할 수 있다. 클래스 선언 비용을 줄이고 코드 간결화를 위해 익명 클래스를 사용한다.\n\n### 람다를 사용한 함수형 인터페이스 선언\n\n람다를 사용하면 더욱 간결하게 선언할 수 있다.\n\n인터페이스에 추상 메서드가 하나이므로 인터페이스 구현 자체가 하나의 메서드 구현만을 의미한다. 즉, 함수와 같은 개념으로 이해할 수 있다. \n따라서 람다 표현식을 이용하여 함수를 구현할 수 있다.\n\n```java\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tCalculator lambdaCalculator = (x, y) -> x + y;\n\t\tint value = lambdaCalculator.sum(2, 3);\n\t}\n}\n```\n\n위의 코드들과 비교했을 때 코드의 직관성과 코드 길이가 차이가 나는 것을 볼 수 있다.\n람다식은 담길 변수의 타입에 해당하는 인터페이스를 사용하도록 만들어졌다.\n해당 인터페이스의 매개변수와 리턴타입만 맞춰주면 나머지는 알아서 처리한다.\n\n## 함수형 인터페이스를 사용하는 이유\n\n행위(함수)도 하나의 값으로 취급하기 위함이다. \n함수를 하나의 값으로 취급해서, 함수들을 조립하고 배치하면서 개발하기 위해 함수형 인터페이스를 사용한다.\n\n1. 동시성 side effect를 없앨 수 있다 : 기능을 하는 함수를 이용해 Side-effect가 없도록 선언형으로 개발한다.\n2. 구조적으로 유연하고 간결해진다 : 코드 재사용 단위가 클래스였던 것이 함수 단위로 가능하게 해주어 유연한 개발이 가능하다. 클래스 사이의 복잡한 연계를 줄일 수 있어 구조적으로 간결해진다.\n\n### 이번 주 스터디 피드백\n\n<베로오>\n이해가 잘 됐다. cooool 하다.\n기본 제공하는 함수형 인터페이스를 왜 패키지로 제공하는지에 대한 내용도 있었으면 좋았겠다.\n\n<헤에나>\n화면을 좀 자주 왔다갔다 해서 집중이 잘 안 됐다.\n추상 클래스 쪽 예시가 맞는 예시였는지 모르겠다. (베로 생각)\n페이지에 숫자라도 있었으면 좋았겠다.\n\n<훛추>\n예외의 발생 비용이 뭘까? -> 예외가 발생하면 어디서부터 발생했는지 찾는 스택 추적 비용이 발생하는데 비용이 크다.\n\n꼼꼼한 사용 방법 좋았다.\n메서드 구현체 내부 보여준 거 좋았다.\n예시가 있었다면 어땠을까?\n\n<포오이>\n굉장히 꼼꼼하게 준비했다. 굉꼼. 잘 보았다. 고생했다.\n내용이 알차다."},{"excerpt":"LOG 체스 미션 PR을 보냈다. 배운 것 궁금한 것 어려웠던 것 느낀 것","fields":{"slug":"/2023-03-27/"},"frontmatter":{"date":"2023년 03월 27일 11:03","title":"2023년 03월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 체스 미션 PR을 보냈다.\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"LOG 잠실캠 와서 공부했다. 잠실 오려고 아침으로 과외 옮겼다. 일요일에 잠실을 가니까 그냥 기분은 좋았다. 요즘은 집에만 있으면 재미가 없어서 잠실 오고 싶긴 하다. 방학 때는 잘 지낼 수 있을까? 아침 과외를 하게 된 후폭풍으로 좀 피곤했다. 컨디션이 좋지는 않았다. 어제도 기절하듯이 잠들어서 오늘은 제대로 잘 자고 싶다. 사실 지금도 좀 졸리다. …","fields":{"slug":"/2023-03-26/"},"frontmatter":{"date":"2023년 03월 26일 15:03","title":"2023년 03월 26일","tags":null},"rawMarkdownBody":"## LOG\n- 잠실캠 와서 공부했다. 잠실 오려고 아침으로 과외 옮겼다. 일요일에 잠실을 가니까 그냥 기분은 좋았다. 요즘은 집에만 있으면 재미가 없어서 잠실 오고 싶긴 하다. 방학 때는 잘 지낼 수 있을까?\n- 아침 과외를 하게 된 후폭풍으로 좀 피곤했다. 컨디션이 좋지는 않았다. 어제도 기절하듯이 잠들어서 오늘은 제대로 잘 자고 싶다. 사실 지금도 좀 졸리다.\n\n## 배운 것\n- DB connection을 사용할 때 재귀는 쓰지 말자.\n\n## 궁금한 것\n- DAO 로직은 어디까지 가도 될까... 😂\n- 상태 패턴의 다양한 상태들 중에 어떤 상태만 필드를 가지고 있는 경우, 해당 클래스는 테스트를 어떻게하면 잘할 수 있을까?\n\n## 어려웠던 것\n- 컨디션 관리\n- 미루지 않는 습관\n\n## 느낀 것\n- 여러 가지 일들이 있었다. 아침부터 이것저것 일이 많았는데, 어떻게 잘 끝난 것 같기도 하고 아닌 것 같기도 하다. 어떤 부분에서는 좋을 수도 있고, 아닐 수도 있다. 지금 상황은 나중에 다시 확인해봐야 좋은지 아닌지 판단할 수 있을 거 같다.\n- 집안일을 많이 못했다. 결국 남은 건 내일의 내가 하게 됐다. 잘 부탁해~\n- 곧 레벨1이 끝난다. 내가 원하던 것을 많이 이뤘는지 궁금하다. 나는 잘 하고 있었을까? 분명 다른 사람이 된 것은 맞다. 그것만으로도 내가 많이 성장했다고 느낀다. 그럼에도 아직 나아지지 않은 부분들은 있다고 생각한다. 그것도 미래의 나에게 부탁해야겠다. 잘 부탁해~\n"},{"excerpt":"LOG 새싹교실했다. 한 분은 나보다 나이가 많았다. 편입생 두 분이랑 새내기 한 명이라 좀 머쓱한 조합이었다 ㅋㅋ 이번 새싹교실은 질문을 좀 많이 받고 싶어서 질문 많이 해달라고 자료에도 써놨다. 과연 질문을 많이 할 수 있게 될 지..? 그치만 나도 배울 때는 어떤 걸 질문해야 할 지 몰라서 그냥 없다고 말했던 적이 있다. 그렇다보니 질문이 쉬운 환경…","fields":{"slug":"/2023-03-25/"},"frontmatter":{"date":"2023년 03월 25일 14:03","title":"2023년 03월 25일","tags":null},"rawMarkdownBody":"## LOG\n- 새싹교실했다. 한 분은 나보다 나이가 많았다. 편입생 두 분이랑 새내기 한 명이라 좀 머쓱한 조합이었다 ㅋㅋ 이번 새싹교실은 질문을 좀 많이 받고 싶어서 질문 많이 해달라고 자료에도 써놨다. 과연 질문을 많이 할 수 있게 될 지..? 그치만 나도 배울 때는 어떤 걸 질문해야 할 지 몰라서 그냥 없다고 말했던 적이 있다. 그렇다보니 질문이 쉬운 환경은 아니긴 하지. 앞으로 수업할 때 열심히 해보려고 한다. 내가 시간을 얼마나 많이 낼 수 있을지는 모르겠지만...\n- 여유가 좀 있어서 바닥 청소를 좀 했다. 곧 방 점검이 있어서 깨끗하게 치워둬야 한다. 그렇지만 귀찮다... 할 것도 많고.. 할 게 많을 때 가장 뒤로 미뤄지는 게 청소인 거 같다. 오늘 집안일을 많이 해치워버릴 생각이었는데 생각보다 많이 못했다. 내일은 어떻게든 다 치워야 한다. 파이팅..!이라고 생각했는데 내일 잠실 가기로 해서 큰일났는데?\n- 과외를 10시-12시로 바꿨다. 원래 1시라서 좀 더 잤는데 주말에 잠실 가고 싶어서 앞으로 시간을 조정했다. 집에만 있다보니 별로 공부가 잘 되는 거 같지 않다.\n- 성하의 글쓰기 리뷰를 안 했다는 사실을 알게 되었다...! 너무 죄송해서 얼른 발견하자마자 달았다 ㅠ 글쓰기 리뷰는 다 한 줄 알고 확인도 안 했는데 확인하길 잘했다.\n- 점심을 먹었다고 방심했더니 저녁을 안 먹었다 ㅋㅋ 그냥 이럴거면 잠실캠 가서 밖에서 사먹는 게 나을 듯.\n\n## 배운 것\n- c++의 ```empty vector```에서 ```back()```을 호출하면 에러가 발생한다.\n- ```markdown```에 코드 블럭에 sql을 사용할 수 있다.\n\n## 궁금한 것\n- 간결합되어 있는 객체 사이에서의 양방향 의존은 괜찮은가?\n- 클래스 이름으로 데이터를 저장하는 것은 별로 좋지 않은 방법일까?\n\n## 어려웠던 것\n- 그냥 오늘은 좀 어려웠다.\n\n## 느낀 것\n- 생각이 정리가 안 된다. 뭐가 맞는걸까? 아직 생각의 양이 부족하다. 앞으로 어떻게 하고 싶은지도 아직 못 정했다. 내가 어떻게 생각하고 있는지도 잘 모르겠다. 확신이 없어서 그렇다. 내 상태는 잘 알고 있으면서도 왜 망설이는지? 알 수 없다. 나도 내가 뭘 하고 싶은 건지 알고 싶다.\n- 목표가 없다. 목표를 정하고 나아가는 사람들이 멋지다고 생각한다. 나는 뭘 하고 싶은걸까? 우테코에 와서 내가 이루고 싶은 건 뭘까? 결국 내가 뭘 하기 위해서 지금 이러고 있을까? 지금 생각해보면 나한테 중요한 게 없다. 그냥 행복하고 싶다. 그런데 행복이 장기적인 목표라고 하기에는 이룰 수 없는 것이다. 단기적으로만 존재할 수 있으니까. 그렇다고 대충 살 수 있느냐 하면 그것도 아니다. 일단은 열심히 하는 걸 좋아한다. 대충 사는 것보단 그게 나으니까. 열심히 하다보면 행복해질 수 있을 거라 생각했다. 가끔은 그렇다. 그렇지만 매일 그렇지는 않다. 오늘 저녁에도 생각한다. 나는 왜 열심히 할까? 내가 이루고 싶은 건 뭘까? 내가 하고 싶은 건 뭘까? 내가 대충 살면 안 되는 이유가 있을까? 그래서 아직 사는 이유가 없다. 미련도 딱히 없다. 아직 못 찾았다. 올해는 찾을 수 있을까?\n"},{"excerpt":"LOG 말랑과 말을 놓았다. 말랑이 실수해서 말을 놨는데 ㅋㅋㅋ 나는 말 놓는 거 좋아서 놓자고 했다. 저녁에 3단계 구현하는 거 말랑이 도와줬다. 말랑도 4단계 전까지는 상태 패턴 썼다고 해서 도움을 많이 받았다. THANK YOU, MALLANG 주노, 글렌, 포이와 깊은 대화(?)를 했다. 주노가 나랑 정말 비슷한 생각을 가지고 있어서 신기했다. 주…","fields":{"slug":"/2023-03-24/"},"frontmatter":{"date":"2023년 03월 24일 03:03","title":"2023년 03월 24일","tags":null},"rawMarkdownBody":"## LOG\n- 말랑과 말을 놓았다. 말랑이 실수해서 말을 놨는데 ㅋㅋㅋ 나는 말 놓는 거 좋아서 놓자고 했다. 저녁에 3단계 구현하는 거 말랑이 도와줬다. 말랑도 4단계 전까지는 상태 패턴 썼다고 해서 도움을 많이 받았다. THANK YOU, MALLANG\n- 주노, 글렌, 포이와 깊은 대화(?)를 했다. 주노가 나랑 정말 비슷한 생각을 가지고 있어서 신기했다. 주변 사람들을 정말 잘 챙기는 것 같아서 본받고 싶어졌다.\n- 헤나, 후추, 포이와 스터디했다. 뭔가 웃길까봐 걱정했는데 다행히 진지한 분위기를 유지할 수 있었다. 다들 대답도 잘하고 공부 많이 했다는 느낌이 들었다. 나도 이제 거기서 공부했던 내용에 대해서는 잘 말할 수 있을 거 같다!\n- 데일리 미팅 때 칭찬당했다. 이상한 말들도 많았지만 ㅋㅋㅋ 내 칭찬도 좋지만 주변 사람들 칭찬을 공식적으로 할 수 있어서 좋았다. 칭찬 안 좋아하는 사람은 없으니까~\n- 기숙사에 못 들어갈 뻔했다 ㅋㅋㅋ 내가 시간을 잘못 알고 있었어서 바깥 벤치에서 잘 뻔했다. 어떤 착한 분이 문을 열어주셔서 다행히 방에서 잘 수 있었다 ㅋㅋ 이제라도 알았으니 다행이야~\n- 브라운과 상담했다. 내 또래가 아닌 다른 입장에서 의견을 들으니 또 느낌이 달랐다. 다 비슷한 결론을 내주시긴 했지만 갈수록 확신이 드는 느낌이었다. 그래도 아직 완벽하게 생각 정리가 되지는 않았다. 좀 더 생각할 시간이 필요하다.\n\n## 배운 것\n\n## 궁금한 것\n- 테스트: stub, fake\n- Solitary Unit Test, Sociable Unit Test -> [단위 테스트](https://algopoolja.tistory.com/119)\n\n## 어려웠던 것\n- 이번 주는 새로운 사람들과 많이 말하지 못했다.\n\n## 느낀 것\n- 내가 힘든데 힘들다고 생각을 못하는 건가, 힘들지 않아서 힘든 생각이 안 드는 건지 문득 의문이 들었다. 지금 생각으로는 안 힘든게 맞는 거 같다. 힘든 것과 스트레스 받는게 같은건가? 힘들다고 생각은 안 든다. 몸은 좀 힘들다. 아직도 잠이 부족하다. 더 자고 싶다.. 😂\n- 이런 생각을 한다는 건 상황이 많이 나아져서 그렇다. 작년까지만 해도 이런 생각 자체를 할 수가 없는 상태였다. 진짜 심신미약이었다. 내가 많이 여유가 생겨서 그런가 보다. 그때는 그냥 일어나서 과제하는 것 자체가 힘들었는데 지금은 그렇지 않으니까 말이다. 자괴감과 자기 비하에서 어느정도 빠져나온 것 같아 기분이 좋다.\n\n"},{"excerpt":"3/24 면접 동등성과 동일성 동일성과 동등성의 차이는 무엇인가요?: 후추 꼬리질문- 해쉬값의 무결성이란? hashcode를 제대로 정의했다면 equals에서 문제가 발생하지 않는다는 뜻인가? : 후추 == 연산자와 equals 연산자는 어떤 차이가 있는가? 각 인스턴스가 본질적으로 고유한 경우에도  를 재정의하는 것이 좋을까요?: 헤나 enum 같은 경…","fields":{"slug":"/vepohuhemal-study-question/"},"frontmatter":{"date":"2023년 03월 24일 01:03","title":"베포후헤말 스터디 면접 질문 준비","tags":["스터디","우테코"]},"rawMarkdownBody":"\n# 3/24 면접\n\n## 동등성과 동일성\n\n- **동일성과 동등성의 차이는 무엇인가요?: 후추**\n- **꼬리질문- 해쉬값의 무결성이란? hashcode를 제대로 정의했다면 equals에서 문제가 발생하지 않는다는 뜻인가? : 후추**\n- == 연산자와 equals 연산자는 어떤 차이가 있는가?\n- **각 인스턴스가 본질적으로 고유한 경우에도 `equals` 를 재정의하는 것이 좋을까요?: 헤나**\n- **enum 같은 경우에는 `equals`를 정의하지 않나요?: 헤나**\n- 언제 `equals` 를 재정의하지 않아도 되나요?\n- 언제 재정의하면 안 되나요?\n- **`equals`를 사용자 정의한다고 했을 때, `equals` 메서드에 들어가야 할 구현은 뭐가 있을까요?: 포이**\n\n## 불변 클래스\n\n- **프로그래밍 할 때 모든 클래스는 불변 클래스로 만드는 쪽으로 설계하는 것이 좋다고 생각하시나요?: 헤나**\n- 불변성이 뭔가요?\n- **불변 객체도 리플렉션을 사용해서 불변성을 깰 수 있는데 그래도 불변 객체가 맞을까요?: 헤나**\n- **클래스 확장을 막는 경우 어떤 장단점이 있나요?: 후추**\n- 불변 클래스를 왜 써야 하나요?\n- **불변 클래스의 내부에 리스트 필드를 갖는 클래스는 불변 클래스가 될 수 있을까요? 어떻게 불변 클래스로 만들 수 있을까요?: 포이**\n\n## 접근 제어자\n\n- **`private`의 접근 범위는 어디까지일까요?: 헤나**\n- `protected`, `package-private` 이 어떻게 구분되어 사용되면 좋을까요?\n- **하위 클래스가 같은 패키지에 있을 때에도 `package-private`이 아닌 `protected` 를 쓸 필요가 있다고 생각하시나요?: 포이**\n- **생성자를 `private`으로 만들 때 예외를 던지시는 편인가요?: 후추**\n\n## 디폴트 메서드\n\n- **디폴트 메서드는 어떨 때 사용하면 좋나요?: 후추** -> 기존의 인터페이스를 수정할 일이 있을 때 사용하면 좋다. 기존에 있던 코드를 재사용할 때\n- 추상 클래스의 구현 메서드와 인터페이스의 디폴트 메서드는 어떤 점이 다른가요?\n- **디폴트 메서드의 단점은 어떤 것이 있을까요?: 헤나**  -> 남용할 가능성이 높다.\n- 디폴트 메서드를 사용하지 않는 다른 언어에서는 어떻게 해결하고 있나요? -> \n- 디폴트 메서드 사용하기 이전에는 어떤 식으로 문제를 해결했을까요?\n- 디폴트 메서드를 사용해서 실제로 발생했던 문제는 어떤 것이 있나요?\n- **거의 대부분이 같은 기능을 하고, 일부만 다른 기능을 구현할 때 `abstract`를 쓰는 것이 좋나요, 아니면 디폴트 메서드를 쓰는 게 좋나요?: 포이** -> abstract가 더 낫다. 오버라이딩에 경고가 뜨지 않는다. 하위 클래스가 이렇게 구현했다고 알 수 없기 때문에.\n\n## 피드백\n\n### 헤나\n\n- 칭찬: 쫄지 않고 잘 말했다. 대답할 때 적절한 시선 처리.\n- 성장점: 모르면 모른다고 말하자. 질문이 이해가 안 된다면 다시 물어보자. 답변에 대한 이유가 있는 게 좋을 거 같다.\n\n### 후추\n\n- 자세가 좋았다. 대답할 때 질문한 사람을 쳐다보는 게 좋았다. 겁없이 안정적인 느낌.\n- 질문이 이해가 안 된다면 다시 물어보자.\n\n### 베로\n\n- 빠르게 동의하는 게 좋았다. 이전 의견에 대한 근거 말해준 것도 좋았다. 리액션이 좋았다. 대답의 당참. 질문 이해가 안 간다고 말한 것. 자세, 말하는 톤, 행동 좋았다.\n- 성장점: 기술에 대한 부적절한 대답. 어떤 의견을 물어볼 땐 트레이드오프를 말해주는 게 좋을 거 같다.\n\n### 포이\n\n- 모르면 모른다고 말했음. 이해 안 됐을 때 말한 거, 차분하게 생각해 달라고 말한 거 좋았다. \n- 트레이드 오프 말하기. 근거는 뭔지 말하면 좋을 거 같다. 답변에 대한 이유가 있는 게 좋을 거 같다.\n\n# 4/7 면접\n\n## 면접 정리\n\n### 리소스 자동 반납\n\n- 예외가 `try`, `finally` 모두에서 발생할 수 있기 때문에 `finally` 로 자원 회수 코드를 명시해줘도 문제가 발생할 수 있다.\n- 예외가 두 곳에서 발생하는 경우 두 번째로 발생한 예외가 첫 번째 예외를 삼키게 되어 디버깅이 어려워진다.\n\n#### 추가로 알게 된 내용\n- Garbage Collector는 메모리 용량에 따라 소멸 여부를 결정한다. 데이터 제거 순서는 무작위이다.\n\n#### finalize() 는 언제 쓸까?\n- 명시적 종료 메서드 패턴에서 호출되지 않을 것을 대비하기 위한 방어 역할을 위해 `finalize()` 를 재정의한다.\n\t- `FileInputStream` 에서 명시적으로 종료 메서드를 호출하지 않았을 경우를 대비해 `finalize()` 메서드에 메모리 해제를 하도록 재정의되어 있다.\n- 네이티브 피어 리소스(다른 언어로 작성된 프로그램을 자바에서 다루기 위해 만들어 놓은 객체)를 해제할 때 사용한다. 일반 객체가 아니어서 GC가 관리하지 않기 때문이다.\n- [참고 자료](https://camel-context.tistory.com/43)\n\n### Optional\n- [참고자료](https://mangkyu.tistory.com/70)\n\n## Enum\n\n- **enum을 사용해서 singleton을 만들라는 말이 있는데, 그렇게 하면 어떤 이점이 있을까요?** : 헤나\n- enum을 사용해야 하는 이유가 있을까요?\n- **enum을 언제 사용하셨나요? 어떨 때 enum을 사용해야 한다는 기준이 있으신가요?** : 포이\n- **enum 대신 클래스를 사용하는 것이 좋은 경우는 언제인가요?** : 포이\n- enum의 컴파일 타임 안전성에 대해 알고 계시나요?\n- **enum의 ordinal 메서드를 사용해보신 적 있나요? ordinal 메서드를 사용하는 것에 대해 어떻게 생각하시나요?** : 후추\n- **ordinal 메서드는 왜 만들어졌을까요?** : 후추\n- **enum의 `name()`, `toString()` 은 어떻게 나눠서 써야할까요?** : 헤나\n- **enum의 `toString()` 을 사용자 필요에 의해 재정의하는 것에 대해 어떻게 생각하시나요?** : 헤나\n- **enum의 단점은 뭐가 있을까요?** : 헤나, 후추\n- **enum의 생성자가 private 인데, 그 이유가 뭐라고 생각하시나요?** : 후추\n\n## 함수형 인터페이스\n\n### 기본 질문\n- 함수형 인터페이스의 동시성 이슈를 없앨 수 있다는 것이 무슨 의미인가요?\n- 함수형 인터페이스의 종류에는 어떤 것이 있나요?\n- Object 객체의 메서드만 인터페이스에 선언되어 있는 경우에는 함수형 인터페이스가 맞을까요?\n- **자바의 표준 함수형 인터페이스 중에 써 본 거 말해주세요.** : 헤나\n- **람다란 무엇인가요?** : 후추\n\n### 의견 질문\n- **함수형 인터페이스에서 static method, default method를 사용하는 게 적절하다고 생각하시나요?** : 헤나\n- **익명 클래스를 썼을 때보다, 람다를 이용한 방법의 장점이 어떤 것이 있다고 생각하시나요?** : 포이\n- **클래스를 선언하는 것은 문서화 과정 중의 하나라고 생각하는데, 람다식을 쓰는 것보다 클래스를 선언하는 게 낫지 않을까요?** : 후추\n- **함수형 인터페이스 구현 시에 익명 클래스를 쓰는 것이 더 좋은 경우가 있나요?**: 포이\n- 불필요한 함수형 인터페이스를 만들지 말고 표준 함수형 인터페이스를 사용하라는 말이 있는데 왜라고 생각하시나요?\n- **함수형 인터페이스를 쓰면서 좋았던 점이 있나요?** : 헤나\n\n## try-with-resources\n\n### 기본 질문\n- try-with-resources가 garbage collector가 관리하는 방식보다 나은 점이 무엇인가요?\n- **`try/catch/finally` 문에서 메모리 누수가 일어날 가능성이 있는 이유는 무엇인가요?** : 헤나\n- `finalize()` 함수는 어디에 정의되어 있는 함수인가요?\n- **garbage collector의 수집 대상이 되는 객체는 어떤 객체인가요?** : 포이\n- `finalize()` 함수의 단점은 무엇인가요?\n- 그럼 `finalize()` 함수는 언제 사용해야 하나요?\n- **try-with-resources의 장점은 무엇인가요?** : 후추\n- **garbage collector가 자원을 해제해 줄 것인데 왜 자원 해제를 해줘야 할까요?** : 후추\n\n### 의견 질문\n- **자바에서 개발자가 garbage collector 한테 지금 당장 객체를 파괴하도록 강제할 수 없게 만든 이유가 뭐라고 생각하시나요?** : 후추\n\n## Optional\n\n### 기본 질문\n- **Java에서 Optional이 왜 등장했다고 생각하시나요?** : 후추\n- Optional의 `ofNullable()`, `of()` 의 차이점은 무엇인가요?\n- **Optional의 `orElse()` 와 `orElseGet()` 의 차이점은 무엇인가요?** : 베로\n- Optional은 어떻게 사용했을 때 가장 좋을까요?\n- **Optional을 반환타입으로만 사용해야 하는 이유가 뭘까요?** : 헤나\n\n### 의견 질문\n- null을 반환하는 것의 단점은 무엇일까요?\n- **`orElse()` 는 언제 써야 할까요?** : 후추\n- Optional을 사용하신 적이 있나요? 어떤 경우에 사용하셨었나요? 언제 사용하면 좋을까요?\n- Optional을 사용할 때 단점이 있을까요?\n- **Optional이 아닌 null을 반환해야하는 경우도 있을까요?** : 포이\n- **필드의 일부 혹은 전체가 null일 수 있는 상황에서도 Optional을 필드로 사용해서는 안 될까요?** : 헤나\n- **Optional은 언제 사용하는 것이 좋을까요?** : 헤나\n- 반환 인자가 generic으로 선언되어 있을 때, 함수형 인터페이스가 들어갈 수 있을까요?\n\n## 피드백\n\n### 헤나\n- 좋은 점: 아는 부분에 대해 예시를 들어가면서 자세하게 답변하는 모습이 좋았다. 단점 말할 때 장점도 같이 말해주는 게 좋았다. 질문을 제대로 이해했는지 다시 물어보는 부분이 좋았다.\n- 성장점: 답변하는 문장의 호흡이 길다. 문장을 마무리하는 부분을 고치면 좋을 것 같다.\n\n### 후추\n- 좋은 점: 굉장히 차분하게 잘 말한다. 잘 모르는 부분도 잘 말해서 대단하다. 어... 같은 말을 안 써서 말을 듣기 편하다. 빠른 인정 좋다. 어떻게 방금 본 내용을 그렇게 잘 말할까. 목소리 톤이 안정적이다. (감기임) \n- 성장점: \n\n### 베로\n- 좋은 점: 생각하는 부분, 아는 부분에 대해서는 잘 말했다. 질문을 잘 알아들어서 좋았다.\n- 성장점: 생각할 때 음, 어라는 말이 많았다. 답변이 길어지니 질문에서 벗어난 답변을 하는 것 같다.\n\n### 포이\n- 좋은 점: 자신감 있게 말하는 부분이 좋았다. 예시를 요구하는 부분 좋았다. GC 설명하는 거 잘했다.\n- 성장점: 짧은 답변이 많아서 좀 더 자세하게 말해줬으면 좋겠다. 덧붙여서 말해주는 게 있으면 좋겠다. \n\n# 4/20 면접\n\n## JDBC\n\nSQLException은 catch 블록으로 반드시 처리해야 하는 checked 예외이다.\n대부분의 데이터베이스 연결 생성 실패나, 작성 오류가 있는 쿼리같은 오류들은 대부분 catch로 해결할 수 없어서 상위 코드로 예외 처리를 넘겨야 한다.\n\n명령문이나 데이터베이스 연결 객체를 생성하는 코드, 객체들을 cleanup 하는 코드가 없어서 가독성이 좋다. 비즈니스 로직에 좀 더 집중할 수 있다.\n\n## GRASP\n\n- **GRASP 원칙 중에서 가장 중요하게 지켜져야 하는 규칙은 무엇이라고 생각하시나요? 그 이유는?** : 후추\n- **결합도가 극단적으로 낮으면 항상 좋은 걸까요?** : 후추\n- **낮은 결합도를 위해서는 어떠한 것들을 할 수 있을까요?** : 후추\n- **응집도가 극단적으로 높은 것은 언제나 좋은 것일까요?** : 말랑 \n- **왜 응집도를 높이면 결합도가 높아질까요?** : 말랑\n- **Pure Fabrication(순수 조립)의 단점은 어떤 것이 있나요?** : 말랑\n- (정보 전문가 패턴) **책임을 할당할 객체를 정할 때 주로 어떻게 정하는 편이신가요?** : 포이\n- 결합도가 높을 때의 장점은 없을까요? / 응집도가 낮을 때의 장점은 없을까요?\n- **클래스 분리는 어떤 기준으로 하시나요?** : 포이 / 클래스 분리는 어떤 때에 수행되어야 할까요?\n- **간접 참조를 사용하게 되면 중간 객체가 생겨 오히려 복잡한 설계가 되지 않을까요? 어떤 때에 간접 참조를 사용하면 좋을까요?** : 포이\n\n## GRASP\n\n- GRASP 원칙 중에서 가장 중요하게 지켜져야 하는 규칙은 무엇이라고 생각하시나요? 그 이유는? : 후추\n- 결합도가 극단적으로 낮으면 항상 좋은 걸까요? : 후추\n- 낮은 결합도를 위해서는 어떠한 것들을 할 수 있을까요? : 후추\n- 응집도가 극단적으로 높은 것은 언제나 좋은 것일까요? : 말랑 \n- 왜 응집도를 높이면 결합도가 높아질까요? : 말랑\n- Pure Fabrication(순수 조립)의 단점은 어떤 것이 있나요? : 말랑\n- (정보 전문가 패턴) 책임을 할당할 객체를 정할 때 주로 어떻게 정하는 편이신가요? : 포이\n\n## ArgumentResolver\n\n- ArgumentResolver 는 무엇인가요?\n- ArgumentResolver는 언제 호출이 될까요?\n- 인자가 전달되면 메서드에서 어떤 과정이 진행되는지 말해주세요\n- ArgumentResolver를 사용한 적이 있으신가요?\n- 왜 인터셉터에서 파라미터가 있는지 없는지 확인해야 할까요?\n- ArgumentResolver에서 Jwt를 변환해줄 수 있는데, 다른 위치에서 변환을 해보신 적도 있나요?\n\n## DI, Spring의 의존성 주입 방식\n\n- 양방향 의존 관계에 대해서는 어떻게 생각하시나요? : 헤나\n- 양방향 의존이 필요한 경우가 있을 수 있다고 하셨는데, 어떤 경우에 양방향 의존이 필요할까요? : 헤나\n- 의존 관계에 대해 설명해주세요 : 헤나\n- Spring한테 의존성 주입을 맡기는 것에 대한 이점이 있을까요? - scope를 자유자재로 바꿀 수 있다. 설정해야 하는 코드가 사라진다.\n\n## JDBC\n\n- 자바에서 데이터베이스에 접근하는 코드를 작성할 때 필요한 객체가 어떤 게 있었나요?: 헤나\n- 사용자가 JdbcTemplate을 사용할 때 정의해야 하는 일이 무엇이 있을까요? : 헤나\n\n# 4/28 면접\n\n## Auto-Configuration\n\n추가된 jar 의존성을 바탕으로 Spring 애플리케이션을 자동으로 구성한다. Auto-configuration은 custom configuration으로 대체될 수 있다.\n\nauto-configuration을 구현하는 클래스에 `@AutoConfiguration` 어노테이션을 달아야 한다.\n\n일반적으로 auto-configuration 클래스는 `@ConditionalOnClass` 나 `@ConditionalOnMissingBean` 어노테이션을 사용한다.\n\nSpring Boot는 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일이 있는지 확인한다. 해당 파일은 configuration 클래스가 한 줄에 하나의 클래스 이름으로 나열되어 있어야 한다.\n\nconfiguration을 특정 순서로 사용해야 하는 경우, `@AutoConfiguration` 어노테이션 또는 `@AutoConfigureBefore`, `@AutoConfigureAfter` 어노테이션을 사용할 수 있다.\n\nuser configuration, condition evaluation 등 다양한 요소의 영향을 받을 수 있다.\n\n## 질문\n\n- `AutoConfiguration` 을 사용해보신적 있으신가요?\n- `AutoConfiguration` 이 무엇인가요?\n- `WebMvcTest` 가 꼭 필요하다고 생각하시나요? : 포이\n- 기본 에러 페이지에서 url만 알면 마음대로 error 페이지에 접근할 수 있다는 단점이 있다고 하셨는데, 왜 이게 단점이라고 생각하시나요? : 포이\n- 커스텀 예외를 사용하시나요? 사용하신다면 왜 사용하시는지 궁금합니다.\n- WebMvcTest의 `excludeFilters` 에 대해 설명해주세요.\n- `@Order` 어노테이션을 사용하는 것에 대해 어떻게 생각하시나요?\n- `@ControllerAdvice` 에서 json을 리턴하는 것에 대해 어떻게 생각하시나요? : 포이\n- `@ControllerAdvice` 에서 커스텀 예외를 지정할 수도 있고, validation 어노테이션의 message를 사용하는 방법도 있는데 어떤 방법이 더 낫다고 생각하시나요? : 헤나\n- `HandlerAdapter` 의 매개변수가 왜 `HandlerMethod`가 아니라 `Object` 일까요? -> 컨트롤러로 요청을 넘겨주기 전에 처리해야 하는 인터셉터 등을 포함하기 위해서 : 헤나\n- `DispatcherServlet`이 맡는 공통 작업은 무엇인가요? : 헤나\n- `WebMvcTest` 가 `SpringBootTest` 와 비교했을 때 어떤 부분이 다른가요?\n- 통합 테스트가 어려운 상황에는 어떤 것이 있을까요? : 헤나\n- controller 테스트가 필요하다고 생각하시나요? : 말랑\n- controller 테스트에서 체크해야 하는 건 뭐가 있을까요? : 말랑\n- qualifier 랑 primary 어노테이션의 우선순위가 뭘까요? : 말랑\n- DispatcherServlet이 있을 때와 없을 때의 차이에 대해 말해주세요. : 말랑\n- DispatcherServlet에서 어떤 과정을 거쳐서 적절하게 요청을 처리하는지 설명해주세요. : 포이\n- `HandlerExecutionChain` 을 직접 실행하지 않고, `HandlerAdapter` 를 통해 실행하는 이유가 무엇일까요? -> 컨트롤러는 다양하게 구현되어 있으므로, 구현 방식에 상관 없이 요청을 위임하도록 어댑터 패턴을 사용한다. : 헤나\n- DispatcherServlet을 한 문장으로 설명해주세요. : 헤나\n\n## 알려주고 싶은 내용\n\n- DispatcherServlet의 patch 메서드 처리만 다르다. doPatch만 없음.\n\n# 5/15 면접\n\n## 쿠키와 세션, 토큰을 이용한 인증\n- 인증: 유저가 서비스에 등록된 유저인지 확인하는 것\n- 인가: 유저가 해당 요청에 대한 권한을 갖는지 확인하는 것\n\n### HTTP의 Connectionless\n클라이언트와 서버가 요청과 응답을 한 번 주고받으면 연결을 끊어버리기 때문에 항상 새로운 연결을 맺어야 한다. 이런 요청들에 대한 정보의 상태는 저장하지 않는다. \n따라서 여러 서버가 존재하는 환경에서 클라이언트 요청에 대해 어떤 서버가 응답하더라도 상관 없다. \n이런 경우 인증 정보도 유지되지 않아 계속해서 인증 정보를 보내야 한다는 문제가 있다. \n\n### 쿠키\nkey-value 형태로 저장되는 작은 데이터. 웹 서버에 요청할 때 헤더에 쿠키를 담아 전송한다.\n만료 날짜까지 유지되는 영속 쿠키, 브라우저가 종료되기 전까지 유지되는 세션 쿠키가 있다.\n쿠키는 사용자가 임의로 변경할 수 있다. \n\n세션 하이재킹: 인증이 완료된 사용자의 브라우저에서 인증 정보가 담긴 세션 쿠키를 탈취하여 로그인 없이 서버와 통신하는 것\n\n### XSS & HTTP Only 쿠키\nXSS는 공격자가 악의적인 스크립트 코드를 삽입하여 의도치 않은 명령을 실행시키거나 세션을 탈취하는 공격\nHTTP Only 쿠키는 개발자가 간단한 접미사를 쿠키 생성 코드에 추가함으로써 활성화할 수 있다.\n\n```java\nSet-Cookie: 쿠키명=쿠키값; path=/; HttpOnly\n```\n\n브라우저에서 해당 쿠키로 접근할 수 없게 되지만, 쿠키에 포함된 정보의 대부분이 브라우저에서 접근할 필요가 없어 HTTP Only Cookie는 기본적으로 적용하는 것이 좋다.\n\n그러나 여전히 네트워크를 직접 감청하는 등의 방식으로 쿠키 탈취가 가능하다. \n이를 위해 HTTPS 프로토콜을 사용하여 쿠키에 대한 정보를 암호화해서 전송할 수 있다.\n\n그럼에도 쿠키는 기본적으로 모든 요청에 포함되기 때문에 쿠키의 정보는 전달되게 된다.\nSecure 쿠키: HTTPS 프로토콜을 사용할 때만 쿠키를 전달하는 방법이 있다.\n\n### 세션\n민감한 정보들을 서버에 저장하고, 연결을 유지하는 방법이다.\n인증된 사용자의 식별자에 대응하는 임의의 문자열 session id를 생성한다.\n\n쿠키는 클라이언트에 저장되며, 세션은 서버에 저장되므로 쿠키에 비해 비교적 안전하다.\n세션은 쿠키에 비해 느리다. 서버에 동시 접속하는 사용자가 많아지면 메모리 공간이 부족해져서 서버에 부하가 걸린다.\n여러 기기에서의 로그인을 제한하기 위해 필요한 때에 로그인 되어 있는 사용자를 강제로 로그아웃을 시킬 때 사용하기도 한다. \n\n스케일 아웃으로 서버를 확장하게 되면, 서버 별로 세션을 따로 관리하기 때문에 세션 불일치 문제가 발생한다. \n\n#### Sticky Session\n동일한 클라이언트의 요청을 처음 요청이 처리된 서버로만 보내는 것. 로드밸런서 설정으로 변경할 수 있다. \n\n그러나 트래픽이 한 곳으로 몰릴 수 있고, 서버의 가용성을 최대한 활용하지 못한다는 단점도 존재한다.\n또한 하나의 서버에 장애가 발생하면 해당 서버를 사용하는 사용자는 세션 정보를 잃어버리게 된다. \n\n#### Session Clustering\n특정 서버에서 세션이 생성되는 경우, 다른 서버로 전파해서 세션을 복제하는 방식으로 세션 불일치를 해결한다.\nTomcat 에서는 All-to-all 세션 복제를 사용한다. 변경 요소가 발생하면 변경 사항이 모든 세션에 복제된다.\n\n유저가 어떤 서버에 접속하더라도 로그인 정보가 세션에 복제되어 있어 정합성 이슈가 해결된다.\n그러나 모든 서버가 동일한 세션 객체를 가져야 하므로 많은 메모리가 필요하다. 또한 서버 수에 비례하여 네트워크 트래픽이 증가한다. -> 소규모 클러스터에서 좋은 효율을 보여준다.\n\n#### Session Server 분리\n세션을 저장하는 세션 서버를 외부 서버로 분리하여 사용한다.\n세션 서버로는 입출력이 잦은 세션의 특성 상, In-Memory DB인 Redis를 사용하는 것이 일반적이다.\n\n새로운 서버를 띄우더라도 기존 서버의 수정이 발생하지 않는다.\n그러나 외부 서버를 거쳐야 하므로 성능이 조금 느려지며, 분리된 세션 서버가 죽는 순간 모든 세션이 사라지기 때문에 해당 세션 서버의 다중화와 데이터베이스의 Reflecation도 고려해야 한다. (가용성을 확보하기 위해 동일한 세션 저장소 하나를 더 구성하여 복제한다.)\n\n### 토큰\n토큰 기반 인증은 쿠키와 비슷하게 인증 정보를 클라이언트에 저장한다. 쿠키나 로컬 스토리지에 저장되게 된다.\n`Authorization` 헤더에 실어 보내고, 토큰의 위변조, 만료 시간을 확인하고 인증 정보를 확인하여 사용자를 인가한다. \nJWT 는 쉽게 복호화 가능하므로, 중요한 개인 정보를 넣어서는 안 된다.\n\n세션 방식에 비해 scale out 관점에서 별도로 처리해주어야 할 것들이 없어진다.\n세션에 비해 서버에 전송되는 데이터의 양이 훨씬 많다. 또한 바로 데이터를 확인 가능하기 때문에 민감한 데이터를 담으면 안 된다는 단점이 있다. 한 번 발행한 토큰은 유효기간이 끝나기 전까지 따로 통제할 수 없기 때문에 세션에 비해 토큰 정보를 탈취 당할 가능성이 높다.\n\n## Interceptor와 Filter의 역할과 차이점\n\nDispatcherServler에 들어가기 전과 후로 Filter와 Interceptor가 작업을 처리하는 것을 볼 수 있다.\n\n### FIlter\n서블릿 컨테이너가 관리한다.\n공통 인증/인가, 로깅, 이미지/데이터 압축 및 문자열 인코딩을 수행한다. \n주로 필터는 스프링 시큐리티에서 사용한다.\n\n`doFilter`, `init`, `destroy` 메서드가 있다. 필터 체인을 사용해서 다음 필터에게 request 객체를 넘겨줄 수도 있다. 다음 필터가 존재하지 않으면 디스패처 서블릿으로 전달된다.\n\n`GenericFilterBean` 은 기존 필터에서 얻어올 수 없는 정보인 Spring의 설정 정보를 가져올 수 있게 된 추상 클래스이다. \n\n`OncePerRequestFilter` 는 모든 서블릿에 일관된 요청을 처리하기 위해 만들어진 필터이다.\n\n## Bean의 Scope 활용하기\n`Bean`은 스프링이 생성/관리하는 클래스의 인스턴스(객체) 이다.\n\n### Bean이 갖는 메타데이터\n- 실제 빈 구현이 정의된 패키지 정보와 클래스 이름\n- 빈의 컨테이너 안에서 동작을 정의한 정보\n- 다른 빈에 대한 의존 정보\n\n### Bean Scope\n특정 Bean이 어느 범위에서 존재할 것인가\n기본적으로 6개의 Scope 설정을 지원한다.\n\n#### Singleton\nIoC 컨테이너 안에서 단 하나의 Bean만 존재하게 된다.\n별도의 캐시에 저장하여 해당 bean에 대한 다음 요청부터 캐시의 빈을 제공해준다.\n\n#### Prototype\n빈 요청이 있을 때마다 새로운 빈을 만들어내는 scope이다.\n새로운 bean의 생성, 의존 관계 주입까지만 관여한 후, 더 이상 관리하지 않는다. \ngc에 의해 bean이 제거된다.\n\n#### Request\n어떤 요청 안에서 빈의 상태가 변경되어도 다른 요청에 영향이 가지 않는다.\n요청에 대한 응답이 끝나면 bean이 소멸한다.\n\n#### Session\nHTTP 세션 한 번에 하나의 빈을 만드는 scope이다.\n\n#### Application \nServletContext와 동일한 생명주기를 갖는 빈을 만든다. \n\n#### Websocket\n\n\n### 싱글톤 적합 vs 비싱글톤 적합\n#### 싱글톤으로 적합한 객체\n- 상태가 없는 공유 객체: 상태를 가지고 있지 않은 객체는 동기화 비용이 없다. 따라서 매번 이 객체를 참조하는 곳에서 새로운 객체를 생성할 이유가 없다.\n- 읽기용으로만 상태를 가진 공유 객체: 1번과 유사하게 상태를 가지고 있으나 읽기 전용이므로 여전히 동기화 비용이 들지 않는다. 매 요청마다 새로운 객체 생성할 필요가 없다.\n- 공유가 필요한 상태를 지닌 공유 객체: 객체 간의 반드시 공유해야 할 상태를 지닌 객체가 하나 있다면, 이 경우에는 해당 상태의 쓰기를 가능한 동기화 할 경우 싱글톤도 적합하다.\n- 쓰기가 가능한 상태를 지니면서도 사용빈도가 매우 높은 객체: 애플리케이션 안에서 정말로 사용빈도가 높다면, 쓰기 접근에 대한 동기화 비용을 감안하고서라도 싱글톤을 고려할만하다. 이 방법은 1. 장시간에 걸쳐 매우 많은 객체가 생성될 때, 2. 해당 객체가 매우 작은 양의 쓰기상태를 가지고 있을 때, 3. 객체 생성비용이 매우 클 때에 유용한 선택이 될 수 있다.\n#### 비싱글톤으로 적합한 객체\n- 쓰기가 가능한 상태를 지닌 객체: 쓰기가 가능한 상태가 많아서 동기화 비용이 객체 생성 비용보다 크다면 싱글톤으로 적합하지 않다.\n- 상태가 노출되지 않은 객체: 일부 제한적인 경우, 내부 상태를 외부에 노출하지 않는 빈을 참조하여 다른 의존객체와는 독립적으로 작업을 수행하는 의존 객체가 있다면 싱글톤보다 비싱글톤 객체를 사용하는 것이 더 나을 수 있다.\n출처: https://gmlwjd9405.github.io/2018/11/10/spring-beans.html\n\n## ApplicationContext\n\n## 질문\n- JWT 방식의 단점은 무엇일까요? (로그인 상태를 여러 기기에서 유지할 수 없음. stateless 하지 않다.)\n- Session Clustering의 장점 / 단점은 무엇인가요? : 포이\n- JWT는 쉽게 복호화할 수 있기 때문에 중요한 정보를 넣어서는 안 된다고 했는데, JWT 에 넣어야 되는 정보에는 무엇이 있나요? : 말랑\n\t- 식별자를 넣으면 좋지 않을까요? ID 값이나 UUID 같은 거\n- stateful한 클래스를 singleton으로 사용하면 안 되는 이유는 무엇인가요? : 헤나\n- stateful한 클래스는 무슨 scope로 빈을 생성하면 좋을까요?\n- prototype scope는 언제 사용하나요? : 포이\n- prototype의 bean은 어떻게 제거되는지 아시나요? : 포이\n- singleton scope를 사용하기 좋은 객체가 뭐라고 생각하시나요? / 비싱글톤으로 적합한 객체는 뭐라고 생각하시나요? : 말랑\n- 필터의 로깅 작업이 필요한 이유는 무엇인가요? -> HTTP 요청과 응답에 대한 정보를 수집할 수 있다. 보안상의 이유와 디버깅을 위해 : 포이\n- Filter에서 발생한 예외처리는 어떻게 할 수 있나요? : 포이\n- ControllerAdvice로 예외처리를 할 수 있나요? : 포이\n- Singleton scope와 Prototype scope를 동시에 사용했을 때 일어날 수 있는 문제점이 있을까요? : 포이\n\t- Singleton bean 내부에서 prototype bean을 사용할 수 있는 방법? -> object provider를 사용하면 된다고 하네요\n- Session Clustering 설명해주세요 : 말랑\n\t- WAS 끼리의 통신은 어떻게 하나요?\n\t- Session의 동기화 시점?\n- Scale up vs Scale out을 비교해주세요 : 말랑\n- refresh token을 추가한 JWT의 장단점을 알려주세요 : 말랑\n- interceptor의 handler를 활용할 수 있는 방법? : 말랑\n\t- 모르겠네요...\n- ApplicationContext가 뭔가요? : 말랑\n- Spring Security에서 interceptor 대신 filter를 사용하는 이유? : 말랑\n- bean이 갖는 메타 데이터에 대해 설명해주세요 : 헤나\n- Singleton, Prototype 외의 다른 스코프의 경우 어떤 설정을 해주어야 하나요? : 헤나\n\t- WebApplication에서만 사용할 수 있습니다. (MVC, WebFlux)\n- Proxy 모드란? : 헤나\n- HTTP Only 쿠키를 사용하면, 브라우저에서 쿠키에 접근할 수 없는데도 사용해도 되나요? : 헤나\n\n# 6/5\n\n## 헤나\n\n### 질문\n- Spring Container에게 객체 생성과 관리를 위임하는 것의 장단점?\n- MVC에 대해 설명해주세요.\n- 레이어를 어떻게 구분해서 작성하시는지?\n- IoC Container 란? 역할?\n- Spring Container의 생명 주기, bean 스코프 (소멸 전 콜백 메서드)\n- 의존 관계 주입은 언제 일어나나? => 의존 관계 주입이 초기화 콜백 메서드 이후에 생성되는 거면 생성될 때에는 필드가 null인데 의존 관계 주입이 가능한가요?\n\n스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → **초기화 콜백 메소드 호출** → 사용 → **소멸 전 콜백 메소드 호출** → 스프링 종료\n\n### 피드백\n- 중간에 질문과 관련 없는 내용이 답변으로 나올 때가 있었다.\n\n## 포이\n\n### 질문\n- dao의 단위 테스트란? \n- dao의 단위 테스트가 아니라 통합 테스트로 봐야 하는 거 아닌가?\n- 실제 db와 연동하는 테스트인 dao의 단위 테스트라고 한 이유?\n- vpc에 대해 설명해주세요\n- vpc 내에 서브넷의 개념이 있는데, 서브넷 개념에 대해 말해주세요. \n- vpc의 보안그룹과 서브넷의 NACL에 대해 알고 계신가요?\n- classist와 mockist에 대해 설명해주세요.\n- 본인은 주로 어떤 테스트 더블을 사용하시는지 말씀해주세요.\n- mocking과 stubing의 차이점?\n- 레이어드 아키텍처 각 계층의 역할에 대해 설명해주세요.\n- argument resolver와 interceptor를 어떻게 사용하셨나요?\n- interceptor를 사용해서 접근해보신 적 있나요? 왜 접근하셨나요?\n- spring bean scope에 대해 설명해주세요. \n- prototype 스코프는 어떤 경우에 사용하면 좋을까?\n- request 스코프와 session 스코프의 차이점이 있나요?\n- interceptor는 항상 작동할까?\n\n### 피드백\n- 한 문장의 호흡이 좀 긴 것 같습니다.\n\n## 베로\n\n### 피드백\n- 끝까지 말하긴 했지만 내용이 좀 틀린 부분이 있었다.\n\n## 말랑\n\n### 질문\n- connection이란?\n- datasource에 대해 설명해주세요. \n- connection pool은 누가 관리하나요?\n- 서브넷을 뭐라고 할 수 있을까요?\n- VPC가 없는 경우에서도 서브넷은 사용할 수 있다고 알고 있는데...\n- CIDR에 대해 설명해주세요.\n- spring event에 대해 설명해주세요.\n- 어떤 경우에 spring event를 쓰는 게 좋을까요?\n- propagation 레벨 NEVER를 사용하는 경우는 언제일까요?\n\n### 피드백\n- 설명하기 어려운 게 나왔을 때 당황했다.\n- TCP/UDP 답변은 생각을 해도 못 했다..."},{"excerpt":"스터디 주제 준비 default-method functional-interface grasp webmvctest ioc-container-and-di bean-candidate 면접 vepohuhemal-study-question","fields":{"slug":"/vepohuhyemal-study/"},"frontmatter":{"date":"2023년 03월 24일 01:03","title":"베포후헤 스터디","tags":null},"rawMarkdownBody":"\n## 스터디 주제 준비\n\n- [[default-method]]\n- [[functional-interface]]\n- [[grasp]]\n- [[webmvctest]]\n- [[ioc-container-and-di]]\n- [[bean-candidate]]\n\n## 면접\n- [[vepohuhemal-study-question]]"},{"excerpt":"LOG 브라운에게 면담 신청했다. 최근에 있던 일이 아직 해결되지 않고 있어서 스트레스 받고 있다. 어떻게든 해결해보고 싶어서 신청했다. 원래 온라인으로 하는 거 제안 주셨는데 아무리 생각해도 온라인으로 할 얘기가 아닌 것 같아 오프라인으로 하게 되었다 ㅋㅋ (저 때문에 출근하게 되신 브라운... 죄송해요 😂) 1, 2단계 PR이 머지되었다. 그런데 코드…","fields":{"slug":"/2023-03-23/"},"frontmatter":{"date":"2023년 03월 23일 14:03","title":"2023년 03월 23일","tags":null},"rawMarkdownBody":"## LOG\n- 브라운에게 면담 신청했다. 최근에 있던 일이 아직 해결되지 않고 있어서 스트레스 받고 있다. 어떻게든 해결해보고 싶어서 신청했다. 원래 온라인으로 하는 거 제안 주셨는데 아무리 생각해도 온라인으로 할 얘기가 아닌 것 같아 오프라인으로 하게 되었다 ㅋㅋ (저 때문에 출근하게 되신 브라운... 죄송해요 😂)\n- 1, 2단계 PR이 머지되었다. 그런데 코드리뷰 채널에는 알림이 오지 않아서 뭔가 이상했다. 3단계 진행해도 되는 거겠지?\n- 오늘 데일리 미팅 때 박스터가 서로 칭찬해주기라는 주제로 진행했다. 서로 칭찬하다가 5기 잡담 채널에 올리기로 결정난 뒤에는 서로 얼마나 더 엄청난(?) 칭찬을 할 지 고민하는 게 웃겼다 ㅋㅋㅋㅋ 오늘은 안 걸렸지만 걸린 사람들이 내일도 하자고 해서 ㅋㅋ... 나도 하게 될 거 같다. 곤란하다 🧨\n- 점심에 BBQ를 먹었는데 오늘따라 날씨가 굉장히 좋았다. 석촌호수 돌면서 산스장(?)도 갔다왔다. 체인저의 벤치 프레스 굉장했다. 역시 헬스인들은 대단한 거 같다. 그렇다고 내가 운동을 하게 되지는 않을 듯 ㅋㅋ\n\n## 배운 것\n- ```Map```에도 ForEach를 쓸 수 있다.\n\n## 궁금한 것\n- 양방향 의존은 별로인가? 왜 별로인가?\n- groupingby\n\n## 어려웠던 것\n- 말 예쁘게 하기.\n\n## 느낀 것\n- 나쁜 사람이 되기 싫다. 나쁜 사람이 되고 싶은 사람이 그렇게 많진 않지만. 여전히 눈치를 보고 있다. 우테코에서 눈치본다는 뜻이라기 보다는 아직도 주변을 많이 신경쓰고 있다는 뜻이다. 그래도 여기 와서는 예전보다는 눈치를 덜 보는 거 같긴 하다. 그래서 자신의 주관과 의견이 뚜렷한 사람이 멋지다. 좋은 것, 싫은 것이 확실한 사람이 신기하다. 난 아직 찾아가는 중이다.\n- 그냥 이것저것 좀 어렵다. 제대로 풀려가는 건지, 뭐가 어떻게 되어 가는건지 잘 모르겠다. 나도 내가 뭘 하고 싶은 건지 모르겠다 ㅋㅋㅋ 언제쯤 알 수 있을까? 빨리 찾을 거라는 기대 같은 건 안 한다. 23년째 찾고 있으니까. 여전히 삶의 목표가 뭘까 물어보면 대답할 수 없다. 지금 나는 일단 그냥 살고 있다. 지금 당장은 재밌는 일들을 하면서 살고 싶다. 나중의 내가 지금의 나를 원망하게 될까?\n- 오늘도 심신미약이다. 내일은 좀 더 자볼까? 하필 오늘은 더 일찍 일어났어서 그랬을지도.\n"},{"excerpt":"LOG 오늘도 긍정 말하기는 이어졌지만... 그렇다고 긍정적인 말을 많이 한 건 아닌 거 같다ㅋㅋㅋ 날이 갈수록 변질된다 ㅋㅋㅋ 긍정적으로 말하라고 다들... 포이랑 같이 커맨드 패턴, 상태 패턴 적용해봤다. 처음에는 진짜 막막했는데 하다보니까 뭔가 됐다. 근데 이렇게 쓰는 게 맞는걸까? 그래도 하고 나니까 마음에 들어서 좋았다. 낮에 많이 웃고 저녁부터…","fields":{"slug":"/2023-03-22/"},"frontmatter":{"date":"2023년 03월 22일 14:03","title":"2023년 03월 22일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘도 긍정 말하기는 이어졌지만... 그렇다고 긍정적인 말을 많이 한 건 아닌 거 같다ㅋㅋㅋ 날이 갈수록 변질된다 ㅋㅋㅋ 긍정적으로 말하라고 다들...\n- 포이랑 같이 커맨드 패턴, 상태 패턴 적용해봤다. 처음에는 진짜 막막했는데 하다보니까 뭔가 됐다. 근데 이렇게 쓰는 게 맞는걸까? 그래도 하고 나니까 마음에 들어서 좋았다.\n- 낮에 많이 웃고 저녁부터 약간 절전모드라 공감 제로맨이 되어 가고 있다. 원래 이런 사람은 맞긴 한데 앞으로는 좀 더 노력해봐야겠다. 그래도 이정도면 많이 늘어난 거 아닐까하고 위로하는 중이다.\n- 아침에 버스에서 아이묭 노래 듣는 사람을 봤다. 사실 아이묭 그렇게 막 좋아하는 가수는 아닌데 그때는 엄청 반가워서 순간적으로 말 걸까 생각했다. 역시 그건 아닌 거 같아서 그만뒀다. 점점 이상한 사람이 되어 가는 거 같기도..? 원래 이런 사람 아닙니다?\n- 토리, 포이, 박스터와 9시 반에 퇴근했다. 신림에서 내려서 박스터랑 얘기하다가 갔다. 박스터는 재밌고 나는 얘기할 사람 있어서 일석이조다~\n- 박스터, 주노, 체인저와 아침에 잠실역에서 우연히 마주쳤다. 한 번도 아침 잠실역에서 같은 크루 만나본 적 없는데 오늘 아침따라 많이 만나서 신기했다.\n\n## 배운 것\n- [[effective-java-ed3|정적 팩토리 메서드의 장단점]] -> 방금 쓰고 알았는데 단점을 안 적었다..ㅋㅋ\n- ```EnumMap<>(EnumClass.class)```: ```enum```을 ```key```로 사용하는 경우에는 ```EnumMap```의 성능이 더 좋다고 한다. 신기하다.\n\n## 궁금한 것\n- 커맨드 패턴의 ```Command```는 ```interface```로만 사용할까? ```abstract class```는 자주 사용하지 않는 편일까? 아무래도 상속을 기피하는 편이라 더 ```interface```를 사용할 것 같긴 하다.\n\n## 어려웠던 것\n- 커맨드 패턴, 상태 패턴 적용하면서 내 코드에 집중을 못했다. 나중에 내가 뭘 하고 있는지도 모르게 되어서 패턴 쓰기 전에는 충분히 공부하고 하는 게 나을 거 같다.\n- 안 좋은 기분 금방 떨쳐내기.\n\n## 느낀 것\n- 내년에 나는 뭐가 되어 있을까? 멋진 사람이 되어 있으면 좋겠지만 정말 그렇게 되어 있을지 궁금하다. 내년의 나라고 나와 그렇게 막 다를 것 같지는 않지만 기왕이면 많이 바뀌어 있으면 좋겠다.\n- 나도 사람을 좀 가리는 것 같다. 아닌 줄 알았는데 ㅋㅋ 아무나 쉽게 친해지는 성격은 역시 못 되나보다. 그렇지만 그것도 그것 나름대로 좋..을 수도 있지 않을까..? 그냥 그렇게 생각하자...\n- 신경써서 말하자. 요즘 너무 뇌를 안 거치고 나오는 말이 많다. 다른 사람들이 생각할 때 어떻게 받아들일지 생각하고 나서 말해봐야겠다.\n- 집에서 뭔가 많이 할수록 피곤하다. 진짜 잠만 자고 빨래하는 곳이 되었다. 이번 주말에는 꼭 밀린 집안일을 해야겠다. 저녁에 집에 가면 청소기를 돌릴 수 없어서 방이 더럽다. 주말에 그냥 깨끗하게 다 치워버리는 게 낫겠다. 지금 냉장고를 열기가 무섭다. 먹을 게 많아도 안 먹으니 소용이 없다. 끔찍한 모습이 되기 전에 주말에 치워버려야겠다.\n- 좋은 사람이 되고 싶다. 어떻게 하면 좋은 사람이 될 수 있을까? 요즘 많이 하는 고민이다.\n"},{"excerpt":"페어와의 규칙 이번 페어는 루카! 루카와 같이 밥을 먹으면서 말을 놓았다. 페어 회고 루카가 나에게 좋았던 점 먼저 친근하게 다가와줘서 좋았다. 규칙 정해서 한 거 좋았다. 의견을 명확하게 말해줘서 좋았다. 친화력이 좋다. 공통적으로 아쉬웠던 점 tdd를 제대로 못했다. 기능에 집중해서 기능 구현 분석을 너무 시간에 몰아쳐서 정리를 못하고 갔다. 타이머 …","fields":{"slug":"/level1-chess/"},"frontmatter":{"date":"2023년 03월 22일 01:03","title":"레벨1 체스 미션","tags":["레벨1","우테코"]},"rawMarkdownBody":"\n## 페어와의 규칙\n\n- 이번 페어는 루카!\n- 루카와 같이 밥을 먹으면서 말을 놓았다.\n\n## 페어 회고\n\n### 루카가 나에게 좋았던 점\n\n- 먼저 친근하게 다가와줘서 좋았다.\n- 규칙 정해서 한 거 좋았다.\n- 의견을 명확하게 말해줘서 좋았다.\n- 친화력이 좋다.\n\n### 공통적으로 아쉬웠던 점\n\n- tdd를 제대로 못했다. 기능에 집중해서 기능 구현 분석을 너무 시간에 몰아쳐서 정리를 못하고 갔다.\n- 타이머 깜빡하는 경우가 있었다. 좀 더 시간 확인 잘하기.\n- 너무 완벽한 코드를 짜기 위해 고려하는 시간이 길었다. -> 동작하는 프로그램 만드는 것이 1순위\n- 이런 고민은 나중에 해볼까? 의견을 좀 쳐내줬으면 좋겠다. -> 규칙 추가\n- 처음에 확실하게 잡고갈 것은 도메인의 기능. 도메인의 역할을 확실하게 정하고 가기. -> 규칙 추가\n\n### 내가 잘했다고 생각하는 것\n\n- 의견전달 확실히 한 거.\n- 말 놓은 거. 밥 먹은 거.\n- 의견 양보를 덜 했다.\n- 나를 납득시키는 코드를 작성했다.\n- 의견 교류를 잘했다.\n- 항상 칼퇴했는데 미션에 시간을 좀 더 많이 썼다.\n\n### 앞으로의 다짐\n\n- 설계를 너무 길게 하지 않을 거 같다. 어쨌든 바뀌니까 너무 오래 잡지 말자.\n- 굳이 다이어그램 안 그려도 될 거 같다.\n- 요구사항 분석을 좀 더 철저하게 할 거 같다.\n- 페어랑 헤어지고 나서도 이야기를 할 거 같다.\n- 시간이 없더라도 TDD를 좀 더 철저하게.\n\n## 앞으로 페어할 때 이렇게 해보자\n\n- 페어가 되면 밥을 같이 먹으면서 (페어가 괜찮다면) 말을 놓자.\n- 설계는 최대 1시간만 하자. 어차피 하면서 바뀐다.\n- 요구사항 분석을 좀 더 철저하게 하자. 도메인이 어떤 역할, 어떤 기능을 해야 하는지 정도는 철저하게 정하고 가자.\n- TDD를 준수하자. 시간이 없더라도 TDD 하자고 말하자.\n- 15분마다 교대하고 1시간마다 10분 동안 휴식을 취하자.\n- 둘 다 좋아요 금지\n- 모르는 거, 이해 안 되는 거는 언제든지 다시 말해달라고 하자.\n- 토론이 필요한 경우 시간을 멈추고 토론하자.\n- 페어랑 헤어지고 나서도 고민되는 부분에 대해 같이 토론하자.\n- 너무 완벽한 코드 짜려고 하지 말자.\n- 리팩토링 시간 하루는 남겨두자. (미션 제출 전날까지 구현을 완료하자)\n- 토론이 너무 길어지거나 지엽적인 부분은 나중에 말하자고 의견을 쳐내주자.\n\n## 학습 로그 말하기 피드백\n\n- 발표의 순서가 좋았다.\n- 질문에 대해서 확실히 잘 이해시켜줬다.\n- 내가 놓칠 수 있는 부분에 대해 추가적인 설명을 해주는 게 좋았다."},{"excerpt":"LOG 베포후헤 스터디 (이거 이제 이름이 되어버린건가 싶다 ㅋㅋ) 준비했다. 내가 생각해도 열심히 준비했었는데 내 생각보다 퀄리티가 많이 나온 것 같지 않아 좀 슬펐다. 후추가 정말 발표를 잘했다. 헤나도 예시 엄청 꼼꼼하게 준비해와서 이해가 잘 됐다. 다들 발표 고수들이었다. 사실 내가 최약체였던 것..! 오히려 좋아 ㅋㅋ 체스는 거의 구현 못했다. …","fields":{"slug":"/2023-03-20/"},"frontmatter":{"date":"2023년 03월 21일 15:03","title":"2023년 03월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 베포후헤 스터디 (이거 이제 이름이 되어버린건가 싶다 ㅋㅋ) 준비했다. 내가 생각해도 열심히 준비했었는데 내 생각보다 퀄리티가 많이 나온 것 같지 않아 좀 슬펐다. 후추가 정말 발표를 잘했다. 헤나도 예시 엄청 꼼꼼하게 준비해와서 이해가 잘 됐다. 다들 발표 고수들이었다. 사실 내가 최약체였던 것..! 오히려 좋아 ㅋㅋ\n- 체스는 거의 구현 못했다. 시간이 없기도 했고, 할 게 많아서. 제일 큰 이유는 스터디 때문이었다. 그래도 스터디 하니까 강제성이 부여돼서 공부가 됐다. 내가 적당히 커버할 수 있는 정도의 스터디는 정말 도움이 된다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 내 결과물과 나를 분리하는 것. 지금은 꽤 익숙해진 것 같지만 아직도 흠칫할 때가 있다. 그냥 just 피드백일 뿐인데 가끔은 나에 대한 공격으로 느껴질 때가 있다. 그래서 그 사람이 미워지는 건 절대 아니다. 나는 오히려 의연해지고 싶다. 더 나아지기 위해서 피드백을 내 성장을 위한 거름으로 여길 수 있는 사람이 되었으면 좋겠다. \n\n## 느낀 것\n- 확실히 발표가 더 늘었다. 원래 말을 더듬거나 '이거 뭐지' 라던지 당황하면 이상한 말을 했었는데 그 빈도수가 현저히 줄었다. 말을 할 일이 많아서 나아졌다고 생각하기로 했다. 페어 회고, 학습 로그 말하기, 그냥 토론 등으로 다져진 거 아닐까? 어쨌든 더 나아지고 싶다. 잘하고 있다!\n- 기억력은 안 좋아졌다. 방금 들은 말도 기억이 잘 안 난다. 사실 집중이 잘 되지 않는다. 왜 집중이 잘 되지 않는지는 여러 가지 이유가 있을 거 같은데 아직은 완벽하게 파악하지 못했다. 내 상태를 정확하게 파악해야 어떻게 할 지도 생각할 수 있는데. 찾아가는 중이다.\n- 레벨 인터뷰 때는 재택해야 한다고 해서 순간 아쉬웠다. 나는 진짜로 방학이 아쉽다. 그 때도 나오고 싶지만.. 방학 때는 캠퍼스를 안 연다고 해서. 지금은 집보다 잠실캠에 오는 시간이 더 좋다. 고등학교 때처럼 여기 있는 사람들과 엄청 오랜 시간을 보게 되니까 더 끈끈하고 빠르게 친해진 거 같다. 지금은 같이 있는 크루들 덕분에 힘들지 않다 :)\n"},{"excerpt":"LOG 드디어 맥북 아래 공간을 쓸 수 있게 됐다. 항상 dock을 올려서 쓰다보니 그대로 설정이 굳어져서 내려가지도 않았었다. 포이가 잡담방에 올려보래서 도움 요청 글을 올렸었다. 그런데 올린지 10분 지나고 브라운이 껐다 켜보라고 조언했는데 바로 돼서 굉장히 머쓱했다...ㅋㅋ 3일 연속 국밥을 먹었다. 오히려 좋았다. 아직은 국밥 쿨타임이 빨리 도는 …","fields":{"slug":"/2023-03-21/"},"frontmatter":{"date":"2023년 03월 21일 15:03","title":"2023년 03월 21일","tags":null},"rawMarkdownBody":"## LOG\n- 드디어 맥북 아래 공간을 쓸 수 있게 됐다. 항상 dock을 올려서 쓰다보니 그대로 설정이 굳어져서 내려가지도 않았었다. 포이가 잡담방에 올려보래서 도움 요청 글을 올렸었다. 그런데 올린지 10분 지나고 브라운이 껐다 켜보라고 조언했는데 바로 돼서 굉장히 머쓱했다...ㅋㅋ\n- 3일 연속 국밥을 먹었다. 오히려 좋았다. 아직은 국밥 쿨타임이 빨리 도는 편이라 자주 먹어도 괜찮다.\n- 오늘은 신림에서 내려서 집에 가봤다. 꽤 사람 많을 줄 알았는데 그렇지도 않았다. 좀 늦게 가면 사람이 많이 없는 모양이다. 그런데 그렇게 차이가 나는 지는 모르겠다. 한 7-8분..? 정도 나는 거 같다. 그때그때 상황 봐서 어디서 내릴지 결정해야겠다.\n- 잠을 얼마 못 잤지만 아침에는 피곤하진 않았다. 그런데 뒤로 갈수록 피곤해지는 걸 보니 알고보면 피곤했던 거 같기도 하다. 그냥 할 일이 많다... 뭔가 하긴 했는데 한 거 같지 않다.\n- 갑자기 체인저랑 포이가 긍정문으로 말하기 했는데 그냥 개웃겼다 ㅋㅋㅋ 처음에는 분명 좋은 취지였는데 갈수록 반례 가져오고 점수 매기기 하니까 웃기기만 했다 ㅋㅋㅋㅋㅋ 나도 오늘 좀 노력해보려고 했는데 딱히 잘 된 거 같지는 않다.\n- 박스터, 포이, 그레이, 다즐과 저녁 먹었다. 다즐은 옷을 잘 입는다. 게다가 동기를 닮아서 처음 봤지만 굉장히 친근했다. 뭘까... 왜 이렇게 닮은 사람이 많은 걸까... 내 주변에 사람이 그렇게 많지도 않은데 계속 닮은 사람이 나와서 이제는 당황스럽다;;\n- 박스터가 리뷰해줬다. 리뷰가 부족하다고 느끼고 있었는데 피드백 해줘서 고마웠다. 질문한 거, 해결 방법 모두 정말 많이 도움이 됐다. 다만 오늘까지 PR을 보낼 생각이었어서 많이 반영 못한 건 아쉽다. 내일 가서 반영 열심히 해야겠다.\n- 눈우랑 말랑 코드를 같이 봤다. 둘 다 관점이 명확해서 재밌게 읽었다. 말랑 코멘트로 볼 때는 굉장히 상냥하게 말하는 줄 알았는데 머릿속으로는 험악한 거 같다 ㅋㅋㅋㅋ 어떻게 구현할 지 힌트를 얻어서 수확이 컸다.\n\n## 배운 것\n- assertThat을 여러 번 할 때는 Junit assertAll을 쓰면 좋다고 한다. by 박에스더 (근데 왜인지는 안 물어봤네)\n- ```Consumer<T>``` : T를 인자로 받아서 void를 리턴값으로 갖는 함수형 인터페이스이다. accept로 실행한다.\n\n## 궁금한 것\n- composite 패턴 by 말랑\n- rich domain model by 눈우\n- command 패턴\n- GRASP\n\n## 어려웠던 것\n- 긍정문 말하기. 내가 굉장히 부정적으로, 독성 말투로 말하고 있다는 걸 뼈저리게 ;; 느꼈다. 말을 부드럽게 해서 안 좋을 게 없는데 앞으로도 노력해보자. 굳이 지금 내 말투가 안 좋다기 보다는 둘 다 하면 좋으니까... 라는 마인드로 해 볼 생각이다.\n\n## 느낀 것\n- 집에 가서는 자기만 하고 싶다 (이제 want로 바뀜) 오늘 집에 와서는 리팩토링을 마저 했는데 피곤하다. 이제 어느 정도 피곤함의 경지에 오르니까 피곤하지 않은 거 같은(?) 기분이 든다.\n- TIL을 보는 사람이 늘어나고 있어서 좋다. 관심 좋아하는 사람이라 내 글이 많은 사람들한테 알려지면 좋겠다. 그렇지만 내 일기 쓸 때마다 알람 울리는 건 좀..\n- todo mate 왜 하고 있는지 모르겠다 ㅋㅋㅋ 오늘은 거기다 적은 일을 70% 이상 못해서 계획을 왜 세우고 있을까하는 현타가 왔다. 계획과 나는 안 맞는 거 같다. 무엇을 할 지 생각하는 걸 정하는 것도 못하다니 쉽지 않네.\n- 많이 웃는 시간이 늘어날수록 즐겁다. 긍정문 때문에 웃겨서 눈물났는데 그 덕분인지 오늘 내내 웃겼다. 내가 조증인가 싶다 이제\n"},{"excerpt":"디폴트 메서드를 사용하는 이유 디폴트 메서드가 없던 때를 예로 들어보자. 우리가 라이브러리 설계자이고, 바퀴의 개수를 가져오는 기능을 구현해야 하는 인기 있는  인터페이스가 있다고 가정하자.\n생각해보니 해당 탈 것이 사륜구동인지 확인하는  이라는 메서드가 있으면 좋을 거 같다. 그래서 기존에 서비스되던  에  을 추가했다. 그런데 이전에 우리의 을 구현한…","fields":{"slug":"/default-method/"},"frontmatter":{"date":"2023년 03월 19일 13:03","title":"디폴트 메서드(Default method)","tags":["레벨1","우테코","학습로그","Java"]},"rawMarkdownBody":"\n## 디폴트 메서드를 사용하는 이유\n\n디폴트 메서드가 없던 때를 예로 들어보자.\n\n```\npublic interface Vehicle {\n\tint getWheelCount();\t\n}\n```\n\n우리가 라이브러리 설계자이고, 바퀴의 개수를 가져오는 기능을 구현해야 하는 인기 있는 ```Vehicle``` 인터페이스가 있다고 가정하자.\n생각해보니 해당 탈 것이 사륜구동인지 확인하는 ```isFourWheel``` 이라는 메서드가 있으면 좋을 거 같다.  \n\n그래서 기존에 서비스되던 ```Vehicle``` 에 ```isFourWheel``` 을 추가했다. \n\n```\npublic interface Vehicle {\n\tint getWheelCount();\n\tboolean isFourWheel();\n}\n```\n\n그런데 이전에 우리의 ```Vehicle```을 구현한 사용자에게는 문제가 생긴다.\n이전에 해당 인터페이스를 구현했던 모든 클래스의 구현을 고쳐야 한다는 것이다! \n\n이렇게 공개된 API를 수정하면 기존 버전과의 호환성 문제가 발생한다.\n\n이를 해결하기 위해 자바 8 부터는 디폴트 메서드를 지원한다.\n\n## 디폴트 메서드란?\n\n디폴트 메서드는 인터페이스에 있는 구현 메서드이다.\n\n```default``` 키워드로 시작하며, method body를 포함한다.\n\n```\npublic interface Vehicle {\n\tint getWheelCount();\n\tdefault boolean isFourWheel() {\n\t\treturn getWheelCount() == 4;\n\t}\n}\n```\n\n이렇게 Default 메서드를 정의할 수 있다. \n위의 예제에서 앞으로 ```Vehicle``` 인터페이스를 구현하는 모든 클래스는 ```isFourWheel```을 상속받는다.\n```isFourWheel``` 을 따로 구현하지 않아도 메서드를 쓸 수 있게 된다.\n\n### 디폴트 메서드 오버라이딩\n\n디폴트 메서드는 기본 구현을 제공한다. \n인터페이스를 구현한 클래스가 디폴트 메서드의 기능을 다르게 구현하고 싶다면 오버라이딩을 사용할 수 있다.\n\n## 디폴트 메서드 활용\n\n### 선택형 메서드\n\n기존 인터페이스에서 잘 사용하지 않던 메서드를 디폴트 메서드로 작성하여 인터페이스를 구현하는 클래스에서 빈 메서드 구현을 하지 않도록 한다.\n\n```\ninterface Iterator<T> {\n\tboolean hasNext();\n\tT next();\n\tvoid remove();\n}\n```\n\n```Iterator```의 remove는 잘 쓰이지 않는다.\n그래서 Iterator를 구현하는 많은 클래스가 remove에 빈 구현을 제공했다.\n\n```\npublic class ListIterator<E> implement Iterator<E> {\n\tList<E> list; \n\tint cursor; \n\t\n\tpublic ListIterator(List<E> list) { \n\t\tthis.list = list; \n\t} \n\t\n\t@Override \n\tpublic boolean hasNext() { \n\t\treturn cursor < list.size(); \n\t} \n\t\n\t@Override \n\tpublic E next() { \n\t\tif (cursor == list.size()) throw new NoSuchElementException();\n\t\treturn list.get(cursor++); \n\t}\n\n\t@Override\n\tpublic void remove() {}\n}\n```\n\n잘 사용하지 않는 remove를 디폴트 메서드로 만들면 다음과 같다.\n\n```\ninterface Iterator<T> {\n\tboolean hasNext();\n\tT next();\n\t\n\tdefault void remove() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n}\n```\n\n이렇게 구현하면 ```Iterator```를 구현하는 하위 클래스에서는 ```remove```를 따로 구현할 필요가 없다.\n\n### 동작 다중 상속\n\n자바에서 클래스는 한 개만 상속할 수 있지만 인터페이스는 여러 개 구현할 수 있다.\n\n```\npublic interface Rotatable {\n\tvoid setRotationAngle(int angleInDegrees);\n\tint getRotationAngle();\n\tdefault void rotateBy(int angleIndegrees) {\n\t\tsetRotationAngle((getRotationAngle() + angleInDegrees) % 360);\n\t}\n}\n```\n\n```\npublic interface Moveable {\n\tint getX();\n\tint getY();\n\tvoid setX(int x);\n\tvoid setY(int y);\n\t\n\tdefault void moveHorizontally(int distance) {\n\t\tsetX(getX() + distance);\n\t}\n\t\n\tdefault void moveVertically(int distance) {\n\t\tsetY(getY() + distance);\n\t}\n}\n```\n\n```\npublic interface Resizable {\n\tint getWidth();\n\tint getHeight();\n\tvoid setWidth(int width);\n\tvoid setHeight(int height);\n\tvoid setAbsoluteSize(int width, int height);\n\n\tdefault void setRelativeSize(int wFactor, int hFactor) {\n\t\tsetAbsoluteSize(getWidth() / wFactor, getHeight() / hFactor);\n\t}\n}\n```\n\n인터페이스를 조합해서 다양한 클래스를 만들 수 있다.\n\n```\npublic Monster implements Moveable, Rotatable, Resizable {\n\t...\n}\n```\n\n또한 디폴트 메서드의 구현을 더 효율적으로 고치는 경우, 해당 인터페이스를 구현하는 모든 클래스도 자동으로 변경한 코드를 상속받게 된다.\n\n즉, 인터페이스의 디폴트 메서드를 수정하는 경우 인터페이스를 구현한 클래스들의 코드를 일일이 바꿔줄 필요가 없다. (메서드가 하위 클래스에서 재정의 되지 않은 경우에 한정된다)\n\n## 디폴트 메서드를 왜 쓸까?\n\n디폴트 메서드는 기존의 구현을 고치지 않고도 이미 공개된 인터페이스를 변경하기 위해 고안되었다.\n기존의 코드를 최대한 수정하지 않으면서, 설계된 인터페이스에 새로운 확장을 가능하게 만든다.\n\n## 참고 자료\n\n- 모던 자바 인 액션 Ch 13"},{"excerpt":"LOG 레벨1 글쓰기 PR을 제출했다. 한 김에 다른 크루들 피드백도 했다. 다들 글을 잘 써서 그런지, 피드백 하는 게 재밌었다. 오랜만에 글을 써서 그런가 어색했지만 역시 칭찬은 베로를 춤추게 한다(?) 생일이라 놀고 왔더니 일이 너무 많이 밀렸다. 밀린 PR도 제출하고, 글쓰기 피드백도 하고, 체스 피드백도 하고 했어야 했는데 시간이 없었다. 놀랍게…","fields":{"slug":"/2023-03-19/"},"frontmatter":{"date":"2023년 03월 19일 12:03","title":"2023년 03월 19일","tags":null},"rawMarkdownBody":"## LOG\n- 레벨1 글쓰기 PR을 제출했다. 한 김에 다른 크루들 피드백도 했다. 다들 글을 잘 써서 그런지, 피드백 하는 게 재밌었다. 오랜만에 글을 써서 그런가 어색했지만 역시 칭찬은 베로를 춤추게 한다(?)\n- 생일이라 놀고 왔더니 일이 너무 많이 밀렸다. 밀린 PR도 제출하고, 글쓰기 피드백도 하고, 체스 피드백도 하고 했어야 했는데 시간이 없었다. 놀랍게도 스터디 자료도 준비했어야 해서 결국 1시 50분에 자버렸다. 너무 체력적으로 힘들다.\n- 디폴트 메서드 발표 준비 했는데 생각보다 어려웠다. 호환성을 다루는 건 너무 많이 나간 거 같아서 뺐는데 시간이 나올지 모르겠다. 예제 만드는 게 항상 쉽지 않다. 저번에 헤나 피드백 대로 예제를 더 준비해봤는데 투머치인 거 같기도 하고.\n\n## 배운 것\n- [[default-method|디폴트 메서드]]\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 내가 모든 걸 커버하기가 쉽지 않다. 필연적으로 하나에는 소홀해질 수밖에 없다. 저번 주는 모든 걸 다 챙기지 못한 거 같다. 체력이 안 된다는 말이 이해 됐다. 앞으로는 어떻게 해야 할까... 고민이 된다. 정답은 없다. 내가 무엇을 선택할지만 결정하면 된다.\n- 지금 너무 잠을 적게 잔다. 물리적인 시간은 6-7시간 정도면 괜찮은 편인데 실제로는 너무 피곤해서 일상에 지장이 있다. 집에서 하는 일을 줄여야겠다. 집은 진짜 자는 곳으로 하자..\n- 요즘 노래가 좋다. 그냥 심심할 때, 주변이 허전할 때 노래를 틀어놓다보니 더 좋아졌다. 지하철 탈 때 들으면 가장 기분이 좋다.\n"},{"excerpt":"LOG 오늘은 놀기로 한 날이라서 한강에 놀러갔다. 날씨가 따뜻했는데 바람이 많이 불어서 산발이 되었다.. ㅎ 레벨1 글쓰기를 했다. 오랜만에 글을 써서 그런가 정말 안 써졌다. 궁금한 사람은 초안을 볼 수 있다 ->  레벨1 글쓰기 아직 많이 부족한 글이다. 쓰고 나니 너무 무겁게 썼나 해서 포이랑 글렌한테 물어봤는데 다 술마셔서 객관적인 판단을 들을 …","fields":{"slug":"/2023-03-18/"},"frontmatter":{"date":"2023년 03월 18일 16:03","title":"2023년 03월 18일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘은 놀기로 한 날이라서 한강에 놀러갔다. 날씨가 따뜻했는데 바람이 많이 불어서 산발이 되었다.. ㅎ\n- 레벨1 글쓰기를 했다. 오랜만에 글을 써서 그런가 정말 안 써졌다. 궁금한 사람은 초안을 볼 수 있다 -> [[level1-writing | 레벨1 글쓰기]] 아직 많이 부족한 글이다. 쓰고 나니 너무 무겁게 썼나 해서 포이랑 글렌한테 물어봤는데 다 술마셔서 객관적인 판단을 들을 수 없었다 ㅋㅎㅋ... 왜 다들 내 글 볼 때만 감성적인거야 ㅋㅋㅋ 그래도 술 마신 사람들한테라도 괜찮다는 말을 들어서 다행이었다.\n- 링 귀걸이를 다시 샀다. 예전 링 귀걸이는 한 짝을 잃어버려서 돌아오지 못했기 때문에 간수를 잘해야 한다. 일자로 된 귀걸이는 귀걸이 고정하는 핀?을 계속 갈아줘야 해서 귀찮은데 이건 안 그래도 돼서 좋다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부를 하고 싶다. 절대적인 시간이 부족하다고 느꼈다. 사실 할 건 정말 많은데 말이다. 나는 어디서부터 어디까지 챙길 수 있을까? 왠지 갈수록 뭔가는 놓칠 수 밖에 없을 것 같다는 생각이 든다.. 모두를 만족시킬 수는 없으니까 말이다. 그래서 아직 고민 중이다. 좋은 선택을 해야 할 텐데.\n- 예전부터 우려하던 일이 일어난 것 같다. 이럴 때 어떻게 대처해야 좋을까. 일단 내 생각부터 정리해야 한다. 아마도 최대한 빨리 하는 게 좋아 보인다. 이런 생각이 들다가도 아닌가.. 싶어서 다시 갈팡질팡하게 된다. 아직도 잘 모르겠다.\n- 할 일이 많다. 적어놓지 않아서 다 까먹었다. 역시 기록의 중요성. 다음 주에는 새싹교실도 해야 한다. 다음 주부터 많이 바쁠 거 같다. 자바.. 잘할 수 있을까? 사실상 기초라서 괜찮지만 그래도 새싹들이 많이 얻어갔으면 좋겠어서 욕심이 난다.\n- 오늘도 너무 졸리다. 잠을 해결을 못하고 있다. 월요일에도 빨리 갈 생각인데 내일은 빨리 잘 수 있을까? 편하게 푹 자고 싶다. 시간 제한, 알람 없이 잘 수 있을까."},{"excerpt":"LOG 체스 2단계 PR 보냈다. 너무 질문할 내용이 없어서 그런지 리뷰가 5개밖에 달리지 않았다 ㅋㅋㅋㅋ 좀 더 많았으면 좋았겠지만 이건 이것대로 괜찮다고 생각한다. 체인저랑 나랑 주말에 생일이어서 온보딩 조원들이 아이스크림 케익 사와서 축하해줬다. 감동이야.. 점심 같이 안 먹어 준다고 할 때 뭔가 있나 싶긴 했다. 그치만 포이랑 글렌이랑 점심 먹고 …","fields":{"slug":"/2023-03-17/"},"frontmatter":{"date":"2023년 03월 17일 14:03","title":"2023년 03월 17일","tags":null},"rawMarkdownBody":"## LOG\n- 체스 2단계 PR 보냈다. 너무 질문할 내용이 없어서 그런지 리뷰가 5개밖에 달리지 않았다 ㅋㅋㅋㅋ 좀 더 많았으면 좋았겠지만 이건 이것대로 괜찮다고 생각한다.\n- 체인저랑 나랑 주말에 생일이어서 온보딩 조원들이 아이스크림 케익 사와서 축하해줬다. 감동이야.. 점심 같이 안 먹어 준다고 할 때 뭔가 있나 싶긴 했다. 그치만 포이랑 글렌이랑 점심 먹고 전력질주 한다고 했을 때는 진짜 믿었다... ㅋㅋㅋㅋㅋ 케이크는 여러 크루와 나눠 먹었다. 많은 사람들한테 축하 받아서 기뻤다 ^ㅅ^ (포비에게 김 과자도 선물로 받았다. 맛있었다.)\n- 레벨 인터뷰가 평가에는 안 들어간다고 해서 다행이었다. 그렇지만 역시 대답 못 할 때는 많이 창피할 거 같다. 열심히 준비해야지!\n- 박스터랑 체스 둬서 2판인가 3판인가 다 이겼다. 확실히 집중이 잘 될 때 해야 잘 되는 거 같다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부를 너무 안 하고 있나... 주변 사람들이 공부 안 하게 만드는 힘이 있나 싶다. 이번 주는 열심히 했다. 그렇지만 남아서 뭔가 하긴 했는데 남는 게 있었나 싶어서 반성하는 중이다. 더 많이 남겨가기 위해 노력하자.\n- 안 그런 줄 알았는데 일주일 내내 남아 있으니 굉장히 피곤했다. 금요일 TIL을 일요일 새벽에 쓰고 있는 걸 보면 .. ㅎ 바로 잠들어 버려서 내용이 잘 기억 안 난다. 진짜 얼른 적어야 했는데 ㅠㅠ\n- 나를 탓하는 생각이 많이 줄었다. 뭔가 안 좋은 말을 들었을 때 '에휴 그러게 왜 그랬어' 이런 생각 많이 했는데 지금은 그런 생각이 잘 안 들어서 신기했다. 자존감이 높아지는 것 같다.\n- 말하는 것에 신경을 많이 못 썼다. 이번 주는 에너지가 많이 없어서 (체스도 그렇고 몸 상태도 그렇고) 그냥 머릿속으로 생각난 대로 날카롭게 말한 게 있는 거 같다. 이번 주 동안 상처받은 크루가 있을 수도 있다는 생각이 들었다 😂 다음 주부터는 신경써서 말하는 습관을 들여보자 👍\n- 금세 방학이 가까워졌다. 시간은 정말 빠르게 흐른다. 방학 때 뭘 할 지, 그 전까지 얼마나 시간을 알차게 보내야 할 지 고민이 된다. 지금까지 시간이 무의미했다는 건 아니다. 무엇보다 값진 시간이었다. 그래도 앞으로도 멋진 시간을 보내기 위해서는 제대로 계획해야 할 거다. 다음 주는 내 성장을 노리는(?) 시간이 되었으면 좋겠다."},{"excerpt":"LOG 체스 2단계까지 구현했다. 못할 거 같았는데 다 해서 다행이었다. 지금까지 안 했던 재입력도 구현했다. 오랜만이라 어떻게 했었는지 기억 안 났는데 루카가 잘 해줘서 좋았다. 주드, 리오, 채채, 포이, 체인저, 콩하나, 글렌, 그레이와 만났다. 지금까지 말 안 해본 크루들이랑 말해봐서 좋았다 ㅋㅋㅋ 그래서 다들 나이가 어떻게 돼...? 나 아직도 …","fields":{"slug":"/2023-03-16/"},"frontmatter":{"date":"2023년 03월 16일 15:03","title":"2023년 03월 16일","tags":null},"rawMarkdownBody":"## LOG\n- 체스 2단계까지 구현했다. 못할 거 같았는데 다 해서 다행이었다. 지금까지 안 했던 재입력도 구현했다. 오랜만이라 어떻게 했었는지 기억 안 났는데 루카가 잘 해줘서 좋았다.\n- 주드, 리오, 채채, 포이, 체인저, 콩하나, 글렌, 그레이와 만났다. 지금까지 말 안 해본 크루들이랑 말해봐서 좋았다 ㅋㅋㅋ 그래서 다들 나이가 어떻게 돼...? 나 아직도 모르겠어..\n- 말랑, 아마란스, 포이, 망고, 토리, 박스터랑 점심 먹었다. 찜닭 먹었는데 요즘 밥맛 없어서 많이 못 먹었다. 박스터가 맛있게 먹었다면 됐어... 박스터가 생일 기념으로 사줬다. 박스터 little hit~~ 이렇게 적는 거 맞지?\n- 드디어 훈수 없이 박스터랑 체스해서 이겼다 ㅋㅎㅋㅎㅋ 앞으로 좀 더 정진(?)해서 주드한테도 도전해야겠다.\n- 오늘 데일리 있었는데 내일 데일리 마스터로 내가 걸렸다... ㅋㅎ 내일 뭘 해야할까. 좀 재밌는 거 하고 싶다. 재밌는 게임 내일 지하철타고 가면서 생각 좀 해봐야겠다.\n\n## 배운 것\n- ```@FunctionalInterface```를 사용하면 커스텀 함수 인터페이스를 만들 수 있다. (루카와 나는 매개변수를 2개 입력받는 함수를 생성했다.)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 꾸준히 노력(?) 하면 된다. 사실 나는 내 노력을 안 믿는 편이다. 실제로 난 노력을 잘 안 하기 때문.. 다음 주 헤나, 후추, 포이랑 스터디 있는 거 준비하려면 학습 로그도 써야 한다. 잘 준비하고 발표 준비도 열심히 하자.\n- 아쉽게도 이리내가 발표한 테코톡은 보지 못했지만, 코코닥이 발표할 때쯤엔 페어 프로그래밍이 어느 정도 마무리 돼서 보러갈 수 있었다. 발표 안 떨고 잘 하는 게 멋지다고 생각했다. 코코닥 차례에 엄청 질문이 많았는데, 질문에 잘 대답하는 것도 신기했다. 역시 테코톡 하는 사람은 엄청 준비를 많이 해야 하는 구나...\n- 이번 미션 하는데 브라운이 잠깐(?) 조언 해주셨다. 우리가 어떻게 구현했는지 다시 생각해볼 수 있어서 좋았다. 지금 머리가 잘 안 돌아간다. 일단 PR 제출하고 내일 어떤지 봐야겠다. 너무 졸리다.\n"},{"excerpt":"LOG 포이랑 체스해서 이겼다. 사실 루카가 훈수둬주긴 했지만...ㅎ 근데 하면서도 내가 체스 진짜 못한다고 생각했다 ㅋㅋㅋ 10시까지 남아서 미션했다. 이번에 이야기를 많이 해서 그런가 둘다 꽤나 납득할만한 코드가 나온 거 같다. 내일 폰 동작, 말 움직이기, 리팩토링하려고 한다. 할 수 있겠지..?? 포이, 토리, 망고, 제리와 저녁 먹으러 갔다. 원…","fields":{"slug":"/2023-03-15/"},"frontmatter":{"date":"2023년 03월 15일 14:03","title":"2023년 03월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 포이랑 체스해서 이겼다. 사실 루카가 훈수둬주긴 했지만...ㅎ 근데 하면서도 내가 체스 진짜 못한다고 생각했다 ㅋㅋㅋ\n- 10시까지 남아서 미션했다. 이번에 이야기를 많이 해서 그런가 둘다 꽤나 납득할만한 코드가 나온 거 같다. 내일 폰 동작, 말 움직이기, 리팩토링하려고 한다. 할 수 있겠지..??\n- 포이, 토리, 망고, 제리와 저녁 먹으러 갔다. 원래 맥날 가기로 했는데 포이가 갑자기 춥다고 서브웨이 가자고 해서 서브웨이 갔다. 근데 오늘따라 먹기가 싫어서 한 20%는 남겼다. 아쉽.\n- 오늘 월급(?) 받았다. 좀 더 여유가 생겼다. 사실 돈 쓸 일이 그렇게 많지 않다. 점심 저녁, 교통비, 커피 이렇게만 돈 쓰는 거 같다. 어째 우테코 오기 전보다 덜 쓰는 듯.\n- 집 가서 박스터랑 체스 한 판 했는데 또 짐 ㅋㅋ 체스 너무 어렵다. 역시 그런 건 나랑 안 맞아. 심리 게임은 잘 할 자신 있는데 ㅋㅋ\n\n## 배운 것\n- Function<T, R>: T는 파라미터, 리턴값으로 R을 리턴한다.\n\n## 궁금한 것\n- 테스트할 때 .getClass()를 안 쓰고 어떻게 할까?\n- instanceof 를 안 쓰는 방법은 없을까?\n- 인터페이스는 어떨 때 쓰면 좋을까?\n\n## 어려웠던 것\n- 절대적인 시간이 부족해서 일단 구현부터 한 부분도 있는데, 이래도 되는걸까. 약간의 죄책감.\n\n## 느낀 것\n- 확실히 페어와 말을 놓고 나니 더 적극적으로 의견을 나눌 수 있었다. 초반에는 편하게 말하는 게 좀 어색했지만, 금방 편하게 말할 수 있게 됐다. 의견을 낼 때도 무겁게 질문하기보다는 가벼운 질문을 할 수 있어 좋았다. (무엇보다 다른 사람들과 반말할 때 헷갈리지 않아서 좋았다 ㅋㅋ 요즘 다른 사람들한테도 반말 나올 거 같다. 정신 똑바로 차리자)\n- 할 건 엄청 많았지만 미션 이야기는 많이 했다. 오늘 내내 미션 했으니.. 어제 생각했던 구조 괜찮아보였는데 이야기하다 보니 부족한 점이 보였다. 루카가 우려되는 점을 솔직하게 말해줘서 서로 조율하면서 고쳐갈 수 있어서 좋았다. 다음에 페어 회고 할 때 말해줘야겠다. TDD 해야 된다고 자주 말해줘서 까먹지 않고 TDD 할 수 있었다 👍\n- 일찍 나오고 늦게 가니까 컨디션이 쉽지 않다. 요즘엔 그냥 7시에 눈이 떠져서 더 자고 싶다.. 주말에 좀 더 자고 싶은데 주말에는 생일이라 그것도 안 될 것 같다.\n 그것도 안 될 것 같다.\n"},{"excerpt":"LOG 문득 포이랑 대화하다가 생각했는데 요즘 혼자 있는 시간이 없다. 오늘은 특히 페어 프로그래밍 해서 더 그렇긴 하지만 ㅋㅋ 혼자 있는 거 좋아하던 나로써는 자각 못 했던 게 신기했다. 많이 성장했구나! 박스터랑 체스 뒀다. 초보라면서 체스 왜 잘 둠? 2판 했는데 2판 다 졌다ㅋㅋㅋㅋㅋ 체스 못 두는 거 맞는 말 되어 버렸다. 앞으로 박스터랑 체스 …","fields":{"slug":"/2023-03-14/"},"frontmatter":{"date":"2023년 03월 14일 15:03","title":"2023년 03월 14일","tags":null},"rawMarkdownBody":"## LOG\n- 문득 포이랑 대화하다가 생각했는데 요즘 혼자 있는 시간이 없다. 오늘은 특히 페어 프로그래밍 해서 더 그렇긴 하지만 ㅋㅋ 혼자 있는 거 좋아하던 나로써는 자각 못 했던 게 신기했다. 많이 성장했구나!\n- 박스터랑 체스 뒀다. 초보라면서 체스 왜 잘 둠? 2판 했는데 2판 다 졌다ㅋㅋㅋㅋㅋ 체스 못 두는 거 맞는 말 되어 버렸다. 앞으로 박스터랑 체스 내기는 절대 안 해야겠다 ^^\n- 어제보다는 속이 괜찮았다. 배고픈데 음식이 잘 안 들어가는 게 화난다. 적게 먹으면 또 배고픈데 먹을 수가 없다ㅠ 뭐 어떻게 안 되나? 며칠째 이러고 있는건지 🥺\n- 루카와 페어가 되었다. 점심에 토도로끼 가서 쇼유라멘 매운 맛 먹었다. 분명 저번에 갔을 때는 별로 안 매웠던 거 같은데 오늘은 너무 매웠다 ㅋㅋㅋ 그래도 꽤 많이 먹었다. 이번 페어 때는 좀 더 편한 분위기에서 하기 위해서 밥도 먹고 아이스 브레이킹도 열심히 했다. 루카와 말 놓은 첫 크루가 되었다. 정말 기념비적인걸 :)\n- 후추, 헤나, 포이와 저녁을 먹었다. 저번에 갔던 엄마 밥상에 갔는데 1시간 걸려서 음식이 나와서 6시 반에 밥 먹으러 가서 8시에 나왔다.. 한 분 밖에 안 계셔서 많이 오래 걸린 것 같다. 사실 나는 별 상관 없었는데 페어랑 남아서 하는 사람이 많았어서 좀 미안했다. 후추와도 말을 놓았다. 약간 함부로 반말 해버릴까봐 (헤나랑은 반말해서 가끔 주변 사람들한테도 반말할까봐 의식적으로 조심했다) 걱정했는데 다행히 오늘 무사히 말을 놓게 돼서 다행이다.\n- 저녁에 돌아와서 오리, 헙크와 트리플 프로그래밍했다. 약간 다른 사람들 의견 듣는 거 재밌었는데, 들으면서 좋은 아이디어가 떠올라서 여러 명한테 설명해줬다. 그런데 지금 다시 생각해보니 좀 더 좋은 게 있을 거 같기도 하고...\n- ~~오늘 왜이렇게 LOG가 많을까~~\n\n## 배운 것\n- 페어 프로그래밍 하느라 배운 게 없어서 슬프다..\n\n## 궁금한 것\n- 포이가 쓰던 익스트랙팅\n- stream 왜 쓸까?\n- 병렬 스트림은 언제 쓸까?\n\n## 어려웠던 것\n- 휴식하지 않으면 말도 안 되는 소리가 필터링이 안 된다.\n\n## 느낀 것\n- 난 사람들과 이야기하면서 공부하는 게 맞는 거 같다... 혼자 있으면 절대 공부 안 한다. 그나마 요즘에는 오래 남아있어서 그런가 머릿속에 남는 게 많다. 그런데 늦게 집에 오면 많이 피곤해진다. 집에 올 때 쯤에 굉장히 피곤해져서 TIL 안 쓰고 자버릴까봐 걱정된다. 지금은 12시 53분. 내일 일어날 수 있겠지?\n- '우테코 전의 나와 달라지기' 미션은 매우 성공적인 것 같다. 진짜 다른 사람이 되어가고 있다. '진짜 나'가 변하고 있는 걸까, 아니면 '나'가 변하고 있는걸까? 아직 잘 모르겠다. 그런 건 모르더라도 요즘 집 밖에 있는 게 더 재밌다는 건 확실하다. 재밌게 즐기고 있다. 2월 초에 썼던 TIL 에서 긍정적인 영향을 받고 싶다고 썼던데, 엄청 긍정적인 영향을 받아서 기분이 좋다.\n- 체력적으로 좀 지친다는 생각을 했다. 요즘 밥도 잘 못 먹는데 오래 남아 있기도 해서 웃긴데 막 웃지 못하는 웃지 못할 일이 일어난다. 즐거운 건 나눠야 좋지. 나는 뭘 잘하나 생각해봤다. 일단 웃는거 하나는 잘하는 거 같다.\n- 많이 알아가지 않더라도, 어제의 나보다 더 많이 알자고 다짐했다. 남들과 비교하는 건 의미 없다. 그걸 깨달은 것만 해도 좋다. 이젠 존재하지 않는 허상을 쫓을 필요가 없다. 어제의 나라는 지표는 매우 구체적이니까. 그래서 부담이 덜하다.\n"},{"excerpt":"3/14 자바로 DB 다뤄보기 Java에서 JDBC 드라이버를 이용하여 DB와 연결하기 JDBC Java DataBase Connectivity 자바 애플리케이션에서 DB 프로그래밍을 할 수 있도록 도와주는 표준 인터페이스. 코드 option + command + F : 필드로 추출 3/17 람다와 스트림 자바에서 함수형으로 프로그래밍할 수 있게 도와주는…","fields":{"slug":"/level1-week6/"},"frontmatter":{"date":"2023년 03월 14일 02:03","title":"레벨1 6주차","tags":["레벨1","우테코"]},"rawMarkdownBody":"# 3/14\n\n## 자바로 DB 다뤄보기\nJava에서 JDBC 드라이버를 이용하여 DB와 연결하기\n\n### JDBC\n- Java DataBase Connectivity\n- 자바 애플리케이션에서 DB 프로그래밍을 할 수 있도록 도와주는 표준 인터페이스.\n\n### 코드\n\n```\nfinal UserDao userDao = new UserDao();\nfinal Connection connection = userDao.getConnection();\n\n```\n\n```\npublic final class UserDao {\n\tpublic Connection getConnection() {\n\ttry {\n\t\treturn DriverManager.getConnection(\n\t\t\t\"jbdc:mysql:localhost:13306/chess?useSSL=false&serverTimezone=UTC\",\n\t\t\t\"root\", \n\t\t\t\"root\"\n\t\t\t);\n\t\t} catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic void insert(final User user) {\n\t\tString sql = \"INSERT INTO user (user_id, name) VALUES (?, ?)\";\n\t\ttry (\n\t\tfinal Connection connection = getConection();\n\t\tfinal PreparedStatment preparedStatement = connection.prepareStatement(sql))\n\t\t{\n\t\t\tpreparedStatement.setString(1, user.userId());\n\t\t\tpreparedStatement.setString(2, user.name);\n\t\t\tpreparedStatement.executeUpdate();\n\t\t}\n\t\tcatch(final SQLException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t} \n\n\tpublic void findByUserId(final String userId) {\n\t\tString sql = \"SELECT * FROM user WHERE user_id = ?\";\n\t\ttry (\n\t\tfinal Connection connection = getConection();\n\t\tfinal PreparedStatment preparedStatement = connection.prepareStatement(sql))\n\t\t{\n\t\t\tpreparedStatement.setString(1, userId);\n\t\t\tfinal var resultSet = preparedStatement.executeQuery();\n\t\t\tif(resultSet.next()) {\n\t\t\t\treturn new User(\n\t\t\t\t\tresultSet.getString(\"user_id\"),\n\t\t\t\t\tresultSet.getString(\"name\")\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcatch(final SQLException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\n```\n\noption + command + F : 필드로 추출\n\n# 3/17\n\n## 람다와 스트림\n\n- 자바에서 함수형으로 프로그래밍할 수 있게 도와주는 도구\n- 함수형 프로그래밍? 작업을 어떻게 수행할 것인지, How에 집중한다.\n\n### 무엇에 집중할 것인가\n\n### 함수란 무엇인가\n\n같은 인수값으로 함수를 호출하면 항상 같은 값을 반환한다. (랜덤 요소 X. Scanner, Random)\n함수나 메서드는 지역 변수만을 변형해야 함수형이라 할 수 있다. 함수나 메서드에서 참조하는 객체가 있다면 해당 객체는 불변해야 한다.\n\n객체의 모든 필드가 final이어야 한다. \n모든 참조 필드는 불변 객체를 직접 참조한다.\n\n---\n메서드 내에서 생성한 객체의 필드는 갱신할 수 있으나, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 한다.\n다음에 메서드를 다시 호출한 결과에 영향을 미치지 않아야 한다.\n\n함수나 메서드가 어떤 예외도 일으키지 않아야 한다.\n\n### 멀티코어와 동시성 제어\n\n자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용을 기반으로 동시성 제어를 할 수 있다.\n\n### Stream API\n\n"},{"excerpt":"LOG 오늘 빨리 갔다. 아침에 바로 눈이 떠져서 20분 억지로 더 잤다. 마음에 드는 아우터가 있는데 화장 안 하면 못 입을 거 같아서 오랜만에 화장했다. 잘 돼서 아침부터 기분 좋았다. 속이 안 좋았다. 어제 저녁에도 밥을 남겼는데 점심에도 속이 안 좋았다. 불고기 백반 먹었는데 절반을 포이가 먹었다. 포이가 배불렀다면 됐어... 근데 여전히 속이 안…","fields":{"slug":"/2023-03-13/"},"frontmatter":{"date":"2023년 03월 13일 14:03","title":"2023년 03월 13일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘 빨리 갔다. 아침에 바로 눈이 떠져서 20분 억지로 더 잤다. 마음에 드는 아우터가 있는데 화장 안 하면 못 입을 거 같아서 오랜만에 화장했다. 잘 돼서 아침부터 기분 좋았다.\n- 속이 안 좋았다. 어제 저녁에도 밥을 남겼는데 점심에도 속이 안 좋았다. 불고기 백반 먹었는데 절반을 포이가 먹었다. 포이가 배불렀다면 됐어... 근데 여전히 속이 안 좋다.\n- 요즘 근데를 많이 쓴다. 모든 말이 근데부터 시작한다 ㅋㅋㅋㅋ 근데 그만 쓰려고 노력해야겠다.\n- 오늘은 헤나랑 얘기를 많이 했다. 학습 로그 말하기가 4시였는데 5시까지 말했다. 학습 로그 말하기 저번보다 잘 말한 것 같아서 좋다 ! 👍 저번보다 공부를 많이 하고 말해서 그런지, 말하기 전에 고민하는 시간이 많이 줄었다. 어.. 라고 말하는 빈도도 줄어서 좋았다. 나중에 학습 회고 말하기는 좀 더 예전부터 준비하고 만들어어야겠다. 너무 닥쳐서 만들다보니 시간이 없어서 예시를 많이 생략했는데 넣었어도 좋았을 거 같다.\n\n## 배운 것\n- IntUnaryOperator가 오토 박싱이 일어나지 않아서 성능이 좋다는 점을 알게 되었다.\n- POP, IMAP 키워드를 알게 되었다. 좀 더 알아보자.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 아침에 주노의 기술부채를 같이 확인하는 시간을 가졌는데 매우 유익했다. 오히려 같이 찾아보니 재밌었다. 혼자서 책 볼 때는 진짜 재미없었는데.\n- 내일 페어랑은 미리 친해지고 진행해 볼 생각이다. 페어만 괜찮다면 점심 같이 먹고... 아니면 말고... 😂 편한 자리에서 의견도 잘 나오고 질문도 잘 할 수 있으니까 좋다. 이번 방식은 잘 먹혔으면 좋겠다!\n- 데일리 때 2등했다! 주말에 줌으로 만나서 열심히 했던 보람이 있다 ㅋㅋㅋ 에코의 스티커를 받았다. AWS 스티커 매우 탐났는데 받아서 좋았다. 그런데 원래 노트북에 붙일 생각이었는데 맥북이라 못 붙이겠다ㅋㅋㅋ 어딘가에 잘 써먹어야겠다. 상품 협찬해주신 에코 감사합니다 🙇‍♀️\n"},{"excerpt":"그냥 좀 하자 '그냥'은 생각보다 어렵다 사실 '그냥'이 제일 어렵다.\n용기 없는 사람은 더욱 그렇다. 그러나 두려운 마음이 내 발목을 잡는 건 싫었다.\n주변에는 언제나 시작도 하지 않고 포기한 일들이 널브러져 있다. 마음속에 부채감으로 남아 있는 일들이다. 괜히 안 될 것 같으니까, 시작하는 것도 무서워서 주저하다 시도조차 하지 않았다. 재미있게도 시간…","fields":{"slug":"/level1-writing/"},"frontmatter":{"date":"2023년 03월 13일 11:03","title":"레벨1 글쓰기","tags":["레벨1","글쓰기","우테코"]},"rawMarkdownBody":"## 그냥 좀 하자\n\n### '그냥'은 생각보다 어렵다\n\n사실 '그냥'이 제일 어렵다. \n용기 없는 사람은 더욱 그렇다. 그러나 두려운 마음이 내 발목을 잡는 건 싫었다.\n주변에는 언제나 시작도 하지 않고 포기한 일들이 널브러져 있다. 마음속에 부채감으로 남아 있는 일들이다.\n\n괜히 안 될 것 같으니까, 시작하는 것도 무서워서 주저하다 시도조차 하지 않았다.\n\n재미있게도 시간이 지나고 나면 그때의 나를 이해하지 못하는 것은 현재의 나였다.\n그때 할 걸, 그거 한다고 죽는 것도 아닌데 좀 해보지... 언제나 후회했다.\n\n갈수록 나아지는 게 아니라 오히려 뒤로 가는 것 같았다. 잘했던 일도 자신감이 없어졌다.\n진짜 잘하고 있는 게 맞을까? 사실은 다 우연이나 운 아니었을까? \n부정적인 질문들은 끝이 없었다. \n\n그렇게 2년 간 슬럼프에 빠졌다.\n아무것도 하기 싫어서 개발도 반쯤 놓았다.\n배우는 걸 좋아했던 나는 더 이상 없었다.\n흥미도 없고, 잘할 자신도 없어서 재미없게 살았다.\n\n### 처음으로 '그냥' 해 본 것\n\n우아한테크코스에 지원한 것은 처음으로 상황을 따지지 않고 해 본 일이다.\n어느 날 예전에 봤던 공고가 기억나서 우연히 들어가 봤는데 지원자를 받고 있었다.\n갑자기 오기가 생겼다. 나도 물러서지 않고 '그냥' 해 보고 싶었다.\n\n지원할 시기가 중간고사 기간이었지만 자기소개서를 썼다.\n프리코스도 팀 프로젝트가 많아 시간이 없었지만 할 수 있는 만큼 했다.\n최종 코딩테스트 날도 시험 이틀 전이었지만 '그냥 해보는 거야. 괜찮아' 라고 생각하며 갔다.\n\n합격한 날에는 그저 신기했다. 진짜 그냥 하면 될 수도 있구나!\n결심했다. 다른 곳이라면 몰라도 우테코에서만큼은 잘하고 싶었다.\n\n### 그럼에도 '그냥' 주어지는 것은 없다\n\n우테코를 시작하기 전에, '이전의 나와 다른 사람이 되기'라는 목표를 세웠다. 슬럼프에서 벗어나 더 나은 사람이 되고 싶었으니까.\n\n그렇지만 첫 주는 생각보다 힘들었다. 역시 한 번에 바뀔 수는 없었다.\n\n그런 생각이 들었다.\n앞으로 비슷한 분야의 사람들을 이렇게 많이 만날 수 있을까? 분명 아니다.\n그런데도 지금까지 살던 대로 살고 있었다. 나서기 싫어하고, 먼저 다가가길 주저했다.\n10개월 뒤에도 예전과 같은 사람이기는 싫었다. 적어도 어제의 나보다는 나아져야 했다!\n\n완전 다른 사람으로 평생 사는 건 힘들지만 10개월 동안 바뀌는 건 쉽지 않을까?\n이번 기회에 시작하기 어려웠던 것들을 망설임 없이 도전해보자고 다짐했다.\n\n사람들에게 먼저 인사하고, 말을 걸었다. 주저하지 않고 말하는 방법을 연습했다.\n다들 말 걸기 전에는 무서운(?) 사람들인 줄 알았는데 전혀 아니었다.\n크루들과 하는 토론, 이야기, 뭐든 좋았다.\n지금은 크루들과 생활하는 게 정말 재밌다. 방학이 아쉬울 정도다.\n\n무엇보다 혼자 찾아보지 않고 다른 사람의 의견을 물어보게 된 것이 가장 큰 변화였다.\n여러 사람의 의견을 듣고 판단할 수 있는 사람이 되어 가고 있어 기쁘다.\n\n한 달이 지난 지금 돌아보면, 나는 언제나 어제의 나보다 나은 사람이 되어 있었다.\n\n### Just Do It!\n\n머릿속에서 맴도는 생각들을 하지 않으면 마음이 편해진다.\n\n```이해 안 되는데 다시 말해달라고 해도 되나?``` \n```그냥 말 걸어봐도 되나?```\n```굳이 물어볼 필요가 있을까? 이유가 있겠지...```\n\n그럴 땐 생각하지 않고 그냥 해보는 것도 좋았다.\n\n잘 모를 때는 크루에게 물어보면 된다.\n지금까지는 말 걸어서 싫어하는 크루는 못 봤다.\n오히려 다른 크루에게 질문하며 의견을 나누는 건 서로에게 도움이 됐다.\n\n그냥 해도 괜찮다.\n우테코에서는 가능하다.\n\n앞으로도 망설여질 때는 Just Do It.\n계속해서 어제의 나와 경쟁할 거다.\n안 될 것 없다. 할 수 있다 :)"},{"excerpt":"스터디 개요 레벨 인터뷰 대비 겸 Prolog 글도 좀 써보자 해서 만들어진 스터디 인원: 베로, 포이, 후추, 헤나, 말랑 Repository: GitHub 스터디 시간 월요일 8시 금요일 3시 진행 4명끼리 한 명씩 10분 방학에도 할 가능성 있음. 포맷 1단계 : 이 스터디 안에서 지금까지 안 한 주제를 선정해서(안 겹치게) 조사하고, 특정 요일 전…","fields":{"slug":"/study-rule/"},"frontmatter":{"date":"2023년 03월 13일 10:03","title":"베포후헤말 스터디 규칙","tags":["레벨1","우테코"]},"rawMarkdownBody":"\n## 스터디 개요\n\n- 레벨 인터뷰 대비 겸 [Prolog](https://prolog.techcourse.co.kr/) 글도 좀 써보자 해서 만들어진 스터디\n- 인원: 베로, 포이, 후추, 헤나, 말랑\n- Repository: [GitHub](https://github.com/woowacourse-study/2023-Prolog-RoadMap)\n\n## 스터디 시간\n\n- 월요일 8시\n- 금요일 3시\n\n## 진행\n\n- 4명끼리 한 명씩 10분\n- 방학에도 할 가능성 있음.\n\n### 포맷\n\n- 1단계 : 이 스터디 안에서 지금까지 안 한 주제를 선정해서(안 겹치게) 조사하고, 특정 요일 전에 글을 쓴다.\n- 2단계 : 다른 크루의 로드맵을 보고 질문할 내용을 정리한다. (명당 2-3개 질문 할당)\n- 3단계 : 스터디 당일 날 각자 해당 크루에게 질문을 한다.\n- 4단계 : 질문 시간이 끝나면 아주 짧은 시간도 좋으니 5분 정도 피드백을 한다.\n\n### 스터디\n- 들어온 질문에 대답할 때 20-30초 안에 끝낼 수 있는 정도의 내용 준비하기\n- 분량은 상관 없음. 10분 미만으로 발표하기.\n- 짧아도 되는데, 짧을 거면 확장된 질문에 대답할 수는 있어야 한다. \n- (좀 더 생각해보기) 꼬리 질문 대비\n\n## 스터디 글 모음\n\n- [[vepohuhemal-study-question|베포후헤말 스터디 질문]]\n- [[default-method|디폴트 메서드란?]]\n- [[functional-interface|함수형 인터페이스는 무엇이고, 람다와 어떤 관계가 있나요?]]\n- [[grasp|GRASP란 무엇인가요?]]"},{"excerpt":"LOG 힘이 나는 날은 아니었다. 그냥 좀 처지는 날이었는데 미션이랑 공부를 하면서 노래 들으니 기분이 좀 나아졌다. 유튜브 뮤직 알고리즘 굉장히 노래 추천 잘 해준다 ㅋㅋ 월요일 날 빨리 가기로 했다. 월요일은 집에도 늦게 갈 생각이다. 집에 가서 딱히 할 게 없기 때문... 늦게 집 가면 어떤 일이 일어날 지 관찰해봐야겠다. 분명 배는 고픈데 입맛이 …","fields":{"slug":"/2023-03-12/"},"frontmatter":{"date":"2023년 03월 12일 15:03","title":"2023년 03월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 힘이 나는 날은 아니었다. 그냥 좀 처지는 날이었는데 미션이랑 공부를 하면서 노래 들으니 기분이 좀 나아졌다. 유튜브 뮤직 알고리즘 굉장히 노래 추천 잘 해준다 ㅋㅋ\n- 월요일 날 빨리 가기로 했다. 월요일은 집에도 늦게 갈 생각이다. 집에 가서 딱히 할 게 없기 때문... 늦게 집 가면 어떤 일이 일어날 지 관찰해봐야겠다.\n- 분명 배는 고픈데 입맛이 없다. 저녁은 냉동 볶음밥이었는데 절반 먹고 남겼다. 늦게 먹고 띄엄띄엄 먹으면 진짜 먹기 싫어진다. 원치 않은 다이어트 식단(?) 되어 버렸다.\n\n## 배운 것\n- 상태 패턴이란? [[state-pattern|상태 패턴]]\n- 싱글턴 vs 정적 메서드 -> [[singleton-vs-static]]\n\n## 궁금한 것\n\n## 어려웠던 것\n- 학습 로그 적는거 진짜 어렵다. 그냥 의견 내기면 모르겠는데 정보 전달이니 꼼꼼히 조사하고 빈틈없이 준비해야해서 부담이 된다.\n\n## 느낀 것\n- 혼자 있어서 기분이 안 좋았던 건 아닌 것 같고, 집에만 있어서 딱히 웃을 일이 없어서 그런 것 같다. 사람과대면으로 이야기 하고 싶다.\n- 다시 날씨가 추워져서 옷을 따뜻하게 입어야 한다. 분명 저번주 금요일은 엄청 따뜻했는데.. 오늘 과외 갈 때 날씨가 너무 추워서 놀랐다.\n- 새싹교실 새싹들을 배정 받았다. 21학번 편입생 2명, 23학번 1명인데 일단 사람이 적은 건 마음에 든다. 문제는 실력 차이... 정도가 될 것 같다. 실력 차이가 나면 진도를 확 뺄 수도 없고 느리게 나갈 수도 없고 애매하다. 다음 주 토요일부터 하기로 했으니까 열심히 준비해보자!\n- 내가 너무 생각없이 놀고 있나라는 생각이 들었다. 뭔가 다들 열심히 하고 있고 나만 신난 느낌? 우테코에서 뭘 가져갈 지를 좀 더 깊게 생각해봐야겠다. 사람이라면 이대로 해도 될 것 같고, 실력이라면 공부에 더 집중해야겠지. 내가 해야 하는 것 말고, 지금은 내가 하고 싶은 걸 고르고 싶다. 이유는 딱히 없고 지금은 그냥 그러고 싶어서. 레벨2 때부터는 어떻게 될 지도 모르는 거니까.\n\n"},{"excerpt":"글을 쓰게 된 배경 망고가 1단계 블랙잭 미션을 리팩터링하다 나에게 질문했다. InputView를 static method를 갖는 util 클래스로 구현하는 것과 싱글턴으로 구현하는 것의 차이는 뭘까? 나는 그 질문에 명쾌하게 답하지 못했다.\n내 1단계 블랙잭 미션은  가 util 클래스로 구현되어 있었다. 딱히 이유가 있냐고 하면... 막연히 싱글턴 패…","fields":{"slug":"/singleton-vs-static/"},"frontmatter":{"date":"2023년 03월 12일 13:03","title":"singleton vs static class","tags":["우테코","레벨1","학습로그"]},"rawMarkdownBody":"\n## 글을 쓰게 된 배경\n\n망고가 1단계 블랙잭 미션을 리팩터링하다 나에게 질문했다.\n\n> InputView를 static method를 갖는 util 클래스로 구현하는 것과 싱글턴으로 구현하는 것의 차이는 뭘까?\n\n나는 그 질문에 명쾌하게 답하지 못했다.\n내 1단계 블랙잭 미션은 ```InputView``` 가 util 클래스로 구현되어 있었다. 딱히 이유가 있냐고 하면... 막연히 싱글턴 패턴이 안티 패턴이라고 해서 안 썼던 것 뿐이었다. \n\n나중에 비슷한 구현을 하게 될 때 둘 중에 어떤 걸 쓸 지 결정하기 위해 이 글을 썼다.\n\n## Singleton(싱글턴) 패턴\n\n위키 백과에서는 다음과 같이 정의한다.\n\n> [소프트웨어 디자인 패턴](https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4)에서 **싱글턴 패턴**(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 **싱글턴 패턴**이라고 한다.\n\n즉, 싱글턴 패턴이란 단 하나의 인스턴스만 생성하여 사용하는 디자인 패턴이다.\n\n가장 간단한 싱글턴 예제는 다음과 같다. \n\n```\npublic class Singleton() {\n\t// Singleton 객체를 static으로 선언한다.\n\tprivate static Singleton instance;\n\n\t// 생성자를 private으로 선언한다.\n\tprivate Singleton() {}\n\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tthis.instance = new Singelton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n생성자를 private으로 선언하여 외부에서 객체를 생성하지 못하도록 막는다.\n객체를 생성할 수 없지만, 정적 팩토리 메서드를 통해 인스턴스를 전달받을 수 있다.\n\n그렇지만 문제가 일어날 수 있는 부분은 너무나도 잘 보인다. 바로 동시성 문제다!\n\n멀티스레드 환경에서는 두 개 이상의 스레드가 ```getInstance()```를 수행하는 경우 두 개 이상의 인스턴스가 생성되는 문제가 생길 수 있다.\n\n```\npublic class Main {  \n    public static void main(String[] args) {  \n        Runnable runnable = () -> {  \n            Singleton singleton = Singleton.getInstance();\n            System.out.println(singleton.hashCode());  // hashcode 출력\n        };  \n  \n        for(int i = 0; i<10; i++) {  \n            Thread thread = new Thread(runnable);  \n            thread.start();  \n        }  \n    }\n}\n```\n\n```\n결과\n1448770673\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n```\n\n분명 싱글턴이라고 했는데 hashcode가 다르다. 왜일까?\n\n이유는 모든 스레드가 동시에 도착하여 객체가 생성되지 않은 null 임을 확인하게 되기 때문이다. 스레드가 도착했을 때 instance가 null 이므로 스레드들이 계속해서 객체를 생성하게 되는 것이다.\n\n동시성을 보장할 때 가장 자주 사용되는 방법은 Holder initialization 방법이다.\n\n```\npublic class Singleton {  \n    private Singleton() {}  \n  \n    public static Singleton getInstance() {  \n        return LazyHolder.INSTANCE;  \n    }  \n  \n    private static class LazyHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n}\n```\n\nholder 안에 선언된 instance가 static 이기 때문에 클래스 로딩 시점에 한 번만 호출된다는 것을 이용한다. 클래스 로딩 시에는 thread-safe가 보장되기 때문에 객체가 단 한 번만 생성된다.\n\n## 정적 메서드 (static method)\n\n정적 메서드는 클래스의 인스턴스 없이 호출이 가능한 메서드이다.\n\n```\npublic static void printValue(final String value) {\n\tSystem.out.println(value);\n}\n```\n\n클래스의 인스턴스가 아닌 클래스와 연결되므로 힙의 Permanent Generation 영역에 저장된다.\n\n\n## 싱글턴 vs 정적 메서드\n\n드디어 본론이다. 그래서 뭘 쓰는 게 좋다는 걸까?\n\n### 싱글턴 장점\n\n- 런타임 다형성을 활용할 수 있다.\n- 인터페이스를 구현할 수 있다.\n- 객체로 존재하므로 싱글턴을 매개변수로 다른 메서드에 전달할 수 있다.\n\n### 싱글턴 단점\n\n- 너무 많은 일을 위임하거나 공유하는 경우 coupling이 많아지고 결합도가 높아진다. 결합도가 높아짐에 따라 수정이 어려워지고 테스트하기 어려워진다.\n- 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖게 되어 안정성이 떨어진다.\n\n### 정적 메서드의 장점\n\n- 매번 인스턴스를 생성하기 위해 생성자를 호출하지 않아도 되므로 낭비되는 메모리를 줄일 수 있다.\n- 객체를 생성하지 않고 사용 가능하기 때문에 속도가 빠르다.\n\n### 정적 메서드의 단점\n\n- static을 사용하게 되면 프로그램 시작부터 끝까지 메모리에 할당된 채로 남아있다. static 영역은 Garbage Collector의 관리를 받지 않기 때문에 프로그램이 종료될 때까지 메모리에 존재하게 된다.\n- 오버라이드가 불가능하며, 객체와 관련이 없기 때문에 절차지향적 성향이 강하다고 볼 수 있다. 무분별한 사용이 객체 지향을 해칠 수 있다.\n\n## 결론\n\n**주관적인 결론**\n\n싱글턴은 단 하나의 클래스 인스턴스만 필요하고, 모든 곳에서 동일한 상태를 유지하고 싶은 경우 사용한다. 이후 클래스 확장을 통한 메서드 재정의가 필요한 경우에 사용한다.\n\n정적 클래스는 mocking 하기 어렵기 때문에 테스트가 어렵지만, 싱글톤은 mocking 하는 것이 쉽기 때문에 테스트 작성이 용이하다.\n\n그러나 정적 메서드는 내부 상태를 변경할 필요가 없고, 매개 변수에 대해서만 작동한다면 정적 메서드를 사용할 수 있다. 또한 다형성이 필요 없고 앞으로 객체 지향을 적용할 필요가 없을 때도 사용 가능하다.\n메서드에 대한 전역 접근만 제공하는 경우, 정적 클래스를 사용하는 것을 고려해볼 수 있다.\n\n지금까지의 미션들은 이후 view가 콘솔이 아닌 다른 것으로 변경될 수 있으므로 변경이 용이해야 한다. 얼마든지 추가적인 확장이 생길 수 있으므로 미션에서는 싱글턴을 사용하는 것이 좋을 듯 하다.\n\n## 참고 자료\n\n- https://tecoble.techcourse.co.kr/post/2020-11-07-singleton/\n- https://tecoble.techcourse.co.kr/post/2020-07-16-static-method/\n- https://javarevisited.blogspot.com/2013/03/difference-between-singleton-pattern-vs-static-class-java.html#axzz7vkYkDfOH"},{"excerpt":"상태 패턴이란? 상태 패턴을 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다. 직접 상태를 체크하여 상태에 따른 행위를 호출하는 것이 아닌 상태를 객체화하여 필요에 따라 다르게 행동하도록 위임한다. 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다. 구성을 이용하여 코드 내의 조건문들을 대체한다. 상태 패턴 vs 전략 패…","fields":{"slug":"/state-pattern/"},"frontmatter":{"date":"2023년 03월 10일 02:03","title":"상태 패턴","tags":["디자인패턴","우테코","레벨1"]},"rawMarkdownBody":"\n## 상태 패턴이란?\n\n- 상태 패턴을 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다.\n- 직접 상태를 체크하여 상태에 따른 행위를 호출하는 것이 아닌 상태를 객체화하여 필요에 따라 다르게 행동하도록 위임한다.\n- 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다.\n- 구성을 이용하여 코드 내의 조건문들을 대체한다.\n\n## 상태 패턴 vs 전략 패턴\n\n- 상태 패턴: 상태 객체에 일련의 행동이 캡슐화된다. Context 객체에서 여러 상태 객체 중 한 객체에게 모든 행동을 맡기게 된다. 객체의 내부 상태에 따라 현재 상태를 나타내는 객체가 바뀌고, 클라이언트는 상태 객체를 몰라도 된다.\n- 전략 패턴: 클라이언트가 Context 객체에게 어떤 전략 객체를 사용할지 지정해준다. 서브 클래스를 만드는 방법을 대신하여 유연성을 극대화하는 용도로 사용된다.\n\n### 참고 사항\n\n- State에 해당하는 클래스를 디자인할 때는 인터페이스 대신 추상 클래스 사용도 생각해보면 좋다. 구상 상태 클래스를 건드리지 않고 추상 클래스에 메소드에 추가하면 되기 때문이다.\n\n## 장단점\n\n### 장점\n\n- 새로운 상태가 추가되더라도 Context의 코드가 받는 영향이 최소화된다.\n- 클래스를 추가하더라도 기존의 메서드 코드는 그대로 유지된다.\n- 상태별 동작을 수정하기 쉽다.\n- 조건문이 줄어들어 코드가 간결해지고 가독성이 올라간다.\n\n### 단점\n\n- 상태에 따른 조건문을 대신한 상태 객체가 증가하여 관리해야 할 클래스의 수가 증가한다.\n\n## 참고 자료\n\n- 헤드 퍼스트 디자인 패턴 Ch.10\n- [tecoble](https://tecoble.techcourse.co.kr/post/2021-04-26-state-pattern/)"},{"excerpt":"LOG 박스터에게 말 걸어보기 레벨1 히든 미션 달성했다. 근데 이야기 시작하게 되자마자 바로 말을 놔버렸다..ㅋㅋㅋ 오히려 좋아. 예전부터 얘기할 각을 열심히 쟀는데 잘 돼서 뿌듯하다(?) 박스터가 젤리 사줘서 맛있게 먹었다. 끝날 때쯤에 네오와 저번에 했던 그리스 로마 신화 이야기했다. 재밌게 들어주셔서 나도 얘기하면서 재밌었다 ㅋㅋ 하마드 코드 보면…","fields":{"slug":"/2023-03-10/"},"frontmatter":{"date":"2023년 03월 10일 02:03","title":"2023년 03월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 박스터에게 말 걸어보기 레벨1 히든 미션 달성했다. 근데 이야기 시작하게 되자마자 바로 말을 놔버렸다..ㅋㅋㅋ 오히려 좋아. 예전부터 얘기할 각을 열심히 쟀는데 잘 돼서 뿌듯하다(?) 박스터가 젤리 사줘서 맛있게 먹었다.\n- 끝날 때쯤에 네오와 저번에 했던 그리스 로마 신화 이야기했다. 재밌게 들어주셔서 나도 얘기하면서 재밌었다 ㅋㅋ\n- 하마드 코드 보면서 하마드랑 이야기했다. 내 의견이 하마드한테 도움이 되어서 기뻤다 😄 코드 리뷰하는 거 재밌다.\n- 헤나가 고민하고 있는 부분에 대해서 허브, 글렌이랑 같이 생각해봤다. 헤나는 view의 함수 메서드가 도메인까지 흘러들어가는 것을 걱정하고 있으면서도 테스트하기 힘든 BlackJack에 중요한 도메인 로직이 있다는 것에 불편함을 느낀 것 같았다. 나도 헤나처럼 함수를 매개변수로 넘긴 케이스라 공감이 됐다. 나는 도메인까지 함수 인터페이스가 흘러가는 건 아닌 것 같아서 그대로 유지할 것 같다고 했다. 나중에 헤나가 어떻게 고쳤는지 봐야겠다.\n- 데일리 때 쥬니가 불러주는 년도에 어떤 걸 했는지 말하는 게임을 했다. 알게모르게 다른 사람들의 나이를 알아버렸다 ㅋㅋㅋ 데일리가 재밌어서 아침을 즐겁게 시작할 수 있는 것 같다.\n\n## 배운 것\n- 네오가 강의에서 한 내용은 상태 패턴에 대한 이야기 같다. -> [[state-pattern|상태 패턴]]\n- IntUnaryOperator\n- Fixture: 테스트 실행을 위한 베이스라인으로 사용되는 객체들의 **고정된 상태**\n- 메서드에 final: 하위 클래스가 메서드를 오버라이딩 할 수 없게 한다.\n- 패키지에서만 사용한다는 확신이 든다면 접근 제어자를 default로 설정해서 외부에서 만들 수 없도록 한다.\n- assertThat(Double).isEqualTo를 사용하면 부동 소수점 때문에 제대로 계산이 되지 않을 수도 있어서 isCloseTo를 사용하는 것이 좋다.\n\n## 궁금한 것\n- 상속이 안 좋은 이유가 있긴 하지만 조합이 그만큼 좋은지는 모르겠다. 여러 사람의 의견을 들어봤지만 확실하게 와닿는 게 없어서 아직은 알쏭달쏭한 상태다. 이번 미션 제출할 때 다니에게 물어봐야겠다.\n\n## 어려웠던 것\n- 글을 써보자! 하고 이펙티브 자바 읽으려고 했는데 다른 사람들과 이야기 하느라 결국 못 썼다.. 이럴거면 그냥 캠퍼스에서는 이야기를 많이 듣고, 집와서 해야 되나 싶다. 아직 레벨1이라 이런 고민도 할 수 있는 것 같다. 나중 가면 다들 바빠서 이야기 못할지도.. 오히려 지금 더 즐겨야겠다 ㅋㅋㅋ \n\n## 느낀 것\n- 이야기 하는 거 별로인 것 같았는데 구현하다보니 예전에 크루들이랑 이야기하고 고민했던 부분이 나와서 오히려 이렇게 의견 많이 들어보는 것도 좋은 듯 하다. 앞으로도 더 열심히 궁금해 하자.\n- 사실 금요일 TIL이 아니라 일요일에 적고 있다 ㅋㅋㅋ 금요일에 쓰고 자려고 했는데 역시나 너무 졸려서 그냥 자버렸다 ㅠㅠ 다음 주는 또 노력해보자.\n- 날씨가 따뜻해서 좋았다. 그렇지만 다음 주부터는 다시 추워져서 패딩을 입어야 할 거 같다. 얼른 얇은 옷을 입고 싶다. 캠퍼스는 여전히 더워서 반팔을 입고 갔었는데 시원하고 좋았다. 에어컨 틀기 전까지는 반팔을 안에 입고 가야겠다.\n- 벌써 방학이 얼마 안 남았다. 지금은 아쉽다는 생각이 드는 걸 보니 잘... 하고 있을지도...? 레벨1도 레벨 인터뷰가 있나? 좀 긴장된다.\n\n"},{"excerpt":"LOG 브라운과 커피챗 했다. 상담, 코칭 둘 다 딱히 할 게 없어서 커피챗을 골랐다. 스타벅스에 가서 커피 마시면서 이야기를 했다. 예전의 나였다면 들어보지 못했을 이야기를 듣게 되어서 많이 놀라웠다. 아직 적응하기 힘들어 하시는 분들에 비해 나는 적응을 잘한 편인 것 같다. 주간 회고 모임 조원들과 오프라인으로 만났다. 프론트엔드가 몇 분 더 있을 줄…","fields":{"slug":"/2023-03-09/"},"frontmatter":{"date":"2023년 03월 09일 05:03","title":"2023년 03월 09일","tags":null},"rawMarkdownBody":"## LOG\n- 브라운과 커피챗 했다. 상담, 코칭 둘 다 딱히 할 게 없어서 커피챗을 골랐다. 스타벅스에 가서 커피 마시면서 이야기를 했다. 예전의 나였다면 들어보지 못했을 이야기를 듣게 되어서 많이 놀라웠다. 아직 적응하기 힘들어 하시는 분들에 비해 나는 적응을 잘한 편인 것 같다.\n- 주간 회고 모임 조원들과 오프라인으로 만났다. 프론트엔드가 몇 분 더 있을 줄 알았는데 요술토끼만 프론트엔드 분이셨다. 요술토끼가 우아한테크코스 백준 단체를 만들었다고 해서 나도 들어가고 싶어졌다.\n- 블랙잭 1단계 코드 리뷰 요청을 다시 보냈다. 머지가 되어야 2단계를 진행할텐데 걱정이 많았다. 포이의 설계를 같이 보면서 머지된 후에 어떻게 구현할 지 대략적으로 생각해봤다. 그거랑은 별개긴 한데 오리랑 포이랑 한 1시간 정도 같이 2단계 미션 생각했는데 너무 웃겼다 ㅋㅋㅋ 2단계 진행에 대한 힌트도 얻어서 재밌기도 했지만 유익했다 👍\n- 어제 체인저와 공부했던 머메이드 강의?를 진행했다. 내가 생각한 건 6명 정도의 작은 규모 강의였지만 사람이 10명 넘게 왔었다. 막상 해보니 많은 것도 좋았다. (체인저 내가 칭찬 안 해줘서 슬퍼하는 거 아니지? 🥺 발표 안 떨고 잘했음 👍) 이런 강의를 여러 번 주도해보면서 다른 사람들도 정보를 좀 더 쉽게 공유할 수 있는 방향으로 바뀌었으면 좋겠다. 개인적으로 지금까지는 친한 사이에서 알음알음 전해지는 지식들이 많아서 아쉬웠다. 다른 사람들도 쉽게 공유할 수 있는 환경이 있으면 좋지 않을까 한다.\n\n## 배운 것\n- ```@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)``` : 언더바로 표시한 모든 부분이 공백으로 처리된다.  \n- mermaid 강의 자료 [노션 링크](https://bloom-okapi-d38.notion.site/Mermaid-0cbc5813e77f40dc8e3788a888f31c44)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부할 때는 공부하고, 이야기할 때는 이야기 하는 방식으로 해보는 건 어떤지 브라운이 의견을 내주셨다. 하나에만 집중하고 이것만 소중하다! 라고 생각하기보다는 적절하게 시간을 나눠서 쓰는게 내 생각에도 더 좋아보인다. 내가 잘하고 있다고 칭찬해주셔서 감사했다. 그렇지만 브라운과 이야기할 때도 내 말이 정리가 안 되는게 느껴졌다... ㅎ 할 말을 머릿속으로 생각해보고 말하는 연습을 하자.\n- 내가 할 수 있는 범위 내에서 할 수 있는 것을 다 하자. 우테코를 다시 할 수는 없듯이, 지나간 우테코의 시간은 다시는 돌아오지 않을 것이다. 그러니 후회없이 하고 싶은 걸 하고, 두려움 없이 나아가자. 10개월 동안 다른 사람이 되어보는건 남은 인생에서 내가 바뀌는 것보다는 쉽지 않을까? 나는 벌써 내가 달라지고 있는 걸 느꼈다. 내가 상상한 더 나은 사람이 되고 싶다. 지금이라면 할 수 있을 것 같다!\n- 편해질수록 말을 조심하자. 항상 말해놓고 후회할 때가 있다. 너무 오바하지 말고 가끔은 침묵이 나을 때도 있는 것 같다.\n- 어제 밥을 늦게 먹었는데 오히려 아침에 배가 더 고팠다. 요즘 잠도 많아졌다. 왜지? 딱히 피곤할 일이 있는 것도 아닌데 희한하다. 과외는 주말에만 하니 평일에 피곤할 일이 거의 없는데.\n- 우테코 시작한 지 벌써 1달이 지났다. 정말 내가 1달간 TIL을 꾸준히 썼다는 게 믿기지 않는다. 저번주 회고에 썼듯이 내일 금요일 회고는 꼭 쓰고 자야겠다. 점점 많은 사람들에게 내 블로그가 알려져서 좀 쉽지 않지만 ㅋㅋㅋ 관심 오히려 좋아 👀  많은 관심 부탁합니다 ^~^\n"},{"excerpt":"LOG 블랙캣과 점심을 먹었다. 역시나 신천 직화ㅋㅋ 페어 미션 재밌다. 재밌는 주제 생각해준 이리내 👍 오늘 아침에도 소파 옆쪽 자리(?)가 있어서 한 번 앉아봤다. 확실히 굿샷보다는 낫긴 한데 포이가 앉은 것처럼 의자에 앉는게 훨씬 좋은 것 같기도. 왠지 모르게 오늘 브라운과 자주 마주쳤다. 브라운한테 합성과 연관의 차이점에 대해서 물어봤다. 나랑 체…","fields":{"slug":"/2023-03-08/"},"frontmatter":{"date":"2023년 03월 08일 15:03","title":"2023년 03월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 블랙캣과 점심을 먹었다. 역시나 신천 직화ㅋㅋ 페어 미션 재밌다. 재밌는 주제 생각해준 이리내 👍\n- 오늘 아침에도 소파 옆쪽 자리(?)가 있어서 한 번 앉아봤다. 확실히 굿샷보다는 낫긴 한데 포이가 앉은 것처럼 의자에 앉는게 훨씬 좋은 것 같기도.\n- 왠지 모르게 오늘 브라운과 자주 마주쳤다. 브라운한테 합성과 연관의 차이점에 대해서 물어봤다. 나랑 체인저가 내린 결론은 연관의 특수한 경우가 합성이라는 것. 집합과 합성의 차이점을 확실하게 알게 되었다.\n- 체인저, 포이와 함께 머메이드를 배웠다. 미션에서 써먹어보려고 배웠는데 클래스 다이어그램까지는 투머치인 듯 하다. 너무 자세하니 오히려 눈에 더 안 들어왔다.\n\n## 배운 것\n- 집합은 외부에서 생성해서 주입해주는 것. 값을 외부에서 생성하므로 해당 클래스와 라이프 타임이 같지 않을 수도 있다. (외부에서 전달된 값은 복사되어 전달되기 때문에 클래스의 라이프 타임이 끝나더라도 외부의 객체는 라이프 타임이 남아있을 수 있다.)\n- 합성은 내부에서 값을 생성하는 것. 값을 내부에서 생성하기 때문에 클래스와 라이프 타임을 공유한다.\n\n## 궁금한 것\n\n## 어려웠던 것\n- 요즘 사람들과 이야기하는 게 재밌어서 혼자 공부를 많이 안 했다 🥺 미션 구현도 생각보다 좀 더 걸렸고, 2단계 미션도 아직 어떻게 구현할 지 생각하지 않은 상태라 분발해야 한다.\n\n## 느낀 것\n- 우테코 초반에 비해 새로운 사람을 만났을 때 하는 말의 주제가 늘어난 것 같다. 오늘 체험을 하게 되었는데, 성장했다는 생각에 조금 기분이 좋았다.\n- 헤나에게 알려 준 데일리 미션 뭔가 잘 된 것 같아서 기분이 좋았다.\n- 레벨2 부터는 좀 더 오래 남아있어야겠다. 집에 가면 공부를 안 하니까 ㅠ 내가 공부만 했더라면 그냥 집에 빨리 갔을텐데 침대는 강력했다.\n- 잡담이 경쟁력이다.. 라는 말을 어제 봤는데, 가끔 그 말을 느낄 때가 있다. 갑자기 불쑥 개발 이야기가 나올 때도 있고, 친밀한 관계에서 더 질문을 많이 하게 되니까 대화 하기 수월하다.\n- 요즘 사람들과 말을 많이 놓고 있는데 이거 괜찮은 건가 싶다 ㅋㅋㅋ 말을 놓는 순간 편해져서 실수할까봐 걱정되긴 한다. 항상 동갑들과 어울리다보니 가끔 '야'라는 말이 나올 때가 있어서 진짜 식겁한다... 조심해야겠다.\n- 집중력을 어떻게 하면 올릴 수 있을까. 열심히 공부하는 다른 사람 옆에 있으면 잘하는데 나를 풀어두니 너무 노는 것 같다 ㅋㅎㅋㅎ.. 좋은 공부 환경 조성을 위해 노력해보자.\n"},{"excerpt":"LOG 요즘 집중이 잘 안 된다. 오늘은 중간에 구현하다가 뛰쳐나왔다. 굿샷은 덥기도 했고.. 집중 좀 잘해보자. 브라운, 포이, 쥬니와 점심을 같이 먹었다. 연어 식당에 갔는데, 와사비를 빼고 먹기를 잘한 것 같다. 브라운이 스타트업 관련 이야기를 많이 해주셨는데, 매우 느끼는 점이 많았다. 배운 것 이 코드를 사용하면 String의 값에 따라 정렬되고…","fields":{"slug":"/2023-03-07/"},"frontmatter":{"date":"2023년 03월 07일 15:03","title":"2023년 03월 07일","tags":null},"rawMarkdownBody":"## LOG\n- 요즘 집중이 잘 안 된다. 오늘은 중간에 구현하다가 뛰쳐나왔다. 굿샷은 덥기도 했고.. 집중 좀 잘해보자.\n- 브라운, 포이, 쥬니와 점심을 같이 먹었다. 연어 식당에 갔는데, 와사비를 빼고 먹기를 잘한 것 같다. 브라운이 스타트업 관련 이야기를 많이 해주셨는데, 매우 느끼는 점이 많았다.\n\n## 배운 것\n```\nMap<String, Long> results = gameResults.stream()\n                     .collect(Collectors.groupingBy(String::valueOf, Collectors.counting()));\n```\n- 이 코드를 사용하면 String의 값에 따라 정렬되고, 값의 개수를 자동으로 세어준다. stream 좋아...\n- ```Consumer<T>``` T 하나를 매개변수로 받는 함수형 인터페이스를 전달할 수 있다. ```function.accept(매개변수)```를 사용해서 함수를 실행한다.\n- ```Predicate<T>``` T 하나를 입력 받아 boolean을 리턴하는 함수형 인터페이스를 전달할 수 있다. ```function.test(매개변수)```로 함수를 실행한다.\n- 유사한 사업 아이디어는 다른 유사 서비스의 디테일과는 다른 디테일을 중심으로 만들어나가는 것이 좋다 by 브라운\n- 스타트업에는 생각보다 필요한 프로세스가 많다. 대기업에서 프로세스를 경험해보고 스타트업에 적용하면 더욱 좋다.\n- 내가 만드는 소프트웨어에 나를 투영하지 말자. 비판을 수용하기 어려워질 수 있다.\n- ```<T extends Number> functionName(SimpleList<T> list)```의 매개변수는 명시적으로 선언되어 있기 때문에 이렇게 써도 가능하다. 그러나 ```<T> functionName(SimpleList<T extends Number> list)```는 리턴 값이 모호하다? (갑자기 쓰다보니 이해 안 됨) \n\n## 궁금한 것\n- 상속은 필요악일까? 조합이 더 좋다고는 하지만 나는 실제로 변화가 일어났을 때 전파될 필요가 있는 경우에는 상속을 해주는 게 좋은 것 같아서 잘 모르겠다.\n- dto 내부에서 ```List<dto>``` 쓰는 거 진짜 괜찮은걸까?\n\n## 어려웠던 것\n- 무의식적으로 공감하기 좀 자제하는 중인데 잘 안 된다. 내가 생각해도 가끔 성의 없는 공감을 해주는 편인데, 그런 건 차라리 안 하느니만 못하다.\n\n## 느낀 것\n- 확실히 현직자와의 커피챗은 뭔가 다르구나 싶다. 얻어가는 인사이트도 많았고, 뜬금없이 나온 이야기였는데 너무 재밌게 들었다.\n- 내가 말하면서 진짜 생각이 정리가 안 된다. 머릿속에서는 논리가 이미 있는데 말로 하면 안 나온다.. 나도 생각을 정리하면서 말하는 습관을 들여봐야겠다.\n- 지금은 늦게 가지 않고 있다. 지칠 것 같기도 하고, 다음 날을 위해서 오늘에 최선을 다하는 게 더 좋다고 생각해서 그렇다. 그런데 오늘은 최선을 다한 것 같지 않아서 좀 하루를 날린 기분이다. 내일은 꼭 열심히 해야겠다.\n- 커버할 수 있는 사람들의 수가 한정적이라는 생각을 했다. 아침에 아는 사람들과 이야기 했는데 분명 9시 10분에 도착했는데 이야기 나누고 나니 50분이 되었다... 이야기에서 얻는 인사이트도 있지만 내 일을 할 때는 좀 집중하기도 해야 하는데. 어느 정도 밸런스를 맞출 필요가 있다는 생각이 든다. 중요한 건 나의 성장이니까. 모든 사람들과 이야기 하고 싶었지만 내 몸이 하나라 한 주제에 대해 진득하게 이야기할 수 없었던 건 많이 아쉬웠다. 이렇게 많은 사람들을 알게 되었지만 내가 처리할 수 있는 건 얼마 안 된다는 게 좀 슬프기도 했다. 동시에 내가 이런 고민도 하게 되는구나, 라는 생각도 들었다. 요즘에는 사람을 만나는 게 재밌다. 먼저 말 거는 거에 맛들렸다 ㅋㅋㅋ 그게 잘 안 되는 사람도 있어서 좀 더 노력해보려고 한다.\n"},{"excerpt":"3/7 좋은 객체의 덕목 읽어보기 좋은 객체 상속과 조합 상속 객체 사이의 관계를 너무 복잡하게 만들기도 하지만 근본적인 원인은 상속 자체가 아니다. 가상 메서드 (virtual method) 클래스와 메서드를 이나  둘 중 하나로 제한하면 문제가 발생할 가능성을 없앨 수 있다. 상위 클래스가 final이라면 상속이 불가능하다. 상위 클래스의 내부 구현이…","fields":{"slug":"/level1-week5/"},"frontmatter":{"date":"2023년 03월 07일 01:03","title":"레벨1 5주차","tags":["레벨1","우테코"]},"rawMarkdownBody":"# 3/7\n\n## 좋은 객체의 덕목\n- 읽어보기 [좋은 객체](https://codingnuri.com/seven-virtues-of-good-object/)\n\n## 상속과 조합\n\n### 상속\n- 객체 사이의 관계를 너무 복잡하게 만들기도 하지만 근본적인 원인은 상속 자체가 아니다.\n\n#### 가상 메서드 (virtual method)\n- 클래스와 메서드를 ```final```이나 ```abstract``` 둘 중 하나로 제한하면 문제가 발생할 가능성을 없앨 수 있다. 상위 클래스가 final이라면 상속이 불가능하다.\n- 상위 클래스의 내부 구현이 달라지면 하위 클래스가 오동작할 수 있다.\n\n### 조합\n- 새로운 클래스를 만들고 기존 클래스의 인스턴스를 참조하게 하는 것\n- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. (is-a 관계)\n- 상속이 적절한 경우: 확장이 아닌, 정제를 하는 경우\n  - 확장: 새로운 행동을 덧붙여 기존의 행동을 부분적으로 보완하는 것\n  - 정제: 부분적으로 불완전한 행동을 완전하게 만드는 것\n\n## 실패 원자성\n- 호출된 메서드가 실패하더라도 호출된 메서드의 객체는 메서드 호출 전 상태를 유지해야 한다.\n- 예외가 발생하더라도 객체의 일관성이 유지되어 정상적으로 사용 가능한 상태를 유지한다.\n- 불변 객체의 특성상 원본 객체와 같은 새로운 객체를 생성하는 방법을 사용하기는 힘들다. 그러나 복구하기 힘든 예외가 발생한 경우에, 원본 객체가 불안정한 상태에 빠지는 경우는 없다.\n- 망가진 객체는 더 이상 정상적으로 사용할 수 없다. 예외를 잘 처리해도 이미 객체 내부의 값이 바뀐 경우는 재앙이 된다.\n\n## 시간적 결합\n> 메서드 A는 언제나 반드시 메서드 B보다 먼저 호출해야 한다.\n\n- 이런 방식은 유연하지 않고, 현실적이지 않다.\n- 순서에 의존하지 않는 동시성을 보장할 프로그램을 만들어야 한다.\n- 시간적 결합이 없는 작업들은 동시에 처리될 수 있다. 따라서 다양한 설계에 대한 측면을 바라볼 수 있게 된다.\n\n## 가변 객체와 불변 객체\n- 모든 클래스를 상태를 변경할 수 없는 불변 클래스로 만들면 유지 보수성이 크게 향상된다.\n- 불변 객체의 크기가 작은 이유: 생성자 안에서만 상태를 초기화할 수 있기 때문이다.\n\n### 불변 객체\n- 변경이 불가능한 객체\n- 객체를 생성 후 외부에 의해 상태를 바꿀 수 없다. (heap 영역에서 객체가 가리키고 있는 데이터 자체의 변화가 불가능하다는 뜻이다.)\n\n#### 장점\n- 생성자, 접근 메서드에 대한 방어적 복사가 필요 없다. 접근 메서드에서도 별개의 객체를 리턴하기 때문이다.\n- 멀티 스레드 환경이라면 동기화 처리 없이 객체를 공유할 수 있다. 동기화하기 위한 값이 변경되지 않기 때문이다.\n- 객체를 신뢰할 수 있다.\n\n#### 단점\n- 객체가 가지는 값마다 새로운 인스턴스를 생성해야 한다.\n\n## 라이브 코딩\n- ```assertThat(card).isSameAs(Card.of(ACE, FOUR));```\n- ```computeIfAbsent(toKey(suit, denomination), ignore -> new Card(suit, denomination));```\n  - toKey: ```return suit.name() + denomination.name();```\n\n# 3/8\n## 데이터베이스 기초\n### POST\n- 클라이언트에서 웹 서버로 어떠한 정보를 제출한다.\n- 데이터는 HTTP 바디에 담아 전송한다.\n- 데이터가 노출되지 않고, 길이 제한이 없다.\n\n### 응답 코드\n- 특정 HTTP 요청이 성공적으로 완료되었는지\n- 2xx : 성공 응답. 이 작업을 수신하여 이해했고 승낙했으며 성공적으로 처리했다.\n- 3xx : 리다이렉션. 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.\n  - 301 영구 이동 : 요청한 페이지를 새 위치로 영구적으로 이동한다.\n  - 302 임시 이동 : 다른 페이지로 이동하지만 나중에 바뀔 수 있다.\n- 4xx : 클라이언트 오류\n- 5xx : 서버 오류\n\n### 데이터 중복\n- 파일 처리 시스템은 각 파일마다 필요한 데이터를 각각 가지고 있어야 한다.\n\n### 비일관성\n- 데이터에 변경 사항이 조금만 있어도 각 파일에서 해당되는 데이터를 모두 변경해야 하며 한꺼번에 수정되지 않으면 곤란하다(?)\n\n### 보안성\n- 파일을 누구나 수정할 수 있다.\n\n### 데이터베이스\n- 데이터의 집합\n- 관리하는 시스템과 통합되어 제공되며 따라서 정확한 명칭은 데이터베이스 관리 시스템 (DBMS)\n- 관계형 데이터베이스 (RDMS)\n- 비관계형 데이터베이스 (NoSQL)\n\n#### 특징\n- 데이터 공유 : 일정한 형식을 필터링 후 저장 / 여러 명이 데이터를 동시 공유하는 것\n- 데이터 중복의 최소화 : 하나의 데이터베이스에 여러 응용 프로그램이 접근 가능할 수 있다.\n- 계속적 변화에 대한 공유 : 항상 최근의 정확한 데이터를 동적으로 유지하는 특징 존재\n- 데이터 논리적 독립성 : 응용 프로그램과 데이터 베이스를 독립 시킨다.\n\n### 관계형 데이터베이스\n- DB계의 주류\n- 컬럼과 로우로 이루어진 테이블 형태로 저장\n- 데이터의 종속성은 관계로 표현한다.\n- 스키마 : 테이블에 적재될 데이터의 구조와 형식을 정의하는 것.\n\n### SQL\n- Structured Query Language\n- 데이터를 저장하거나 얻기 위해서 사용하는 표준화된 언어\n- 질의문 혹은 쿼리\n\n### where\n- like\n\t``` select * from movie where title like '%클'```\n- %클 : 앞에는 무엇이든지 와야 하지만 뒷자리는 클이어야 한다.\n- 클% : 앞자리는 클리어야 하고, 뒷글자는 무엇이든지 가능하다.\n- %클% : 클이라는 글자를 갖는 title이 포함된 결과를 검색한다.\n\n### update\n- 테이블의 데이터를 변경한다.\n```UPDATE `tbl_name` SET `col1_name`=`값1` WHERE `col1_name`=`조건` ```\n### delete\n- 테이블의 데이터를 삭제한다.\n```DELETE FROM `tbl_name` WHERE `col1_name`=`조건` ```\n\n### group by\n- 그룹핑하여 조회한다.\n```\nSELECT *\nFROM movie\nGROUP BY title, openning_date;\n```\n\n제목 별로 나눈 다음, openning_date에 따라 다시 나눈다.\n\n### having\n- 집계 함수의 결과가 조건에 맞는 데이터를 조회한다.\n```\nSELECT\nFROM\nGROUP BY\nHAVING 집계함수(`col2_name`) >= 조건\n```\n\n- limit : 지정한 개수만큼 조회한다.\n```\nselect *\nfrom movie\nlimit row_count\n```\n\n- order by\n```\norder by `col2_name` ASC|DESC\n```\n\n### 순서\nfrom -> where -> group by -> having -> select -> order by -> limit\n\n## 키\n- 대체 키\n- 외래 키\n- 슈퍼 키\n\n### PK\n- 기본적으로 NOT NULL\n- 키는 중복될 수 없다.\n\n## 트랜잭션\n- 일련의 작업 단위\n- 데이터의 무결성을 보장받을 수 있다.\n- 성공 또는 실패 -> 트랜잭션은 원자성을 갖는다.\n\n## API\n- Application Programming Interface\n- 다양한 컴포넌트 간의 통신 방법\n\n### 인터페이스\n- 두 물체 공간, 단계 등의 공통 경계면\n- 독립되고 관계가 없는 시스템끼리 접촉하거나 통신이 일어나는 부분\n- CUI (Character User Interface)\n- GUI (Graphical User Interface)"},{"excerpt":"LOG C++ 강의를 시작했다. container, stl 관련 내용부터 시작하고 있다. 늘 그랬듯 시간에 얽매이기 보다는 무엇을 가르칠지를 생각할 것이다. 과외 하고 나서 밀린 일들을 했다. 휴학 증명서도 제출하고, 미루던 블로그 구글 애널리틱스, 서치도 등록했다. 밀린 일을 하고 나니 뿌듯하다. 나중에는 RSS도 등록해 볼 생각이다. 회고를 쓰고 다른…","fields":{"slug":"/2023-03-05/"},"frontmatter":{"date":"2023년 03월 05일 15:03","title":"2023년 03월 05일","tags":null},"rawMarkdownBody":"## LOG\n- C++ 강의를 시작했다. container, stl 관련 내용부터 시작하고 있다. 늘 그랬듯 시간에 얽매이기 보다는 무엇을 가르칠지를 생각할 것이다.\n- 과외 하고 나서 밀린 일들을 했다. 휴학 증명서도 제출하고, 미루던 블로그 구글 애널리틱스, 서치도 등록했다. 밀린 일을 하고 나니 뿌듯하다. 나중에는 RSS도 등록해 볼 생각이다.\n- 회고를 쓰고 다른 사람 회고를 구경했다. 다들 재밌게 공부하는 것처럼 보인다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 리팩토링할 생각을 하니 막막해졌다. 원래 복잡한 구조일수록 고치는게 오래걸려서, 지금 많이 꼬여있는 의존성들을 어떻게 풀어놓을지 궁리해야 한다. 아직 뾰족한 수는 떠오르지 않는다.\n- dto를 써야 할까? controller가 비대하니 service를 만들어야 할까?\n\n## 느낀 것\n- 나는 글을 쓰는 것을 좋아한다. 코딩도 좋아한다. 노래 듣는 것도 좋아한다. 요즘 좋아하는 것을 찾고 있다. 내가 좋아하는 것을 잘 찾아나갈 수 있을까? 23년 살도록 내가 좋아하는 걸 제대로 알지 못한다는 건 조금 웃긴 것 같다 ㅋㅋ\n- 조금 더 감정적이게 되었다. 나는 이런 변화가 좋다고 생각한다. 재작년, 작년까지만 해도 허무주의/무기력함에 빠져 살았는데 좀 더 많이 웃고 이야기하는 지금이 훨씬 좋다. 지금은 잘하는 사람들을 봐도 자괴감이 들거나 무기력해지지 않는다. 자존감이 약간 올라갔다고 생각해도 되려나?\n"},{"excerpt":"LOG 레벨1 조의 블랙캣과 페어가 되었다. 페어 미션 수행하기가 이리내의 데일리 미션이었기 때문에 블랙캣과 깃허브 맞팔도 하고 (사심 채우기) 코드 리뷰도 했다. 항상 리뷰어한테만 리뷰 받다가 같은 크루에게 리뷰를 받으니 또 신선한 기분이었다. 의외로 재밌었다 ㅋㅋㅋ 온보딩 조와 6시 끝나고 술을 마시러 갔다. 재밌는 이야기도 많이 했다. 역시 좋은 사…","fields":{"slug":"/2023-03-06/"},"frontmatter":{"date":"2023년 03월 05일 15:03","title":"2023년 03월 06일","tags":null},"rawMarkdownBody":"## LOG\n- 레벨1 조의 블랙캣과 페어가 되었다. 페어 미션 수행하기가 이리내의 데일리 미션이었기 때문에 블랙캣과 깃허브 맞팔도 하고 (사심 채우기) 코드 리뷰도 했다. 항상 리뷰어한테만 리뷰 받다가 같은 크루에게 리뷰를 받으니 또 신선한 기분이었다. 의외로 재밌었다 ㅋㅋㅋ\n- 온보딩 조와 6시 끝나고 술을 마시러 갔다. 재밌는 이야기도 많이 했다. 역시 좋은 사람들과 (좋사좋시) 재밌게 놀다보니 시간이 금방 갔다. 내일 또 잠실 가야 돼서 많이는 안 마셨지만 그냥 기분이 좋았다. 사실 다들 만난지는 1달밖에 안 됐지만 신기하게도 잘 맞는 사람들 같다.\n- 제네릭 미션을 완료했다. 어제 12시부터 했는데, 어려운 내용 같다...🥺\n\n## 배운 것\n\n## 궁금한 것\n- 브라운과의 커피챗 주제로도 한 거지만 페어와 의견이 다를 때는 어떻게 의견을 표현하는게 좋을까? 내가 강강 약약이라 자기 주장이 약한 페어를 상대로는 어떻게 내 의견을 피는게 좋을지 궁금하다.\n\n## 어려운 것\n- 어쩌다보니 오늘 크루들과 이야기하는 데에만 시간을 쓰게 되었다. 물론 사람을 만나는 것도 좋고 즐겁지만 내가 해야 하는 일도 있는 만큼 어떻게 시간을 잘 쓸 수 있을지 고민이 된다.\n\n## 느낀 것\n- 확실히 자존감이 올라간 것 같다. 지금이라면 나를 달가워하지 않는 사람이 있더라도 그러려니 하고 넘길 수 있다. 뭔가 '나는 좋은 사람이고, 나의 진가를 못 알아보는 상대방이 안타깝다 🙂' 라는 생각이 든다고 해야 하나 ㅋㅋㅋ 작은 성공부터 시작해보자는 다른 사람들의 말이 어떤 뜻인지 다시 알게 되는 시간이 되었다. 어쩌면 다른 사람 눈에는 건방져 보일 수도 있지만...🥺 나에게는 지금이 인생의 가장 큰 한 걸음을 걷는 시간이다.\n- 헤나와 페어 회고를 하면서 말을 놓았다. 나는 확실히 존댓말을 하는 사람과 반말을 하는 사람의 친밀도가 다른 것 같아서 말을 놓으면서 훨씬 더 가까워진 것 같다. 회고를 하며 내가 강강약약이라는 걸 알았다. 의견이 강한 사람에게는 강하게 주장할 수 있지만, 의견이 그렇게 강하지 않은 사람에게는 오히려 더 배려하느라 양보해버린다는 걸..! 체인저가 그럴 때는 오히려 상대방을 강한 의견을 하는 사람으로 만들라는 말이 인상 깊었다. '그 방법의 장점은 어떤 게 있나요?' 나, '왜 그 방법이 좋다고 생각하시나요?'라는 질문을 더 던지면서 서로의 토론을 일으키는 방식도 있을 것 같다. 나는 시간이 없어서 그냥 양보하고 넘어갔는데, 헤나가 그걸 느끼고 있었다는 게 괜히 미안했다. 시간이 더 많을 때 이런 이야기 많이 해볼걸 ㅠㅠ 다음 체스 미션 때는 내 의견을 적절하게 잘 말하는 게 좋을 것 같다.\n- 요즘에는 감사하는 마음, 겸손한 마음을 갖고 있다. 내가 이런 생각을 하게 될 줄이야ㅋㅋㅋ 옛날에는 대체 뭐가 감사하다는 건지, 뭐가 즐겁다는건지 이해하지 못했는데 이제는 알 것 같다는 게 다르다.\n"},{"excerpt":"LOG 테코톡 발표가 있었지만 미션 구현하느라 발표는 보지 못했다. 기능 구현 자체는 만족스럽게 됐었는데 합치는 부분이 문제였다. 생각해본 결과 추상화 자체는 좋지만 딜러와 플레이어는 분리되는게 맞는 것 같다. 네오는 포켓몬을 좋아한다고 한다. 오늘만 해서 포켓몬 트레이너를 4명 정도 봤다. 아마란스도 포켓몬을 좋아하다니 신기했다 ㅋㅋㅋ 주변에 포켓몬 트…","fields":{"slug":"/2023-03-02/"},"frontmatter":{"date":"2023년 03월 02일 10:03","title":"2023년 03월 02일","tags":null},"rawMarkdownBody":"## LOG\n- 테코톡 발표가 있었지만 미션 구현하느라 발표는 보지 못했다. 기능 구현 자체는 만족스럽게 됐었는데 합치는 부분이 문제였다. 생각해본 결과 추상화 자체는 좋지만 딜러와 플레이어는 분리되는게 맞는 것 같다.\n- 네오는 포켓몬을 좋아한다고 한다. 오늘만 해서 포켓몬 트레이너를 4명 정도 봤다. 아마란스도 포켓몬을 좋아하다니 신기했다 ㅋㅋㅋ 주변에 포켓몬 트레이너 꽤 많았구나\n- 글쓰기 미션이 시작됐다. 이제 할 거 없으면 (사실 많음) 글쓰기를 하면 되겠다.\n- 이번주 토요일부터 과외를 재개하기로 했다. 과연 주말 괜찮을까 ㅋㅋ 자료도 얼른 준비해야겠다.\n- 생각해보니 내일 시간이 많이 없다..ㅠㅠ 코수타에 미니미션까지 하면 시간이 굉장히 촉박하다. 뭐든 미션을 완성하는 게 급선무이니, 빠르게 완성해야 할 것 같다. 생각해보니 3/1이 공휴일이어서 여유있는 목요일이 아니라 금요일에 마감하는구나.. 방금 알아서 곤란해졌다 ㅋㅋ 생각보다 시간이 없던 게 맞았다. 그래도 할 수 있는 데까지 해보자!\n\n## 배운 것\n\n\n## 궁금한 것\n\n## 어려웠던 것\n- 쉬지 않고 집중 가능한 줄 알았는데 6시 되니까 헤나도 나도 좀 어지러웠다..ㅋㅋ 휴식하지 않고 페어 프로그래밍 하기는 하지 말자.\n\n## 느낀 것\n- 어쨌든 미션은 완성해야 리뷰도 받을 수 있는 거다. 고민되는 부분도 많지만 완성이 목표여야 한다. 저번 미션 때도 느꼈지만 페어 프로그래밍 때 쳐낼 건 쳐내면서 진행했어야 했는데 좋은 의견들이 많이 나와서 빠르게 진행하지 못했다. 그 부분이 아쉬운 점이다.\n- 말투가 중요하다는 걸 오늘 느꼈다. 독성말투 글을 읽고 나니 공격적으로 말하는 (의도는 그렇지 않다고 하더라도) 사람의 말투가 들렸다. 사람의 내면은 자기 자신 외에는 누구도 모르니까, 어쩔 수 없이 우리는 밖에 보여지는 모습으로 판단하게 된다. 좋은 사람으로 보이려면 내 외면이 좋은 사람이 되어야 한다. 그렇다고 해서 밖으로 보이는 것에만 집중하면 불행해진다. 뭐든 적당한 게 좋은 것 같다. 적당히 좋은 사람도 힘든 거구나.\n- 취미를 갖는다는 건 뭘까. 진짜 나는 딱히 취미라고 할 게 없는데 취미에 진심인 사람들을 보면 신기하다. 그래서 별로 재미 없게 사는 것 같기도 하다.\n"},{"excerpt":"페어 페어는 헤나였다. 헤나와 처음 만나고 나서 약 40분간 아이스 브레이킹 시간을 가졌다. 페어와 정한 규칙 20분마다 교대했다. 모르는 것은 바로바로 물어본다. 페어가 멍 때리면 괜찮냐고 물어본다. 페어가 마음 상할까 봐 하고 싶은 말을 숨기지 않는다. 페어와 프로그래밍 할 때 규칙 요구사항 분석 후에 클래스 간의 관계를 그림으로 그리면서 구현했다. …","fields":{"slug":"/level1-blackjack/"},"frontmatter":{"date":"2023년 03월 01일 15:03","title":"블랙잭 미션","tags":["레벨1","우테코"]},"rawMarkdownBody":"## 페어\n- 페어는 헤나였다.\n- 헤나와 처음 만나고 나서 약 40분간 아이스 브레이킹 시간을 가졌다.\n\n### 페어와 정한 규칙\n- 20분마다 교대했다.\n- 모르는 것은 바로바로 물어본다.\n- 페어가 멍 때리면 괜찮냐고 물어본다.\n- 페어가 마음 상할까 봐 하고 싶은 말을 숨기지 않는다.\n\n### 페어와 프로그래밍 할 때 규칙\n- 요구사항 분석 후에 클래스 간의 관계를 그림으로 그리면서 구현했다.\n- 테스트 코드 메서드 이름을 카멜 케이스로 작성했다. ```throwExceptionWhenCardDuplicated()```, ```create()```\n- 에러 메시지는 매직 스트링을 사용했다.\n- 클래스와 클래스 필드 사이에 띄어쓰기 하지 않는다.\n- 테스트 코드 클래스 선언 아래에 띄어쓰기 하지 않는다.\n- TDD 할 때 실패하는 테스트 -> 테스트 실행 -> 돌아가도록 최소한 구현 -> 테스트 실행 후 성공 확인 -> 성공하는 테스트 -> 테스트 실행 -> 돌아가도록 구현 ... 방식으로 구현한다. 실패하는 테스트가 없는 경우 작성하지 않는다.\n- Co-authored 사용했다.\n- 도메인을 먼저 구현하기 시작했다.\n- 커밋 규칙: test -> feat\n\n## 미션에서 고민한 주제들\n### 참가자의 점수를 계산하는 클래스는 어디여야 하는가?\n1. ParticipantCards: 참가자의 카드 리스트를 가지고 있고, 점수를 계산할 때 카드 리스트를 갖고 있으면 계산하기 쉽다.\n2. CardNumber(최종 채택): 다른 카드들의 합에 따라서 에이스의 값이 변경되어야 하므로, 카드 숫자의 값을 저장하고 있는 enum인 CardNumber에서 값을 계산해야 한다. 대신 계산하는 메서드의 매개변수는 ```List<CardNumber>```로 받는다. (```List<Card>```를 받게 되면 다른 클래스와의 의존성이 커질 것 같다)\n3. Optimizer(가칭): 점수를 계산하는 외부 객체를 만든다. ParticipantCards의 계산 메서드에서 Optimizer를 매개변수로 넣어 보낸다.\n\n- 결국 CardNumber를 채택했다. \n\n### 딜러의 권한은 어디까지인가? (얼마나 현실세계와 가깝게 구현해야 할까?)\n- 카드를 나눠주는 것도 딜러의 권한인가?\n- 점수를 계산하는 권한을 딜러에게 줄까 고민했지만 헤나가 너무 현실세계와 비슷하게 구현한다고 해서 기각했다.\n\n### 에이스의 값을 어떻게 가변적으로 설정할까?\n- 에이스의 값은 1, 11이 될 수 있다. 21이 넘지 않으면서 가깝게 만드는 것이 최선이지만, 21을 넘은 경우 값이 최대한 작아져야 한다.\n- CardNumber에서 계산하기로 했는데, 매개변수로 값을 받은 모든 카드 숫자를 더하고, 에이스의 개수만큼 10씩 더해가는 방식을 취했다. 대신 21이 넘지 않도록 더한다. 코드를 보는게 이해가 빠를 듯하다. \n- [코드](https:/github.com/hyena0608/java-blackjack/blob/hyena0608/src/main/java/blackjack/domain/CardNumber.java) stream과 reduce를 사용했다. 헤나 덕분에 reduce도 사용해보고 좋았다.\n\n## 페어 회고\n\n### 스스로에게 좋았던 점\n- 궁금하거나 이해가 잘 안 됐던 부분을 바로바로 물어봤다.\n- 페어의 의견을 많이 반영하려고 노력했다. 내가 해보지 않은 방법을 최대한 많이 사용해보려고 노력했다.\n\n### 스스로에게 아쉬웠던 점\n- 쉬자고 말하면서 했어야 했는데 그냥 내 페이스로 밀어붙인 것 같아서 미안했다.\n- 안 그래도 미션 시간이 없는데 내가 늦게까지 남아있지 않아서 더 시간이 없었던 것 같다.\n- 결정을 내렸어야 하는 부분에서는 의견을 확실하게 주장했어야 했는데, 내 의견도 좋고 페어 의견도 좋다는 애매한 포지션을 취해서 미션 진행이 느려지는데 기여한 것 같다.\n\n### 페어에게 좋았던 점\n- 그림으로 설계하면서 진행했던 게 좋았다. 서로의 의견을 들어보고 진행했던 게 좋았다.\n- 이상한 의견을 내도 잘 들어줘서 의견을 낼 때 머뭇거리지 않고 낼 수 있었다.\n- 페어 프로그래밍의 규칙을 미리 정해두고 해서 좋았다.\n\n### 페어에게 아쉬웠던 점\n- 나와 헤나 모두 의견이 강하지 않아서 여러 번 물어보고 진행하느라 조금 시간이 오래 걸렸던 것 같다.\n- 서로의 의견을 너무 존중하느라 ㅋㅋㅋ 사소한 의견 결정도 오래걸렸던 것 같다. \n\n### 소감 & 앞으로의 다짐\n- 뭔가 폭신폭신한 페어 프로그래밍을 했던 것 같다.\n- 가장 중요한 로직을 선정하고 중요한 순서대로 구현해야겠다.\n- 설계 시간을 정해두고 정해진 시간을 지키면서 미션을 진행해야겠다.\n- 부딪히는 부분에서 어떻게 의견을 잘 낼 수 있을지 고민해봐야겠다.\n\n## 다음 미션에서 적용할 것\n- 처음에 만났을 때 말을 놓자고 먼저 제안해 본다. 편한 분위기에서 말을 건넬 수 있어 좋은 것 같다.\n- 미션 시작 전에 간단하게 30분 정도 아이스 브레이킹을 진행한다.\n- 설계는 1시간 정도 한다. 그림을 그리면서 객체간의 관계만 생각해본다. 세부적인 필드나 메서드는 미리 생각하지 않는다.\n- 너무 내 의견을 양보하지 않는다. 어떤 게 더 좋은 건지, 왜 좋은지 물어보면서 진행한다. 주장할 때는 확실하게 하자.\n- 머릿속에서 말을 정리하고 이야기한다. 말을 하고 싶다는 생각으로 말을 시작하지 말자. 정리되지 않은 말은 오히려 페어를 헷갈리게 한다.\n- 질문도 여러 번 했고 이야기를 나눴는데도 결정이 안 나면 일단 내 의견을 밀고 나간다."},{"excerpt":"LOG 정말 일이 하나도 안 풀리는 날이었다. 헤나랑 미션 하러 가려고 11시에 나왔더니 지갑을 놓고 가서 문 안 열리는 기숙사 엘리베이터를 기다렸고, 어찌저찌 타서 지갑 가지고 버스 탔더니 타자마자 급출발/급정거 해서 머리+손등+다리 3타 맞았다. 손등 느낌이 이상해서 병원 가야겠다고 생각했는데 하필 오늘 공휴일이라 일단 잠실역에 있는 24시간 병원에 …","fields":{"slug":"/2023-03-01/"},"frontmatter":{"date":"2023년 03월 01일 13:03","title":"2023년 03월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 정말 일이 하나도 안 풀리는 날이었다. 헤나랑 미션 하러 가려고 11시에 나왔더니 지갑을 놓고 가서 문 안 열리는 기숙사 엘리베이터를 기다렸고, 어찌저찌 타서 지갑 가지고 버스 탔더니 타자마자 급출발/급정거 해서 머리+손등+다리 3타 맞았다. 손등 느낌이 이상해서 병원 가야겠다고 생각했는데 하필 오늘 공휴일이라 일단 잠실역에 있는 24시간 병원에 갔는데 거기서는 엑스레이를 찍을 수 없다고 했다... 그래서 석촌역에 있는 병원 응급실에 갔다. (이쯤 되었을 때 헤나에게 무지 미안해지기 시작) 응급실에 갔더니 12시 40분이었고, 점심시간이라 2시부터 진료한다 했다. 배고파서 세븐일레븐에서 뭔가 먹으려고 갔더니 불은 켜져있는데 문이 안 열렸다 ㅋㅋㅋ ~~이쯤되니 진짜 기분이 안 좋았다~~ 그래서 그냥 중국집에 들어갔는데 하필 또 자리가 없어서 기다렸다 먹었다. 와중에 헤나한테 미안해서 매머드에서 커피 사가려고 했는데 공휴일이라 안 열음 ㅋㅋㅋㅋㅋ 그래서 옆에 있는 커피 집에서 간신히 커피 두 잔 샀다... 진짜 뭔 날이었나 싶다. 3월 액땜했다 치자...\n- 다행히 골절 같지는 않았지만 엑스레이에서 잘 안 보이는 미세골절일 수도 있다길래 일주일 뒤에도 아프면 엑스레이 다시 찍어보라고 했다. 응급실이라 돈 걱정했지만 13000원 밖에 안 나와서 다행이었다. 그때는 손가락 움직이는 것도 아팠는데 지금은 좀 괜찮다.\n- 헤나와 에이스 계산 방법에 대해 토론했다. 열띤 이야기 끝에 에이스 처리를 포함해서 점수 계산하는 로직까지 짰다. 편안하다...\n- 오늘은 새로운 사람들을 많이 만났다. 이름만 들어봤던 사람들을 실제로 만났다ㅋㅋ 말랑, 후추, 썬샷, 하마드, 우가, 리오, 베베, 헤나, 디노와 어쩌다보니 저녁을 같이 먹게 되었다. 내가 그때쯤 굉장히 지쳐있는 상황이었어서 텐션 높게 말하지는 못했지만 재밌었다. 가위바위보 해서 썬샷에게 아이스크림도 얻어먹었다 ㅋㅋ\n\n## 배운 것\n- stream에서 mapToInt -> sum 보다 reduce가 더 느리다고 한다. mapToInt를 하면 primitive 타입으로 계산되어서 그렇다고 한다. (by 말랑)\n- AutoBoxing: 원시타입의 값을 해당 wrapper 클래스의 객체로 바꾸는 과정. 자바 컴파일러는 원시타입이 wrapper 클래스의 타입이 파라미터를 받는 메서드를 통과할 때, 원시 타입이 wrapper 클래스의 변수로 할당될 때 AutoBoxing을 적용한다.\n- Auto unboxing: wrapper 클래스에서 원시 타입으로 자동으로 변환하는 것. 기본 자료형의 wrapper 객체 대입.\n\n## 궁금한 것\n\n## 어려웠던 것\n- 기분이 안 좋은 상태에서 긍정적인 생각을 하는 것은 힘들다는 걸 알았다. 무의식적으로도 긍정적인 사람이 되고 싶다.\n\n## 느낀 것\n- 어려웠던 것을 적으면서 생각했는데, 요즘엔 놀랍게도 부정적인 생각을 안 한다. 일이 잘 풀려가고 있고, 우테코 생활도 즐거워서 그런 것 같다. 원래는 일이 잘 풀릴 때도 '언젠간 힘들겠지', '잘하고 있는 건 아닌 거 같은데?', '이런 것도 못해?'라는 생각을 계속하게 됐는데 지금은 훨씬 좋아졌다. 그 분한테 이런 말을 전해줄 수 있다면 좋을텐데!\n- 좋은 사람들이 많고, 상냥한 사람들도 많다. 아직까지는 정말로 좋은 사람들만 만나고 있는 것 같다.\n- 가끔 지금 순간이 몰카인가? 싶은 때가 있다 ㅋㅋㅋ 진짜 신기한 게 우테코에 있는 사람들의 얼굴이 내 지인들과 겹치는 사람들이 많다. 사촌오빠, 친구의 남자친구, 동기 등등... 닮은 사람들이 끝도 없이 나와서 신기하다. 꼭 아는 사람이 아니더라도 어딘가에서 본 것 같은 분들이 나온다. 신기하다.\n- 포이가 이펙티브 자바 읽어보라고 했는데 처음부터 차근차근 읽을 자신은 없다. 중간중간 뒤적이는 건 할 수 있을 듯. 원래는 책 읽는 거 좋아했었는데 확실히 개발 책은 읽을 때는 재미없다. 이거 인정하기 싫었는데 ㅋㅋ 유익하긴 함.\n"},{"excerpt":"2023-03-01 2023-03-02 2023-03-05 2023-03-06 2023-03-07 2023-03-08 2023-03-09 2023-03-10 2023-03-12 2023-03-13 2023-03-14 2023-03-15 2023-03-16 2023-03-17 2023-03-18 2023-03-19 2023-03-20 2023-03-21 2…","fields":{"slug":"/2023-03/"},"frontmatter":{"date":"2023년 03월 01일 13:03","title":"2023년 03월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-03-01]]\n- [[2023-03-02]]\n- [[2023-03-05]]\n- [[2023-03-06]]\n- [[2023-03-07]]\n- [[2023-03-08]]\n- [[2023-03-09]]\n- [[2023-03-10]]\n- [[2023-03-12]]\n- [[2023-03-13]]\n- [[2023-03-14]]\n- [[2023-03-15]]\n- [[2023-03-16]]\n- [[2023-03-17]]\n- [[2023-03-18]]\n- [[2023-03-19]]\n- [[2023-03-20]]\n- [[2023-03-21]]\n- [[2023-03-22]]\n- [[2023-03-23]]\n- [[2023-03-24]]\n- [[2023-03-25]]\n- [[2023-03-26]]\n- [[2023-03-27]]\n- [[2023-03-29]]\n- [[2023-03-30]]\n- [[2023-03-31]]\n"},{"excerpt":"LOG 오늘 드디어 사다리 미션이 끝났다. 이번에 리뷰해주신 토니는 정말 좋은 리뷰어였다 👍 DM으로 편하게 질문해도 된다고 하셨는데, 막상 DM 하려니 어떤 말해야 할 지 모르겠어서... 많이 못했던 것 같다. 죄송해요 토니 😂 헤나와 페어가 되었다. 헤나는 istj인데 내가 본 사람 중에서 가장 istj 같다 ㅋㅋㅋ 뭔가 체계적으로 개발하고 기록도 잘…","fields":{"slug":"/2023-02-28/"},"frontmatter":{"date":"2023년 02월 28일 14:02","title":"2023년 02월 28일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘 드디어 사다리 미션이 끝났다. 이번에 리뷰해주신 토니는 정말 좋은 리뷰어였다 👍 DM으로 편하게 질문해도 된다고 하셨는데, 막상 DM 하려니 어떤 말해야 할 지 모르겠어서... 많이 못했던 것 같다. 죄송해요 토니 😂\n- 헤나와 페어가 되었다. 헤나는 istj인데 내가 본 사람 중에서 가장 istj 같다 ㅋㅋㅋ 뭔가 체계적으로 개발하고 기록도 잘 남겨두시는 것 같아서 신기했다. 헤나를 본받아서 나도 기록을 열심히 해보고 싶다!\n- 점심으로 찜닭을 먹었다. 양이 너무 많아서 결국 조금 남겼다. 6명이서 찜닭으로 10만원 먹은거 실환가 ㅋㅋㅋ 그래도 맛있었으니 오케이입니다.\n- 내일도 출근하기로 했다. 아침은 너무 힘드니 1시에. 헤나와 설계 토론을 하다보니 너무 시간이 빨리 가서 어느 정도 구현을 해두려고 한다.\n\n## 배운 것\n- 문자열 덧셈이 굉장히 시간이 오래 걸린다. java 11부터는 StringConcatFactory.makeConcatWithconstants로 최적화를 해준다고 하는데도 느렸다. 웬만하면 StringBuilder를 사용하는 쪽으로..\n- StringBuffer는 동기화를 지원하여 멀티 스레드 환경에서도 안전하게 동작할 수 있다고 한다. 그러나 네오 말로는 멀티 스레드 환경에서 String을 구성할 일이 있나 싶다고 한다. ~~나도 그렇게 생각한다..~~ 반례를 찾으면 글로 남겨야겠다.\n\n## 궁금한 것\n- 강의를 그냥 듣는 게 나을지, 아니면 강의 중에 던져지는 키워드를 듣고 내가 혼자 더 찾아보는게 좋을지? 강의에서 좋은 인사이트를 얻을 수 있는 건 맞지만 맹신하지는 않아야 한다고 생각한다. 그래도 강의니까 처음부터 끝까지 놓치지 말고 듣는게 좋을지, 아니면 중간에 조금 놓치더라도 따로 더 찾아보는게 좋을지 궁금하다. 나는 그때 찾아보지 않으면 그 뒤로 절대 안 찾아봐서.. 고민이 된다.\n\n## 어려웠던 것\n- 중간중간에 상대방 말을 놓친다. 순간순간 다른 생각이 드는데, 그때 제대로 정신을 잡지 않으면 다른 사람이 말할 때 그 뒷부분을 아예 못 듣는다. 페어한테 이럴 때 굉장히 미안하다 😥\n\n## 느낀 것\n- 토리한테 ```~가 ~~라고 생각하면 어떡하지?``` 라는 말을 습관적으로 했는데 우리 그런 거 생각 안 하기로 했잖아!!🐿️  해서 그런 생각에서 빨리 벗어나올 수 있었다. 토리 말이 맞지👍\n- 데일리 때 레벨1에서 어떤 걸 이루고 싶은지에 대해 이야기 했다. 그때는 너무 횡설수설한 것 같아서 글로 써본다. 먼저 우테코 크루들과 편하게 인사하는 사이가 되고 싶다. 모두가 아니더라도 많은 사람들을 알고, 소통할 수 있었으면 좋겠다. 아직까지는 잘하고 있는 것 같다. 좀 더 바라는 것이 있다면 크루들이 나를 편하게 대해주었으면 좋겠다. 그러려면 나도 다가가기 쉬운 사람이 되어야 한다. 두 번째는 레벨1에서 사용한 Java 개념을 확실하게 알고 쓰기. 사용했던 것에 대해서는 잘 설명할 수 있는 사람이 되어 있으면 좋겠다.\n- 점심 먹다가 이야기 나왔는데, 말투도 실력이다(?) 똑같은 말도 말투에 따라 다른 뜻으로 해석될 수 있듯이 최대한 좋은 말투로 말하는 게 하나도 손해볼 게 없다. 굳이 날카로운 말투로 말할 필요가 없듯이, 나도 부드러운 말투로 말하려고 노력해야겠다. 나는 기분나쁨의 역치가 높은 편인데 그래서 오히려 다른 사람들에게 말할 때 내가 '독성 말투'로 말하고 있지 않은지 다시 돌아보게 된다. [독성말투](https://edykim.com/ko/post/tech-has-a-toxic-tone-problem-lets-fix-it/?fbclid=IwAR0YKYz45F3aNL-aMHr376RpCBjOaNo88xmbk7e9l0yKscreEk8lNwaCR-g) 라는 글을 읽어봤는데, 개발자라면 꼭 한 번쯤 읽어볼만한 글인 것 같다. 다른 사람들에게도 공유해야겠다. 웬만한 개발자들은 주변에서 이런 독성 말투를 쓰는 개발자를 본 적 있을 것이다.\n"},{"excerpt":"2/28 문자열 자바는 문자열을 위한 클래스를 제공한다. String 생성 방법 intern()을 사용하면 JVM의 최적화 StringConcatFactory.makeConcatWithconstants 로 연결해준다. StringBuilder와 StringBuffer는 생성자로 별도 설정해주지 않으면 초기 capacity가 16 characters로 세팅…","fields":{"slug":"/level1-week4/"},"frontmatter":{"date":"2023년 02월 28일 02:02","title":"레벨1 4주차","tags":["레벨1","우테코"]},"rawMarkdownBody":"# 2/28\n## 문자열\n- 자바는 문자열을 위한 클래스를 제공한다.\n### String 생성 방법\n```\nString a = \"a\";\nString b = new String(\"a\");\nString c = new String(\"a\").intern();\n```\n- intern()을 사용하면 \n  \n### JVM의 최적화\n```\nString a = \"a\";\nString b = \"b\";\nString c = \"c\";\n\nSystem.out.println(a+b+c);\n```\n\nStringConcatFactory.makeConcatWithconstants 로 연결해준다.\n- StringBuilder와 StringBuffer는 생성자로 별도 설정해주지 않으면 초기 capacity가 16 characters로 세팅된다. 작은 용량이기 때문에 재할당으로 인한 추가 비용이 발생하기 쉽다. 또한 loop와 같은 상황에서 StringBuilder 객체가 계속해서 생성되는 일이 발생하게 된다.\n- 최적화하는 방법을 알아야 하는 이유는 다른 JVM으로 내 코드가 실행될 수도 있기 때문이다. 원리를 알아야 그 때 다르게 동작할 때 이유를 알아낼 수 있다.\n- String의 + 연산은 JDK 8버전과 11버전에서 각각 다르게 처리한다.\n\n# 3/2\n## 글쓰기\n- 개발: 코드를 작성하는 일. 설계하고, 구현하고, 리팩터링하는 등의 과정. 내가 작성한 코드를 다른 사람이 봤을 때 쉽게 이해할 수 있을까?\n- 글: 나의 생각을 표현하는 일. 생각하고, 작성하고, 고치는 등의 과정. 내가 쓴 글을 다른 사람이 봤을 때 쉽게 읽을 수 있을까?\n-> 글과 개발은 비슷하다.\n\n### 글쓰기가 중요한 이유\n- 자신의 생각과 감정을 자신의 손을 통해 \"문자로\" 정리하고 표현하는 방법\n- 글로 표현하지 않은 생각과 감정은 결국 사라진다.\n- 나는 글을 쓰는 것이 두렵지 않다. 내가 잘 쓸 수 있다고 생각하기 때문이다! 글은 많이 써봐야 더 잘 쓰게 된다. 지금까지 많이 써 왔고, 지금이 완벽하게 잘 쓴다고 생각하지는 않지만 그래도 내 마음에 들게 글을 쓸 수는 있다 👍\n- 공부의 결과로 글쓰기가 나오는 것은 아니다. 공부하며 글쓰기를 해야 한다.\n- 나는 오히려 내 글에 관심 가져줬으면 좋겠다 ㅋㅋㅋ 그래서 잘 쓰려고 노력한다.\n- 습관의 힘을 활용한다. 일정 시간에, 일정한 장소에서 글을 써보려고 노력하자. 나도 TIL을 쓰는 습관을 들이려고 노력하는 중이다.\n- 생각해보니 내가 글을 쓰는 것이 자신 없었던 적이 없네...? 관심받기 좋아하는 사람이었어서 그런가 ㅋㅋㅋ\n\n### 글쓰기의 시작\n- 글쓰기 시작이 반이다. 한 줄이라도 써보자.\n\n### 진행 방식\n- 각 레벨 별 동일한 주제로 1개의 글을 쓴다.\n- 진행 방식은 온라인 코드 리뷰 방식과 동일하다.\n- Markdown 방식으로 글을 쓴 후, PR을 보낸다.\n- PR 짝은 6-7명으로, 자신의 글을 제외한 나머지 글을 읽고 피드백한다.\n- 코드 리뷰와 동일하게 계속해서 피드백을 남긴다.\n- 최종 피드백을 남길 시, 200자 내외로 정리하여 작성한다.\n- 최종 피드백이 완료되면 글 작성자는 리뷰 요청을 보낸다. 최종 merge된 글에 대해서 각 조에서 1개의 우승작을 선발한다.\n- 각 조 별 우승작 중 최종 우승작을 다 함께 선발한다.\n\n### 레벨 1 글쓰기 일정\n- 주제: 우아한테크코스 한 달 생활기\n- 진행 기간: 3/2 ~ 3/27. 3/2~3/20 1차 제출 기간. 3/21 ~ 3/26 크루간 글쓰기 리뷰, 퇴고 작업. 본인의 글을 리뷰할 크루들에게 글쓰기 리뷰 채널에서 멘션으로 리뷰 요청\n- 3/27: 크루 리뷰 반영 후 최종 제출 (LMS 리뷰 요청까지 할 것)\n\n### 레벨 1 글쓰기 규칙\n- A4 1페이지 이상의 분량으로 작성한다. 워드 1페이지 이상, 2페이지 이하. 글자 크기 10pt, 자간 1.0 기준\n- '나', '저'로 시작하는 문장은 되도록 쓰지 않는다. 지루하게 시작하는 문장을 줄이자.\n- 한 문장의 글자 수가 30자가 넘어가지 않도록 한다.\n- 한 문장에는 하나의 정보만 담도록 한다.\n- 능동형 문장을 쓰도록 한다.\n\n### 한 문장 쓰기\n- 나는 과거의 나를 부수기 위해 도전한다.\n\n# 3/3\n## 제네릭\n- 다양한 종류의 데이터를 관리하는 경우 데이터의 타입을 특정 타입으로 고정할 수 있다.\n- 장점: 특정 타입으로 제한하여 타입 안정성을 제공한다. 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.\n- 제네릭을 사용하지 않을 경우, 다양한 종류의 객체 타입을 추가할 수 있다. 추가한 객체 타입을 사용하려면 다시 형변환을 해야 한다.\n- 제네릭을 사용하면 해당 타입만 추가할 수 있다. 다른 타입을 저장하면 컴파일 에러가 발생한다. 특별하게 예외상황이 아니면 Generic을 사용한다.\n"},{"excerpt":"LOG 제이슨, 홍고와 커피챗을 했다. 굉장히 현실적인 이야기를 많이했다...ㅋㅋㅋ 나도 보통 생각하고 있던 이야기였지만 제이슨의 입으로 들으니 좀 더 와닿는 부분이 있었다. 누누와 말을 놓았다. 점점 말을 놓는 사람들이 많아져서 편하게 대할 수 있어 좋은 것 같다. 하마드에게 먼저 말을 걸어보았다. 하마드 이야기는 뭔가 신기하고 놀라운 이야기들이 많았다…","fields":{"slug":"/2023-02-27/"},"frontmatter":{"date":"2023년 02월 27일 14:02","title":"2023년 02월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 제이슨, 홍고와 커피챗을 했다. 굉장히 현실적인 이야기를 많이했다...ㅋㅋㅋ 나도 보통 생각하고 있던 이야기였지만 제이슨의 입으로 들으니 좀 더 와닿는 부분이 있었다.\n- 누누와 말을 놓았다. 점점 말을 놓는 사람들이 많아져서 편하게 대할 수 있어 좋은 것 같다.\n- 하마드에게 먼저 말을 걸어보았다. 하마드 이야기는 뭔가 신기하고 놀라운 이야기들이 많았다 ㅋㅋ\n- 오늘 데일리 미팅 주제는 주말에 있었던 일 영어 쓰지 않고 말하기였는데 너무 웃겼다 ㅋㅋㅋ 좀 자제하려고 노력했는데 쉽지 않았다\n- 저녁은 글렌, 포이랑 고기를 먹었다. 3명이서 7인분 먹었다 😋\n\n## 배운 것\n- 도치가 설명해준 가변 동반 클래스\n- Collection의 document에 함수를 어떻게 구현하면 좋을지에 대한 가이드라인도 나와있다는 것\n\n## 궁금한 것\n- 정말 boolean add를 추가하는 것만이 최선이었을까? 도치의 질문이었는데 정말 add의 리턴타입을 boolean으로 해야만 하는 것밖에는 방법이 없었을까?\n\n## 어려웠던 것\n- 제이슨과는 할 이야기를 생각해내는 게 쉽지 않았다. 커피챗을 하는 것은 좋지만 준비가 되지 않은 상태로 시작되었다보니 주제가 잘 생각나지 않았다. 다른 사람을 편하게 만드는 대화 주제 생각하는 것이 아직 쉽지 않은 것 같다.\n\n## 느낀 것\n- 회고 스터디 사람들 다들 좋은 사람들 같다. 이번 3주차 회고에 망고와 글렌의 회고가 올라왔는데 회고를 보면서 나와 다른 가치관, 다른 관점에서의 3주차 우테코를 돌아볼 수 있어 좋았다. 이래서 남들 회고 보는게 재밌나 싶다.\n- 주말에 푹 쉬니까 확실히 컨디션이 좋았다. 월요일 1시 출근 최고...\n- 제이슨이 말한 것 중에, 회사의 개발자들을 외부에 노출시키는 것 또한 프로모션이 될 수 있다는 것이 굉장히 와닿았다. 나도 왜 그런지 궁금할 때가 있었는데 그것 자체로도 프로모션이 될 수 있다니 충격적이었다.\n- 나보다 더 잘하는 것처럼 보이는 사람들한테 이제는 주눅들지 않는다. 원래는 내가 저 경지까지 갈 수는 있을까 싶어서 괜히 주눅들고 막막하고 그랬는데 요즘은 그렇지 않다. 내가 다다를 수 있는 경지라는게 느껴져서 그런 것 같다. 시간은 좀 걸리겠지만, 안 될 거라는 생각은 안 한다. 충분히 할 수 있다고 생각한다.\n- 주변의 모든 사람에게서 배울 점을 찾고 있다. 듣는 연습을 하고, 질문하는 연습을 하고, 좋은 답을 하는 방법을 배운다. 주변에 좋은 사람들이 많으니 배울 것도 많다.\n- 모방은 창조의 어머니이다. 단순하게 모방하는 것은 그닥 좋지 않지만, 내가 더 연구하고, 살을 붙이고, 내 것으로 체화한다면 모방 또한 좋은 '수단'이 될 수 있다. 기억하자. 처음부터 그냥 잘했던 사람은 없다.\n"},{"excerpt":"LOG 앞머리를 잘랐다. 앞머리 고데기를 하기 싫어서 앞머리 펌을 했는데, 뿌리가 휘어서 고데기가 필수가 되었다...ㅋㅋㅋ 그래도 앞머리가 거슬리지 않아 훨씬 좋다! 배운 것 연결이 빈번하지 않다면 model에서 view로 데이터를 넘겨줄 수도 있다. model 계층이 view에 영향을 최대한 덜 받게 하려면 어느 순간에는 controller라는 계층을 …","fields":{"slug":"/2023-02-26/"},"frontmatter":{"date":"2023년 02월 26일 09:02","title":"2023년 02월 26일","tags":null},"rawMarkdownBody":"## LOG\n- 앞머리를 잘랐다. 앞머리 고데기를 하기 싫어서 앞머리 펌을 했는데, 뿌리가 휘어서 고데기가 필수가 되었다...ㅋㅋㅋ 그래도 앞머리가 거슬리지 않아 훨씬 좋다!\n\n## 배운 것\n- 연결이 빈번하지 않다면 model에서 view로 데이터를 넘겨줄 수도 있다. model 계층이 view에 영향을 최대한 덜 받게 하려면 어느 순간에는 controller라는 계층을 둬서 관리하는 것이 더 깔끔한 구조를 유지할 수 있다. (by 토니의 리뷰)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"함수형 인터페이스 람다 식 또는 메서드 참조에 대한 할당 대상으로 사용된다. 참고 자료 모던 자바 인 액션 [https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html]","fields":{"slug":"/Predicate/"},"frontmatter":{"date":"2023년 02월 24일 07:02","title":"Java 8 Predicate","tags":["Java","개발"]},"rawMarkdownBody":"\n## ```Interface Predicate<T>```\n\n- 함수형 인터페이스\n- 람다 식 또는 메서드 참조에 대한 할당 대상으로 사용된다.\n\n\n## 참고 자료\n- 모던 자바 인 액션\n- [https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html]\n"},{"excerpt":"LOG 점심: 신천직화🍗  저녁: 김볶밥🍚 출입증 목걸이를 받았다! 출입증까지 같이 주는 줄 알았는데 그게 아니었다.. 그래도 훨씬 카드를 갖고 다니기 좋아졌다. 빨리 퇴근했다. 포이랑 토리랑 같이 이야기하면서 갔는데 갑자기 싸피하시는 분이 말 걸어서 깜짝 놀랐다. 서류합격이 잘 안 된다 이런 이야기였던 것 같았다. 나는 원래 활동 자체가 스펙이 될 수 …","fields":{"slug":"/2023-02-23/"},"frontmatter":{"date":"2023년 02월 24일 07:02","title":"2023년 02월 23일","tags":null},"rawMarkdownBody":"## LOG\n- 점심: 신천직화🍗  저녁: 김볶밥🍚\n- 출입증 목걸이를 받았다! 출입증까지 같이 주는 줄 알았는데 그게 아니었다.. 그래도 훨씬 카드를 갖고 다니기 좋아졌다.\n- 빨리 퇴근했다. 포이랑 토리랑 같이 이야기하면서 갔는데 갑자기 싸피하시는 분이 말 걸어서 깜짝 놀랐다. 서류합격이 잘 안 된다 이런 이야기였던 것 같았다. 나는 원래 활동 자체가 스펙이 될 수 없다고 생각하는 편이라 자기가 좀 더 노력해야 한다고 생각했다. 아무튼 좀 당황스럽긴 했다 ㅋㅋ\n- 글렌의 테코톡이 있었다. 다들 테코톡 준비를 열심히 해서 그런가 질문도 잘 대답하고 발표도 잘했다. 가끔 아찔한 질문들도 있어서 내가 저런 상황에서 어떻게 대답했을지 고민을 했다.\n- 늦게 일어났다. 아침에 눈을 떠보니 이른 알람을 못 듣고 바로 7시 15분에 기상했다. 피곤이 누적된 모양이다.\n## 배운 것\n\n## 궁금한 것\n- enum에서 동일한 값을 갖는 enum을 리턴하는 메서드를 만드는 것은 해도 되는 걸까? 어떤 기준으로 해도 되는지 선택할 수 있을까?\n\n## 어려웠던 것\n\n## 느낀 것\n- 나중에 테코톡 발표를 하게 될 텐데, 나 스스로 질문에 답을 할 때 공격적으로 답한다던지 얼른 해치워버리려고 하는 답변을 하기도 해서 걱정됐다. 좀 더 답변을 잘할 수 있는 방법은 그 부분에 대해 정말 잘 아는 것밖에 없을 것 같다 ㅠ\n- 스터디, 알고리즘 등 나를 현혹하는 주제들이 많다. 나도 욕심이 많은 편이라 이것저것 하고 싶은 게 많은데 이번에는 꼭 내가 집중하고 싶은 것에만 집중할 예정이다. 내가 배우면 다 알 수 있는데 잠깐 배우는 걸 미뤄둔다는 마인드로 지내볼 예정이다 ^^ 주변에 이런 사람들이 많아서 많이 배울 수 있는 것 같다.\n- 드디어 홍실과 말을 해봤다ㅋㅋ 한 2주간 말할까 말까만 반복했었는데 그래도 큰 숙제를 해결한 느낌이다. 애쉬랑도 말해봤는데 좀 더 친해지고 싶다!\n\n"},{"excerpt":"LOG 너무 졸려서 어제 TIL도 못 쓰고 자버렸다. 그나마 오늘은 할 일이 많이 없어서 어제 TIL도 적었다. 다행히 기억이 좀 나서 적을 수 있었던 게 좋았다. 포비와 1:1 면담(?)을 했다. 간단하게 내 소개와 내가 왜 우테코에 뽑혔을지에 대한 이야기를 나눴다. 이야기를 하면서 내 마음속에서 정리되는 생각들도 있었다. 배운 것 모던 자바 인 액션에…","fields":{"slug":"/2023-02-24/"},"frontmatter":{"date":"2023년 02월 24일 03:02","title":"2023년 02월 24일","tags":null},"rawMarkdownBody":"## LOG\n- 너무 졸려서 어제 TIL도 못 쓰고 자버렸다. 그나마 오늘은 할 일이 많이 없어서 어제 TIL도 적었다. 다행히 기억이 좀 나서 적을 수 있었던 게 좋았다.\n- 포비와 1:1 면담(?)을 했다. 간단하게 내 소개와 내가 왜 우테코에 뽑혔을지에 대한 이야기를 나눴다. 이야기를 하면서 내 마음속에서 정리되는 생각들도 있었다.\n\n## 배운 것\n- 모던 자바 인 액션에서 Predicate를 알게 되었다. -> [[Predicate|java8 Predicate]]\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 2주간 좀 익숙해졌다고 생각했는데 아직 모르는 사람들이 있었다. 좀 더 많은 사람들을 만나면서 다양한 생각을 나눠보고 싶다.\n- 포이와 토리의 리뷰어였던 찰리의 추천 책인 '객체지향의 사실과 오해'라는 책을 알게 되었다. 사실 지하철에서 틈틈이 읽고 있던 책이었는데 추천 책이라 기분 좋았다 ㅋㅋ 한 절반 정도 읽었다. 노는 시간을 줄이고 남는 시간에는 책을 읽어봐야겠다.\n- 나는 다른 사람의 의견을 궁금해하는 사람이 되고 싶다. 포비와 이야기를 하면서 \"베로는 어떤 식으로 기억하면 좋을 사람이고 싶나요?\"라는 질문을 받았다. 그 질문에 대한 대답은 \"정답이 아닌 다른 사람의 의견이 궁금한 사람\"이었다. 정답은 아무래도 좋다. 우테코에서 지내면서 알게 된 것은 잘못된 것은 없다는 것이다. 나름대로 그 사람의 철학과 가치관이 담겨 있는 의견들이었다. 그래서 함부로 남의 의견을 매도하고 싶지 않았다. 맞고 틀림이 아니라 순수하게 상대방의 의견을 들을 줄 아는 사람이 되고 싶다. 포비한테 대답한 내용이 완전하게 지금의 나와 같지는 않을 수 있다. 앞으로 더 나아지면 된다고 생각한다.\n"},{"excerpt":"LOG 점심: 시부야 저녁: 수가성 오늘은 포비의 강의가 있었다. 내일 글렌과 제이가 발표라서 리허설을 같이 봤는데, 포비가 같이 오셔서 피드백 해주셔서 신기했다. 내 발표가 아니라서 그런지 (ㅋㅋ) 질문 듣는 게 재밌었다. 의외로 저녁 밥을 먹고 나니 저녁에 공부할 시간이 많지 않았다. 그래도 오늘 저녁에 남아 있어서 미션 리팩토링을 좀 더 할 수 있었…","fields":{"slug":"/2023-02-22/"},"frontmatter":{"date":"2023년 02월 22일 01:02","title":"2023년 02월 22일","tags":null},"rawMarkdownBody":"## LOG\n- 점심: 시부야 저녁: 수가성\n- 오늘은 포비의 강의가 있었다. 내일 글렌과 제이가 발표라서 리허설을 같이 봤는데, 포비가 같이 오셔서 피드백 해주셔서 신기했다. 내 발표가 아니라서 그런지 (ㅋㅋ) 질문 듣는 게 재밌었다.\n- 의외로 저녁 밥을 먹고 나니 저녁에 공부할 시간이 많지 않았다. 그래도 오늘 저녁에 남아 있어서 미션 리팩토링을 좀 더 할 수 있었다.\n- 컨디션이 좋지는 않았다. 그래서인지 미션 구현에 집중을 많이 하지 못했다. 내일은 꼭 미션을 제출하고 집에 갈 예정이다.\n\n## 배운 것\n- LinkedHashMap을 사용하면 추가된 순서대로 저장된다.\n- nextInt()의 경우 개행이 사라지지 않아 다음에 nextLine 입력을 받을 때 버퍼에 남은 개행이 입력될 수 있다. 차라리 일괄적으로 nextLine을 사용하는 것이 좋은 것 같다.\n\n## 궁금한 것\n- 권위에 도전하기 위해 상대방에게 말을 건넬 때, 어떻게 하면 더 좋은 말로 할 수 있을까?\n- 상대방에게 상처를 주지 않고 의견을 건네는 방법은 어떤 방법이 있을까?\n- LinkedHashMap을 사용했는데, 키 값이 한글일 때 순서가 유지되지 않는 이유는 무엇일까? \n\n## 어려운 것\n- 여전히 미션에 집중하기 어렵다. 컨디션 때문인지, 이번 미션에 흥미가 떨어져서인지... 열정이 식은 건 아닌 것 같지만 집중이 잘 안 된다. 강의실에서 해 봐야 하나?\n\n## 느낀 것\n- 내가 이루고 싶은 것이 무엇인지 항상 생각하고 있어야 할 것 같다. 시간은 빠르고, 지금도 흘러가고 있다. 매일매일 생각하지 않으면 금방 잊어버린다. 내일도 더 잘하고 싶고, 무엇이든 배우는 것에 집중하고 싶다.\n- 내가 어떻게 보이는지는 마음먹기에 달렸다는 생각을 했다. 신기하게도 그때 이후로 마음을 편하게 먹을 수 있게 되었는데, 그냥 이 상태가 좋다. 오늘 포이한테도 말했지만 내가 우테코에 와서는 여기서만 할 수 있는 것들을 해보고 싶다. 딱 우테코 기간 동안 예전의 나와 다른 사람이 되어 보고 싶다. 굳이 기간을 그렇게 잡은 이유는 앞으로 그렇게 되자는 목표가 너무 거창하기 때문이다. 포비가 말했듯이 작은 것부터 도전해나가는 중이다.\n- 내일 출입증이 나온다고 한다! 토리 말로는 웰컴키트를 준다던데 궁금하다. 우형은 지금 전면 재택중이라고 한다. 조금 동기부여가 된 것 같다.\n- 모르는 주제로 테코톡을 해보려고 한다. 레벨2때 하고 싶은데 다들 그때 하고 싶어해서.. 여차하면 레벨3까지 늦춰질 수도 있을 거 같다.\n- 내일은 레벨1 조와 점심을 먹는다. 이번에는 어떤 사람들과 같이 밥을 먹을지 궁금하다. 예전에 들었던 말 같은데 밥 먹으며 하는 이야기가 중요하다는 얘기가 있었다. 확실히 그럴지도.\n- 생각해보니 집에 와서 뭘 하는 걸까 ㅋㅋㅋ TIL도 자기 10분 전에 쓰는데 그 전에는 뭘 하는거지? 분명 집에 가는 길에는 어떤 걸 하고 싶다는 생각을 했었는데 집에 들어오면 그런 생각이 사라진다. 차라리 집 가는 길에 책을 읽어보는 건 어떨까.\n"},{"excerpt":"Java 왜 ArrayList의 add는 boolean을 리턴할까? 예외가 try, finally에서 동시에 발생하면 어떻게 될까? 스택 풀기 Spring @Controller vs @RestController DAO와 Repository의 차이점 @Mock vs @MockBean SQL TEXT와 VARCHAR의 차이점이 무엇일까? 디자인 패턴 상태 패…","fields":{"slug":"/short-programming-knowledge/"},"frontmatter":{"date":"2023년 02월 21일 14:02","title":"짧은 개발 지식","tags":["개발"]},"rawMarkdownBody":"\n## Java\n\n* [[why-return-type-of-add-function-is-boolean|왜 ArrayList의 add는 boolean을 리턴할까?]]\n- [[simultaneously-throw-exception|예외가 try, finally에서 동시에 발생하면 어떻게 될까?]]\n- [[stack-unwinding|스택 풀기]]\n\n## Spring\n\n- [[controller-vs-restcontroller|@Controller vs @RestController]]\n- [[dao-vs-repository|DAO와 Repository의 차이점]]\n- [[mock-vs-mockbean|@Mock vs @MockBean]]\n\n## SQL\n\n- [[text-vs-varchar|TEXT와 VARCHAR의 차이점이 무엇일까?]]\n\n## 디자인 패턴\n\n- [[state-pattern|상태 패턴이란?]]"},{"excerpt":"틀린 내용이 있을 수 있습니다. 모든 지적을 환영합니다. ArrayList의 add 리스트 미니 미션을 수행하다가 들었던 궁금증이었다. 와 는 뭐가 다르길래 리턴 타입이 다를까? 궁금하지 않는가? 강의에서 ArrayList의 boolean add는 항상 true를 리턴해서 왜 그렇게 구현했는지 모르겠다는 이야기를 들었다. 나도 그때 당시 그 말에 공감했다…","fields":{"slug":"/why-return-type-of-add-function-is-boolean/"},"frontmatter":{"date":"2023년 02월 21일 05:02","title":"왜 ArrayList의 add는 boolean을 리턴할까?","tags":["개발"]},"rawMarkdownBody":"**틀린 내용이 있을 수 있습니다. 모든 지적을 환영합니다.**\n\n## ArrayList의 add\n\n- 리스트 미니 미션을 수행하다가 들었던 궁금증이었다. ```void add(int index, String value)```와 ```boolean add(String value)```는 뭐가 다르길래 리턴 타입이 다를까? 궁금하지 않는가?\n- 강의에서 ArrayList의 boolean add는 항상 true를 리턴해서 왜 그렇게 구현했는지 모르겠다는 이야기를 들었다. 나도 그때 당시 그 말에 공감했다. 그런데 index로 값을 추가하는 메서드의 리턴 타입은 'void'라는 것이 뭔가 이상했다.\n\n## Collection\n\n정답은 Collection 인터페이스에 존재한다.\nCollection에 ```boolean add(E e)``` 의 docs를 확인해보자.\n\n```\nReturns {@code true} if this collection changed as a result of the call.  \nReturns {@code false} if this collection does not permit duplicates and already contains the specified element.\n```\n```호출의 결과로 이 컬렉션이 변경된 경우 true를 반환한다. 이 컬렉션에서 중복을 허용하지 않고 지정된 요소가 이미 포함되어 있으면 false를 반환한다.```\n\n즉, Collection의 boolean add(E e)는 중복을 허용하지 않는 하위 컬렉션의 경우를 고려해서 만든 것이다!\n\n```\nadd를 지원하는 컬렉션은 이 컬렉션에 추가할 수 있는 요소에 제한을 둘 수 있다. 특히 일부 컬렉션에서는 null 요소의 추가를 거부하고 다른 컬렉션에서는 추가할 수 있는 요소의 유형에 제한을 가한다.\nCollection 클래스는 문서에 추가할 수 있는 요소에 대한 제한 사항을 명확하게 명시해야 한다.\n\nCollection이 이미 요소를 포함하고 있다는 이유 이외의 이유로 특정 요소 추가를 거부하는 경우 false를 반환하지 않고 예외를 발생시켜야 한다. 이렇게 하면 이 호출이 반환된 후 컬렉션에 항상 지정된 요소가 포함된다는 불변성이 유지된다.\n```\n\n## ArrayList의 add 함수\n\n```\npublic boolean add(E e) {\n         modCount++;\n         add(e, elementData, size);\n         return true;\n     }\n```\n     \n```\npublic void add(int index, E element) {\n        rangeCheckForAdd(index);\n\tmodCount++;\n\tfinal int s;\n\tObject[] elementData;\n\tif ((s = size) == (elementData = this.elementData).length)\n\t\telementData = grow();\n\tSystem.arraycopy(elementData, index, elementData, index + 1, s - index);\t\t\t      elementData[index] = element;\t\t\t\t\t\t              \n\tsize = s + 1;\n}\n```\n이제 이 부분을 이해할 수 있다. ArrayList는 중복을 허용하므로 false가 리턴되는 경우가 없어 항상 true를 리턴하는 것이다.\n\n## 왜 리턴 타입이 다를까?\n\n- 아래 참고 링크를 통해 답을 유추할 수 있었다. 우리가 add 메서드를 생각할 때, 리턴 타입이 void일 것이라고 예상하는 게 당연하다. 그런데 add 메서드는 Collection 인터페이스에 포함되어 있는 함수로, ArrayList, HashSet 등 Collection 클래스들은 모두 동일한 메서드 시그니처를 오버라이딩하여 구현한다.\n- HashSet의 add 함수는 ArrayList와 달랐다. HashSet의 add는 다음과 같다.\n\n```\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n\t    }\n```\n(HashSet은 HashMap을 사용해서 구현된다)\n\nArrayList와는 다르게 항상 true를 리턴하는 것이 아닌, 값의 존재 여부를 판단하고 true/false를 리턴한다. 즉, HashSet에서의 boolean add는 필요하다는 것이다. add 자체에서 값의 존재 여부를 판단한 후, 값의 삽입 여부를 호출부로 알려줘야 하기 때문이다.\n\n## contains로 확인한 다음에 add를 하면 void로 구현할 수 있지 않을까?\n\n(여기서부터는 약간의 뇌피셜이 있습니다.)\n- 싱글 스레드 환경에서는 괜찮을 수 있지만, 멀티 스레드 환경에서는 critical할 수 있다. 예를 들어 다른 스레드가 값을 추가하는 동시에 내 스레드에서 contains를 수행하여 값이 포함되었는지 여부를 확인할 수 있다. 이때 동시성이 제대로 체크되지 않을 가능성이 있다. (이 부분은 커널 코드를 보지 않았기 때문에 확실하지 않음)\n- 즉, 방금 값 추가를 시도해서 값이 존재할 수 있지만 동일한 자료구조에 동시에 접근하게 되어 내 스레드의 contains에서는 존재하지 않는다는 리턴값을 받을 수도 있다는 것이다. 따라서 이 경우에 set.contains와 set.add는 single/atomic한 행동이어야 한다. 그러므로 add에서 boolean을 리턴하는 것이 contains와 add를 동시에 실행하는 atomic operation 이어야 한다고 볼 수 있다.\n- HashSet과 같은 Collection의 구현체에서 boolean add의 필요성이 존재하므로, Collection의 add 함수의 리턴 타입은 boolean이 되어야 할 것이다. void를 리턴하게 되면 중복을 허용하지 않는 하위 컬렉션의 경우 위험성이 커지게 된다. ArrayList의 경우 그런 경우를 체크할 필요가 없으므로 항상 true를 리턴하는 코드를 작성한 것이다.\n\n## 그렇다면 ArrayList의 add(int index ...)의 리턴 타입은 왜 void 인가?\n\n- 해당 메서드는 index 위치에 값을 삽입하라는 메서드이다. index가 존재하는 Collection에서만 필요하므로 Collection의 메서드에는 빠져있는 것을 볼 수 있었다.\n- index를 다루는 Collection에서는 값을 넣지 못하는 경우가 존재하지 않으므로 굳이 boolean type을 쓸 이유가 없다. 따라서 리턴 타입을 void로 설정한 것으로 보인다.\n\n## 참고 링크\n- [stackoverflow 참고 자료](https://stackoverflow.com/questions/24173117/why-does-list-adde-return-boolean-while-list-addint-e-returns-void)\n"},{"excerpt":"LOG 오늘 점심은 제육이었다. 여기 와서 제육을 3번 먹었다 ㅋㅋㅋ 살면서 제육볶음을 사서 먹어본 적이 얼마 없는 것 같은데 의외로 맛있는 것 같다. 미션은 할 만한데 오늘 나온 List 과제가 진짜 하기 싫었다... 그래도 집 와서 마무리 해서 다행이다. 내일은 꼭 미션을 마무리하고 싶다. View 까지 안 된다면 핵심 로직만이라도 😭 디투가 우리 학…","fields":{"slug":"/2023-02-21/"},"frontmatter":{"date":"2023년 02월 21일 01:02","title":"2023년 02월 21일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘 점심은 제육이었다. 여기 와서 제육을 3번 먹었다 ㅋㅋㅋ 살면서 제육볶음을 사서 먹어본 적이 얼마 없는 것 같은데 의외로 맛있는 것 같다.\n- 미션은 할 만한데 오늘 나온 List 과제가 진짜 하기 싫었다... 그래도 집 와서 마무리 해서 다행이다. 내일은 꼭 미션을 마무리하고 싶다. View 까지 안 된다면 핵심 로직만이라도 😭\n- 디투가 우리 학교 선배라는 걸 알게 되었다. 선배들이 꽤 왔다고 들었는데 3명이나 있을 줄은 몰랐다. 심지어 모앱 수업은 같이 들었어서 더 신기했다 ㅋㅋㅋ 이 정도면 못 알아본게 신기하다.\n- 아마란스가 스터디 제의를 줬는데 내가 제풀에 지칠까봐 아쉽지만 거절했다 ㅠ 뭐든 하고 싶은 마음은 앞서지만 내가 감당하지 못할 걸 알고 있어서 더 아쉬운 것 같다.\n\n## 배운 것\n- 왜 배열의 add는 boolean을 리턴할까? : [[why-return-type-of-add-function-is-boolean|배열과 add 함수]]\n- checked exception을 안 쓰는 이유는? : [[effective-java-ed3|item 71]]\n\n## 궁금한 것\n- serialVersionUID가 뭘까. 강의 시간에 Exception, Error 코드(java 내부 코드)에서 나왔다.\n- 요즘 언어는 checked exception을 안 쓰는 이유는?\n\n## 어려웠던 것\n- 하기 싫은 미션을 얼른 끝내야 해서 어거지로(?) 하는 게 쉽지 않았다.\n\n## 느낀 것\n- 사람들의 생각을 알아보는 건 재밌는 것 같다. 그래서 남의 블로그 보는 게 재밌는건가 ㅋㅋ 여기 와서 예전의 나와 다르게 살아보려 하고 있는데 진짜로 주변 사람들한테 다르게 느껴지는 것 같아서 신기했다. 그렇다고 내가 잘 보이려고 연기하고 있거나 억텐을 끌어올린다기보다는 여러 가지 시도를 해보는 중이다. 이런 기회가 흔치 않으니까 이것저것 다 시도해보고 싶다.\n- 내 말투에 대해 되돌아보고 있다. 가끔 반응을 하느라 상대방의 말을 끊게 되는 경우가 있는데 사실 타이밍을 잘 못 잡겠다. 서로에게 생산적인 질문을 하는 사람이 되고 싶다.\n- 생각해보니 오늘 아침에 그렇게 피곤하지 않았다. 왜인지는 모르겠다. 커피를 마셨지만 역시나 전혀 효과가 없다. 이럴 거면 커피를 안 마셔도 되지 않을까? 그렇다고 단 걸 마시자니 탄수화물이 걱정된다.\n- 의외로 나와 이야기가 잘 통하는 모르는 사람을 만났을 때는 그닥 어색함을 느끼지 않았다는 것을 느꼈다. 내가 편안함을 느끼고 대할 수 있는 사람의 특징은 뭘까? 예전에도 알아보려고 했던 것 같은데 아직 알아내지 못했다.\n"},{"excerpt":"2/21 Checked Exception, Unchecked Exception Checked Exception Checked Exception : Exception을 상속. compiled time에 catch 가능함. try catch를 사용하지 않으면 컴파일 에러가 발생한다. exception이 발생하는 메서드가 throws 예약어로 Exception…","fields":{"slug":"/level1-week3/"},"frontmatter":{"date":"2023년 02월 21일 01:02","title":"레벨1 3주차","tags":["우테코","레벨1"]},"rawMarkdownBody":"# 2/21\n## Checked Exception, Unchecked Exception\n### Checked Exception\n- Checked Exception : Exception을 상속. compiled time에 catch 가능함. try catch를 사용하지 않으면 컴파일 에러가 발생한다.\n- exception이 발생하는 메서드가 throws 예약어로 Exception을 호출 메서드에 전달해야 한다.\n### Unchecked exception \n- Run Time Exception이라고 한다.\n- 컴파일 시점에 Exception을 catch하는지 확인하지 않는다. 컴파일 시점에 Exception이 발생할 것인지의 여부를 판단할 수 없다.\n- Exception이 발생하는 메서드에서 throws 예약어를 활용해 Exception을 처리할 필요가 없지만 처리해도 무방하다.\n### Checked Exception, Unchecked Exception 선택 방법\n- (코틀린은 checked exception이 없다고 한다)\n- 호출하는 메서드가 Exception을 활용해 뭔가 의미있는 작업을 할 수 있다면 Checked Exception을 사용하라.\n- 호출하는 메서드가 Exception을 catch해서 예외 상황을 해결하거나 문제를 해결할 수 없다면 Unchecked Exception을 사용하라.\n- 명확하지 않다면 Unchecked Exception을 사용하라.\n- 내 생각: checked Exception을 사용하지 않아도 될 것 같다. 낮은 수준에서 checked exception을 사용한 경우 그 함수를 사용하는 모든 함수에서 throws를 사용하게 되어 함수를 사용하기 어렵다. (후추의 추가 의견 : checked exception이 안정성을 완벽히 보장하는 것이 아니다. 사용하는 쪽에서 예외처리를 어떻게 하느냐에 달려있기 때문이다.)\n### Exception 처리\n- 메소드에서 여러 개의 Exception을 throw 하는 경우 쉼표로 구분할 수 있다.\n- 메서드에서 여러 개의 Exception을 throw할 때 부모 클래스로 예외를 전달하는 방법도 있다. (ObjectStreamException, UnknownHostException을 Exception으로 통합해서 던지는 것)\n- 메서드를 호출할 때 예외를 처리한 후, 예외를 재전달(rethrow)하는 것도 가능하다.\n### 복구\n- 예외가 발생한 문제를 정상 상태로 돌려놓는다. (파일 등에 저장을 해두는 등)\n- 재처리 또한 복구에 해당된다.\n```\nint readTryCount() {\n  try {\n      return Integer.parseInt(InputView.read());\n        } catch (final NumberFormatException e) {\n\t    return readTryCount();\n      }\n  }\n```\n### 회피\n- 직접 예외를 처리하지 않고 호출한 쪽으로 회피할 수 있다.\n- 고민없는 회피는 외면하는 것과 같다. 회피를 할 때는 많은 고민 후 결정한다.\n### 무시\n- catch에 아무런 로직도 없는 경우\n- 진짜 외면하는 경우도 있다. 무시를 하는 경우는 더 많은 고민이 필요하다.\n### 전환\n- Checked Exception을 Unchecked Exception으로 전환할 수 있다.\n- DbException 같은 경우 도메인 계층까지 전달되기 전에 추상화 계층에 맞는 예외로 변경 하거나 적절한 시점에 예외를 처리할 수도 있다.\n## List\n- 데이터 저장 방식: ArrayList와 LinkedList\n- ArrayList: 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해서 데이터를 복사하는 방법을 사용\n- LinkedList: 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다.\n\n# 2/22\n## 슬기로운 우테코 생활\n- 절망의 골짜기. 내가 재작년~작년에 경험했었는데 지금은 좀 더 올라가는 중인 것 같다. 아직 절망의 골짜기이지만 기울기가 양수가 되어가는 시점이 아닐까?\n- 레벨1: 경쟁의식 버리기. 옆 크루와 같이 학습하고 성장하는 방법을 찾는다. 주변과 비교하지 않고 '나의' 배움과 성장에 집중한다. 내 가장 큰 라이벌은 옆의 크루가 아니라 어제의 나라는 것을 잊지 말기.\n- 레벨2, 3: 꾸준함, 소프트스킬. 난이도가 높아지고, 성장은 더디고, 흥미는 떨어지는 단계. 자신만의 학습 방법을 찾고, 학습 속도를 유지하면서 꾸준히 학습하는 습관을 만든다. 기술적인 역량 외에 소프트스킬 역량을 향상시키는데도 관심을 가져야 한다. 특히 팀플에서 사람들 만날 때 더 어려움을 느낄 때가 많으니 소프트스킬을 향상 시킬 수 있는 좋은 기회라고 생각해보자.\n- 레벨4: 멘탈 관리. 수박 겉핥기 식의 다양한 지식 습득이 아닌 깊이 있는 지식 습득. 주변 상황 (기업 채용, 크루들의 취업 준비 등)에 휘둘리지 않고 꾸준히 학습에 집중하는 멘탈 관리. 나만의 철학 만들기.\n- 꾸준히 성장하는 크루들은 어제의 나와 경쟁하면서 꾸준히 배움과 성장에 집중한다. 기존의 학습 방법, 틀을 빨리 깨트리는, 버릴 수 있는 용기를 가진 크루가 꾸준히 성장할 수 있다. 주변에도 이런 사람이 있는데 나도 오로지 내 성장에만 집중하는 사람이 되어야겠다. 어차피 시간 들이면 내가 더 잘한다는 마인드로!\n- 뭔가 다 하는 것은 어렵지 않다. 그냥 하면 된다. 그렇지만 남들이 하고 있는데 나는 아직 할 준비가 되지 않아서, 부족하다고 생각해서 내 공부에 집중하는 것도 정말 중요하다. 그럴 수 있어야 한다. 그 길이 더 빠른 길이라는 믿음이 있어야 한다.\n- 알고리즘... 나도 해야 하긴 하는데 나 또한 지금은 아닌 것 같다. 우테코에 들어오려고 했던 건 알고리즘을 하는 게 아니라 협업과 백엔드 경험을 하기 위해 들어왔기 때문에 알고리즘은 나중으로 미루는게 좋을 것 같다.\n### 어떻게 살아야 할까\n- 필요한 것은 권위에 도전할 수 있는 용기\n- 권위에 도전하는 과정이 내가 진정 좋아하는 일, 잠재력을 찾는 과정\n- 변화를 만들려고 할 때 가장 작은 것부터라도 시작해보기. 당연시 하던 학습 방법, 책을 읽는 방법 등 내가 변화를 만들 수 있는 가장 작은 시도부터 시작해보자. 하다가 안 되어 힘들 때는 주변 사람들을 활용하자. 주변 사람에게 위로와 에너지를 받아 다시 시도해보자. 또 안 되면 잠깐 쉬어도 괜찮다. 도전했다는 것 자체가 좋은 거다.\n- 변화를 만들기 위해서는 의지력보다는 환경이 더 중요하다. 변화하기 좋은 환경을 만들자. 나도 우테코에 와서 생각보다 다른 사람과 이야기도 많이 하고, 나와 다른 사람을 일부러 만남으로써 다양한 관점으로 바라볼 수 있는 것 같다.\n- 주변 환경을 정리해서 꾸준히 학습할 시간을 확보한다.\n- 다른 사람의 경쟁/비교보다 어제의 나와 비교해서 성장했는지에 집중한다.\n# 2/24\n## 사다리 타기 피드백\n### 접근 방식\n- Out->In 접근 방식: 도메인 지식이 없거나 요구사항을 객체로 도출할 수 없는 경우. tdd 구현시 특정 상태를 분리해 시작하는 것이 중요하다. 작은 단위부터 tdd 시작하기.\n- In->Out 접근 방식: 도메인 지식이 있거나 요구사항을 객체로 도출할 수 있는 경우. 가장 작은 단위의 객체(In)부터 기능을 추가하면서 Out 방식으로 완성해나간다. 그러나 시작 단계에서 가장 작은 단위의 객체를 찾는 것이 쉽지 않다.\n- 둘 중에 하나만 사용하지는 않는다. 핑퐁하듯이 사용한다.\n- 객체 설계 사이클: 테스트 실패 -> 테스트 성공 -> 리팩터링\n### 객체 설계 방식\n- Out -> In으로 시작한다. 도메인 지식으로 설계할 수 있는 부분까지 설계\n- 요구사항을 분석한다. 도메인 설계에서 Object graph 중 가장 마지막 노드(의존성을 가지는 객체가 하나도 없는 객체)부터 구현을 시작하는 것이 TDD로 접근하기 수월하다.\n- 요구사항 기반으로 객체를 도출한다.\n"},{"excerpt":"LOG 오늘은 그 분과 만날 수 있는 (아마도) 마지막 날이었다. 그 전의 나와 지금의 나는 많이 달라진 것 같다. 어느 정도 마무리 단계일 때 괜찮아졌다고 생각했는데 아직도 괜찮지는 않은 것 같다. 그래도 앞으로는 더 마음 편하게 살려고 노력하고 싶다. 예전보다는 더 나은 내가 되고 싶다. 아침에 많이 이야기 하고 와서 그런지 오늘은 좀 더 마음 편하게…","fields":{"slug":"/2023-02-20/"},"frontmatter":{"date":"2023년 02월 20일 05:02","title":"2023년 02월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘은 그 분과 만날 수 있는 (아마도) 마지막 날이었다. 그 전의 나와 지금의 나는 많이 달라진 것 같다. 어느 정도 마무리 단계일 때 괜찮아졌다고 생각했는데 아직도 괜찮지는 않은 것 같다. 그래도 앞으로는 더 마음 편하게 살려고 노력하고 싶다. 예전보다는 더 나은 내가 되고 싶다.\n- 아침에 많이 이야기 하고 와서 그런지 오늘은 좀 더 마음 편하게 지낼 수 있었다. 편한 내가 훨씬 살기 편한 것 같다.\n- 체인저가 진행하는 주간 회고 모임에 들어갔다. 우테코에서 하게 된 첫 모임(?)인데 기대된다. 내가 TIL 적는게 약간 혼잣말 하는 것 같아서 동기부여가 잘 안 됐는데 같이 하면 좋지 않을까? 주간 회고 때 한 말을 블로그에 적어보는 것도 좋겠다.\n## 배운 것\n- 구현하는 프로젝트에서 사용하는 도메인 용어를 사용할 때에는 주의한다. 기존 단어의 의미와 프로젝트 내에서 사용되는 도메인적인 의미가 뒤섞이지 않도록 유의한다.\n- IllegalStateException과 IllegalArgumentException을 구분하는 것은 중요하다. 둘 중 어떤 예외가 발생하는지에 따라 외부의 값이 잘못되었는지, 프로젝트 내의 객체나 로직이 잘못되었을지를 파악하여 다르게 처리해야 하기 때문이다. IllegalArgumentException의 경우 사용자 / 클라이언트에게 올바른 값을 입력하는 것을 요청해야 하고, 후자는 서비스 로직에 문제가 있다고 파악할 수 있다. 후자의 경우는 일시적 문제일 수 있기에 이전에 사용자가 입력한 값을 재사용하여 자체적으로 재시도하는 로직을 추가할 수도 있다.\n## 궁금한 것\n- 어떻게 하면 객체에 책임을 잘 나눌 수 있을까? 오늘 미션을 계속 고민하면서 이 방향이 맞는지, 저 방향이 맞는지 생각하는데 바로 떠오르지 않았다. 어떻게 하든 뭔가 완벽하지 않은 느낌이 계속 들었다. 이런 식으로 설계하면서 미션을 진행해도 되는걸까?\n## 느낀 것\n- 나와 다른 사람들을 좀 더 잘 이해해보고 싶다. \"그냥 그런 사람\" 이라고 생각하는 것보다 상대를 이해해보려고 하는 자세가 훨씬 좋아보인다.\n- 예전의 내 태도를 반성하게 됐다. 그때는 지금보다 부정적이고 나와 다른 사람을 굳이 이해하기 위해 노력하는 사람은 아니었던 것 같아서. 지금 돌아보니 좋은 태도가 아니었다. 그래도 남아있어 준 사람들이 오히려 대단할지도 모른다.\n"},{"excerpt":"LOG 포이가 내 위키를 염탐하고 있다고 하면서 TIL이 무섭다고 했다(?) 대체 뭐가 무서운데!! 데일리 조와 같이 점심을 먹었다. 브라운이 추천했던 토도로끼에 갔는데 꽤 맛있었다. 쇼유라멘 좋아 배운 것 : github 강제 push하는 방법 IllegalStateException: 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알리…","fields":{"slug":"/2023-02-17/"},"frontmatter":{"date":"2023년 02월 18일 12:02","title":"2023년 02월 17일","tags":null},"rawMarkdownBody":"## LOG\n- 포이가 내 위키를 염탐하고 있다고 하면서 TIL이 무섭다고 했다(?) 대체 뭐가 무서운데!!\n- 데일리 조와 같이 점심을 먹었다. 브라운이 추천했던 토도로끼에 갔는데 꽤 맛있었다. 쇼유라멘 좋아\n## 배운 것\n- ```git push -u origin +master --force```: github 강제 push하는 방법\n- IllegalStateException: 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알리는 예외\n- IllegalArgumentException: 메서드에 잘못되거나 부적절한 매개변수가 전달되었음을 알리는 예외\n- ```assertDoesNotThrow(() -> code ...);```: ```assertThatCode(() -> 예외 코드).doesNotThrowAnyException()``` 대신에 ```org.junit.jupiter.api.Assertions.assertDoesNotThrow```를 사용할 수 있다.\n- 회고를 잘하는 방법을 배웠다. - [[level1-week2|회고를 잘하는 방법]] 나는 개선점만 말하는게 회고인줄 알았는데 감정 회고도 중요하다고 해서 신기했다. 좋은 말로 상대의 개선하는 점을 말하는 것도 배우면 좋을 텐데 쉽지 않다.\n## 궁금한 것\n- 프리코스 때 enum static 함수로 값을 입력 받아 해당 값과 동일한 enum 객체를 리턴하는 함수를 사용했었는데, 이게 좋은 함수 형식이 맞을까? 그때는 그냥 아무 생각 없이 썼었는데 이번 미션의 라인 클래스를 리팩토링하다 고민이 되었다. ```List<Boolean>``` 형식의 line을 ```List<State>``` 이런 식으로 enum을 사용해서 리팩토링할까했는데 이 질문 때문에 결국 그만뒀다. 다음 주에 다른 사람들한테 물어봐야겠다.\n## 어려웠던 것\n- 여전히 어색한 분위기를 참기 힘들다. 어색한 분위기 속에서 불쑥 뭔가를 물어보는 게 내 입장에서는 굉장히 큰(?) 용기였는데 곰곰히 생각해보니 굳이 그럴 필요가 있나라는 생각이 든다. 심지어 딱히 아이스 브레이킹이 되는 것 같지도 않다. 침묵을 참아내는 것도 능력인 것 같다.\n## 느낀 것\n- 우테코에 와서 소프트 스킬이 정말 굉장히 매우 중요하구나... 라는 생각이 계속해서 든다. 이렇게 많은 모르는 사람들을 단시간에 만나기도 쉽지 않은데 여기에서 많이 배워가고 싶다. 주변에 사람들과 쉽게 이야기를 하는 분들이 많은데 나도 배우고 싶다 ㅋㅋ\n- 무엇보다 정말로 궁금한 것이 많은 사람들이 대단하다. 관심을 갖고 알아가고 싶은 마음이 궁금증을 자아내는게 아닐까? 공부든 뭐든 관심을 갖고 알아가려는 태도는 배울만하다.\n- prolog 써야 할 것 같다. 집 가기 전에 포이가 가변 인자에 대해서 질문한 부분이 있었는데 가변인자가 Objects[]로 변환된다는 사실은 몰랐어서 신기했다. 질문들이 다 깊은 질문들이고 내가 '그냥' 쓰는 것들에 의문을 가지는 형식이어서 정말 도움이 많이 될 것 같다. 근데 시간이 있을까...? 요즘 자꾸 TIL도 밀려서 속상하다 😢\n- 잠이 너무 많아졌다. 아침에 일찍 일어나고 출퇴근 시간에 좀 시달리다보니 몸이 피곤한 듯... 공부하고 싶은데 체력이 모자라다.\n"},{"excerpt":"LOG 도치와 페어프로그래밍 마무리 하다가 추상 팩토리 얘기 잠깐 했는데 구구가 그걸 왜 쓰냐고 해서 즉석 피드백 시간이 열렸다. 이번에 페어 프로그래밍할 때 생성자에서 매개변수를 좀 줄이고 싶어서 그 부분을 피드백 요청했다. 구구가 한 질문들이 굉장히 생각해볼만한 질문들이어서 좋았다. 우리가 쓴 것이 Controller인 것인지? Controller는 …","fields":{"slug":"/2023-02-16/"},"frontmatter":{"date":"2023년 02월 17일 04:02","title":"2023년 02월 16일","tags":null},"rawMarkdownBody":"## LOG\n- 도치와 페어프로그래밍 마무리 하다가 추상 팩토리 얘기 잠깐 했는데 구구가 그걸 왜 쓰냐고 해서 즉석 피드백 시간이 열렸다. 이번에 페어 프로그래밍할 때 생성자에서 매개변수를 좀 줄이고 싶어서 그 부분을 피드백 요청했다. 구구가 한 질문들이 굉장히 생각해볼만한 질문들이어서 좋았다. 우리가 쓴 것이 Controller인 것인지? Controller는 왜 써야 하는지? 전략 패턴을 사용한 이유는 무엇인지? 굳이 생성자의 매개변수를 줄일 필요가 있을지? LineStrategy가 util에 있는 이유는 무엇인지? 질문도 좋았지만 중간중간 구구의 인정을 받아서 기뻤다 ㅋㅋ\n- 나는 구구의 피드백을 받을 때 말투가 날카롭다고 생각하지 않았는데 확실히 관점의 차이가 있는 것 같다. 아무래도 지피에 있을 때 자주 질문을 받아서 그런지 오히려 이정도는 좋은 피드백이라고 생각했다. 내가 말을 할 때도 날카롭게 질문하는 거라고 받아들이는 사람이 있을 수도 있겠다는 생각이 들었다. 좀 더 유하게 말하는 연습을 해봐야겠다.\n## 배운 것\n- 패키지를 결정할 때 해당 클래스가 어떤 역할을 하고, 어디서 사용하는지 고려해서 패키지를 정하자.\n- 최대한 불필요한 것은 없애보자. (이건 구구의 견해일 수도 있다.)\n- mermaid를 사용하면 클래스 사이의 관계와 프로그램 구조를 한 눈에 볼 수 있다. github readme에 쉽게 붙여넣을 수 있어 더 좋다.\n## 궁금한 것\n- 지금은 안 쓰이지만 나중에 필요할 것 같은 클래스를 미리 구현해놓는 것은 굳이 할 필요가 없을까? 이런 생각이 당연하게 \"맞다/아니다\"라는 답변을 내릴 수 있는 것인지, 단순 취향 차이인지 궁금하다. 구구는 내가 아직 경험이 많이 쌓이지 않아서 나중에 구현되면 좋을 클래스의 예시도 제대로 못 드는 상태에서는 안 쓰는게 낫다고 했지만, 다른 사람들의 견해도 궁금하다. 혹시 이 TIL을 보는 사람은 생각을 댓글로 달아주세요.\n## 느낀 것\n- 이번 미션에서 기능 구현 우선순위를 정해놓는 것이 좋겠다는 생각을 했다. 처음부터 설계를 완벽하게 하기보다는 점진적으로 만들어가는 애자일 방식으로 구현하는 게 미션을 빠르게 구현할 수 있는 방법 같다. 사실 부가적으로 구현되는 부분에 집중하다보니 메인 기능에 시간을 많이 못 쏟은 것 같아서 아쉽다.\n- 지피에서 선배들, 후배들과 이야기하는 시간이 정말 많이 도움이 되었다는 생각을 새삼스럽게도 했다. 거기서 키워드도 주워 듣고, 건전한 토론을 하는 방법을 배울 수 있어 좋았던 것 같다. 앞에 나서는 연습을 했던 것도 많이 도움이 되었다. 모두 지피하세요 :)\n- 예전에는 권위있는 사람의 말을 무조건 경청하려는 습관이 있었는데, 이제는 내가 의도했던 것들/내 생각을 좀 더 자유롭게 말할 수 있는 것 같아서 성장했다고 느꼈다. 포비가 말하는 '권위에 도전하라'라는 말을 실천한 것 같아 기분이 좋다 😄\n"},{"excerpt":"LOG 웹 수업에서 HTTP, CSS, JS 배웠는데 역시 재미없다... 물건너간 풀스택의 꿈 runcat 안 되는 줄 알았는데 그냥 상태바가 자리가 없어서 안 보인 거였다... ㅎㅎ 오늘 아침에 지하철 타면서 객체지향의 사실과 오해 라는 책을 읽었다. 중간에 읽다가 졸려서 자긴 했지만ㅠ 오늘 도치랑 미션하면서 굉장히 고민을 많이했다. 지금 생각해보니 굳…","fields":{"slug":"/2023-02-15/"},"frontmatter":{"date":"2023년 02월 15일 02:02","title":"2023년 02월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 웹 수업에서 HTTP, CSS, JS 배웠는데 역시 재미없다... 물건너간 풀스택의 꿈\n- runcat 안 되는 줄 알았는데 그냥 상태바가 자리가 없어서 안 보인 거였다... ㅎㅎ\n- 오늘 아침에 지하철 타면서 객체지향의 사실과 오해 라는 책을 읽었다. 중간에 읽다가 졸려서 자긴 했지만ㅠ\n- 오늘 도치랑 미션하면서 굉장히 고민을 많이했다. 지금 생각해보니 굳이 생각 안 해도 되는 걸 생각했나? 라는 생각은 든다..ㅋㅋ 너무 어렵게 생각한 것 같기도 하고.\n## 느낀 점\n- 배운 점, 궁금한 점, 어려운 점이 없는 걸 보면 쓸 말이 없는 것 같다. 한 게 없으니.. 내가 우테코를 왜 하고 싶어 했었는지 기억했으면 좋겠다.\n- 페어에게 적당히 태클을 거는 것도 필요한 것 같다. 정확하게 의견을 피력하지 않으면 그대로 반영되기 때문에 아니다 싶은 거는 제대로 토론해야 한다. 오히려 우테코에 와서 페어 프로그래밍 하면서 내가 프리코스 때 짠 것보다 오버해서 짜는 느낌이다. 그때가 잘했다기 보다는 굳이 요구사항에서 나와있지 않은 것까지 어거지로 추가하는 느낌? 뭐든지 적당히가 좋을 듯.\n- 목표에서 멀어진 느낌이 난다. 여전히 나태하다고 생각한다. 하자고 했던 건 확실하게 지키자. 그게 미래의 나를 위한 길이다. 미래의 내가 지금의 나를 원망하지 않도록 최선을 다하자. 내일은 꼭 배운 것을 쓸 수 있으면 좋겠다.\n"},{"excerpt":"2/14 TDD, 리팩터링 production 코드가 잘 돌아가는지 검증하는 코드 -> Test Code TDD란? TFD(Test First Development) + 리팩토링. 실패하는 코드를 만들고 성공하게 하는 것. 일단 코드를 성공하게 한 다음에 정말 의미를 갖는 코드인지 리팩터링한다. TDD 하는 이유: 디버깅 시간을 줄여준다. 동작하는 문서 …","fields":{"slug":"/level1-week2/"},"frontmatter":{"date":"2023년 02월 14일 01:02","title":"레벨 1 2주차","tags":["우테코","레벨1"]},"rawMarkdownBody":"# 2/14\n## TDD, 리팩터링\n- production 코드가 잘 돌아가는지 검증하는 코드 -> Test Code\n- TDD란? TFD(Test First Development) + 리팩토링. \n- 실패하는 코드를 만들고 성공하게 하는 것. 일단 코드를 성공하게 한 다음에 정말 의미를 갖는 코드인지 리팩터링한다.\n- TDD 하는 이유: 디버깅 시간을 줄여준다. 동작하는 문서 역할을 한다. (단위테스트 있으면 동일한 거 아닌가?) 변화에 대한 두려움을 줄여준다. -> 왜 TDD를 해야 하는가?\n- 이미 구현된 코드에 대한 단위테스트를 작성하면 단순히 커버리지만 높은 코드가 나올 수 있다. (구현 사항을 이미 알고 있기 때문에)\n- 심적으로 안정감을 얻을 수 있다.\n- 처음부터 완벽한 설계를 하는 것이 아니라 점진적으로 설계를 개선해 나갈 수 있다. 과도한 설계에 따른 추가 비용을 해소한다.\n- 빠른 피드백을 받을 수 있다.\n### TDD 원칙\n1. 실패하는 단위 테스트를 작성할 때까지 프로덕션 코드를 작성하지 않는다.\n2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.\n3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.\n### 빠른 피드백을 통한 개발 효율\n- 버그를 찾는 시점이 빨라진다.\n- 일정한 리듬으로 일함으로써 프로그래밍에 재미를 느낌 (?)\n- 더 많은 삽질을 할 수 있다. (?) 삽질은 더 많은 배움이다.\n- 지금 필요한 것은 새로운 접근방식에 도전할 수 있는 용기\n## 개발을 잘한다의 기준은?\n- 코드 작성 시 가장 중요한 것은? -> 성능 / 가독성 / 유지보수성\n- 개발자가 코드를 신경쓰는 이유는 비용을 절약하기 위함이다.\n- 기술부채가 쌓이는 것은 어쩔 수 없는 것. 적절한 기술부채를 쌓을 수도 있어야 한다.\n- 언제나 자신만의 기준이 필요하다.\n- 내가 코드를 작성할 때 가장 중요한 것은? : 수정이 용이한 코드. 다른 사람이 읽기 쉬운 코드. 최선의 코드를 위해 적절한 기술부채를 쌓을 줄 알고, 적절한 시점에 기술 부채를 정리할 수 있어야 한다. \n- 테스트 커버리지는 어디까지?\n- 본인이 생각하는 자바를 잘한다는 기준은 무엇인가?\n- 자바를 잘하는 사람이 되기 위해 어떠한 시도를 할 것인가?\n- 미션을 진행하며 위 시도를 하였을 때 본인이 성장하고 있는지 어떻게 측정할 수 있는가?\n## 메타인지\n- 인지에 대한 인지, 생각에 대한 생각\n- 인지: 온갖 사물을 알아보고 기억하며 추리해서 결론을 얻어내고, 그로 인해 생긴 문제를 해결하는 등의 과정\n- 메타인지: 문제를 해결하는 것에 대해 생각하기\n- 메타인지 향상을 위해 내가 무엇을 알고 모르는지 판단. 학습 기록을 남기고 학습 로드맵을 그려보기!\n## 짝 프로그래밍 메타인지\n- 어떻게 하면 불확실성이 높은 현실 세계의 요구사항을 빠르게 반영하고, 유연하게 반응하고, 빠르고, 더 일찍 고객에게 가치를 전달할 수 있을까? -> 더 빠르게, 더 자주, 더 꾸준하게 피드백을 받기 위한 방법 중에 하나로 짝 프로그래밍을 시작한 것\n### 짝 프로그래밍의 장점\n- 버그 감소, 앱을 만들고 통합하는 시간이 감소\n- 디버깅이 잘 됨 -> 문제가 있을 때 상대에게 설명하는 순간 답을 아는 경우가 많아짐\n- 전문가의 암묵지를 효과적으로 배울 수 있는 장점이 있다. -> 단축키 어떻게 하는지, 모르는 버그를 만났을 때 어떻게 구글링하는지, 디버깅은 어떻게 하는지 등\n- 새로운 신입, 주니어 개발자가 오면 시니어와 짝 프로그래밍하는 경우도 많다. 개발 도메인 지식 뿐만 아니라 시니어가 갖고 있는 프로그래밍에 대한 전문성\n- 팀워크 향상: 갈등이 생기는 건 당연하다. 갈등을 더 작은 단위로 빠르게 만나고 빠르고 해소하는 경험을 할 수 있기 때문에 짝 프로그래밍이 팀워크 향상에도 도움이 된다.\n- 짝 용기: 같이 하기 때문에 혼자서 하기 어렵거나 두렵거나, 귀찮은 것들을 같이 해낼 수 있는 용기가 생긴다.\n# 2/15\n## 웹 기초\n### 인터넷이란?\n- 전 세계적으로 연결된 컴퓨터 네트워크\n- 네트워크의 네트워크\n### 웹이란?\n- 월드 와이드 웹 (WWW)\n- 인터넷에 연결된 컴퓨터를 이용해 사람들과 정보를 공유할 수 있는 공간\n### 하이퍼텍스트\n- 하이퍼링크를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트\n- 하이퍼텍스트는 링크에 따라 그 차례가 바뀌는 임의적이면서 나열형인 구조\n### 웹의 기능\n- URL : Uniform Resource Locator\n- HTTP : HyperText Transfer Protocol\n- HTML\n### URI vs URL\n- URI : 통합 자원 식별자. 인터넷에 있는 자원을 나타내는 유일한 주소. URI의 하위 개념으로 URL, URN이 있다.\n- URL : 흔히 웹 사이트 주소로 알고 있지만, URL은 웹 사이트 주소뿐만 아니라 컴퓨터 네트워크상의 자원을 모두 나타낼 수 있다.\n### HTTP\n- 웹 상에서 정보를 주고받을 수 있는 프로토콜\n- 주로 HTML 문서를 주고받는 데에 쓰인다.\n- HTTP는 요청과 응답으로 구성되어 있고, 클라이언트가 요청을 하면 서버가 응답하는 구조로 되어있다.\n- http:// 는 이 프로토콜을 사용해서 정보를 교환하겠다는 표시\n### HTML\n- 웹 페이지의 모습을 기술하기 위한 마크업 언어 (규약)\n- HTML 태그 : HTML을 기술하기 위해 사용하는 명령어의 집합. 여는 태그 + 닫는 태그로 구성되며 닫는 태그 없이 사용하는 태그도 있다. (element, attribute...)\n- ```<!DOCTYPE html>``` : 웹 브라우저가 HTML을 올바르게 표시할 수 있도록 버전 표시\n- p 태그 : 단락/문단을 구분\n- br 태그 : p 태그 없이 강제 개행\n- h# 태그 : 섹션의 제목을 나타내는 태그. 숫자들은 제목의 등급을 나타낸다.\n- a 태그: 하이퍼링크를 걸어주는 태그\n- img 태그: 이미지를 삽입하는 태그\n\n### CSS\n- 마크업 언어가 실제 표시되는 방법을 기술하는 언어\n- 디자인적 요소를 HTML과 분리해보자!\n\n# 2/16\n## 좋은 코드\n- 코드를 줄여쓰지 않는다. 코드 자체로 설명이 되도록 코드를 작성하면 유지 및 관리의 비용이 줄어든다. 주석을 달지 않아도 잘 읽히는 코드가 좋다.\n- 원시값을 포장하면 확실하게 의도를 코드를 통해 전달할 수 있다.\n- 일관된 코드 스타일을 가져야 동료 개발자의 혼동을 줄일 수 있다.\n- 하나의 역할만을 담당하라. 하나의 함수가 많은 일을 하면 추상화 계층이 나빠진다.\n- 추상화 계층: 특정한 집합의 기능의 자세한 부분을 숨기는 한 방법이다. (출처 - 위키백과) 추상화할 부분은 사람마다 다르다.\n- 매개변수를 명확히 해라. 매개변수는 함수를 부르는 곳에서 이해하기 어렵다. \n- 내 생각: 주석은 관리가 힘들기 때문에 최대한 자제하는 것이 좋다. 코드가 변경되었을 때 연관된 주석까지 바꾸기는 힘들기 때문이다.\n- 명확하지 않은 것도 문제가 되지만, 과한 설계도 독이 된다. 정답은 없으니 상황에 맞게 판단하자.\n- 적절한 API를 사용하면 견고한 코드를 작성할 수 있다.\n- 적절한 자료구조를 사용하는 것도 좋다. (중복을 허용하지 않는 set을 쓰는 등)\n- API를 위한 코드는 작성하지 말자. (stream이 주가 되는 경우 등)\n### 예측 가능한 코드\n- 의미있는 값을 반환하라. (값이 존재하지 않으면 -1을 응답하는 등) 차라리 예외를 반환하는 것이 좋을 듯. magic number를 사용하지 않도록 조심하기.\n- 값이 올바르지 않는 경우 외부에서 처리하도록 위임한다.\n- 정답은 없고, 설계를 할 때 문제\n- Collection은 값이 없다면 null이 아닌 빈 Collection으로 작성한다. 객체도 동일하게 Null Object라는 것을 사용한다. 시작되지 않은 위치일 때의 상황도 하나의 객체로 바라보자. \n- 부수효과를 제거하라. 명령과 조회가 같이 존재하지 않도록 하자.\n- 중요한 입력/비즈니스 로직에 대해 무시하지 마라. 아무것도 리턴하지 않는 대신에 사용자가 정보를 알 수 있게 확인하라.\n- 원시값을 포장하면 의도를 전달할 수 있고, 잘못 사용하기 어렵다. 상태가 불변한 경우 상태의 변화에서도 자유로울 수 있다. \n- 변경 가능성을 최소화한다. 매개변수를 변경하며 생길 수 있는 버그와 성능 중 무엇이 더 중요할 지 생각한다.\n- 객체의 값을 외부에 노출할 때 또한 방어적 복사(새로운 객체를 따로 생성하는 등)를 통해 보호해야 한다. 불변 구조(unmodifiableList)를 통해 외부로부터 방어할 수도 있다.\n- 가독성 높은 코드를 작성하기 위해 어떠한 노력을 했는가?: 어떤 메서드에서 다른 메서드를 사용할 때, 해당 메서드가 사용된 위치 바로 밑에 두어 잘 읽힐 수 있도록 코드를 작성했다. 또한 생성자에 들어가는 매개변수를 최대한 줄이기 위해 책임을 여러 클래스로 분산했다. \n- 예측 가능한 코드를 작성하기 위해 어떠한 노력을 했는가?: 최대한 주석을 제외하고, 변수 이름과 메소드 이름으로 동료 개발자가 이해할 수 있도록 노력했다. 사회적으로 통용되는(?) 단어를 사용하려고 노력했다.\n- 실수를 방지하는 코드를 작성하기 위해 어떠한 노력을 해봤는가?: 예외를 꼼꼼하게 처리했다. \n## 좋은 회고란?\n- 나를 돌아보고 다음에 더 개선할 부분이 있는지 생각하기 위해서\n### 감정 회고\n- 감정적으로 소통하는 것\n- 회고를 통해 꼭 구체적인 action plan이 없어도 된다. 감정 공유만으로도 가치가 있다.\n- 좋은 이야기만 할 경우 학습 개선도 행복도 얻기 힘들다. 좋았던 점, 개선할 점, 감정 회고가 적절히 섞여야 한다.\n- 상대방을 진정 위한다면 개선점이나 감정적인 부분에 대해서도 피드백을 해주면 성장하는데 많은 도움이 될 수 있다.\n- 감정을 표현할 때는 상대방이 주어가 되기 보다 '나'를 주어로 하는 문장을 쓴다.\n- 구체적인 행동과 상황을 공유하고 그 순간 느낀 감정에 대해 언급을 하는 것이 중요하다.\n- 큰 변화를 만드는 것이 중요한 것이 아니라 내가 작은 변화로 개선되는 것이 중요하기 때문에 우선순위에 따라 하나씩 개선해나가자.\n- todo 리스트를 작성해보고 시간 날 때 도전해보는 것도 좋다.\n"},{"excerpt":"LOG 세진, 용우를 만났다. 설입에서 잠깐 하이볼 마셨다. 피치 하이볼은 내 스타일은 아니었다. 1단계 merge가 되었다. 숨 돌릴틈도 없이 2단계를 해야 한다. 월요일에는 아마 내내 연극 준비할 거 같아서, 바로 2단계 PR을 보낼 생각이다. 배운 점 getter를 지양하지 않아도 되는 이유를 알게 되었다! 리뷰어 분의 아주 정성들인 리뷰 덕분이다.…","fields":{"slug":"/2023-02-12/"},"frontmatter":{"date":"2023년 02월 12일 09:02","title":"2023년 02월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 세진, 용우를 만났다. 설입에서 잠깐 하이볼 마셨다. 피치 하이볼은 내 스타일은 아니었다.\n- 1단계 merge가 되었다. 숨 돌릴틈도 없이 2단계를 해야 한다. 월요일에는 아마 내내 연극 준비할 거 같아서, 바로 2단계 PR을 보낼 생각이다.\n\n## 배운 점\n- getter를 지양하지 않아도 되는 이유를 알게 되었다! 리뷰어 분의 아주 정성들인 리뷰 덕분이다. 도메인에서 getter로 값을 뽑아낸 후 비즈니스 로직을 수행하는 것은 지양해야 한다. 그러나 미션에서 ```전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다.``` 같은 요구사항이 존재하므로 getter도 비즈니스 로직을 수행한다고 볼 수 있을 것 같다. getter를 지금까지 지양한 이유가 없어졌다..ㅋㅋ\n\n## 느낀 점\n- 내일이 월요일이라니...! 연극을 해야 한다는 게 매우 긴장된다. 대사 까먹지 않고 잘할 수 있었으면 좋겠다. 🥹\n- 오늘 친구들을 만나고 오면서, 새로운 사람들을 대할 때 내 방식대로 하는 게 나을지 아니면 방식을 바꿔보는게 좋을지 생각하게 되었다.\n"},{"excerpt":"LOG 자동차 경주 미션 코드 리뷰가 달렸다! 기대하고 있었는데 굉장히 상세하게 작성해주셨고, 어떤 부분을 고민해야 할 지 꼼꼼히 알려주셔서 많은 도움이 되었다. 연극을 열심히 준비하고 있다. 😎  아무래도 여기서 연극에 진심인 조는 우리 조 밖에 없는 것 같다...ㅋㅋ 배운 것 리뷰 DTO 내부에서 DTO를 사용해도 되는가? : 도메인과 DTO 사이에 …","fields":{"slug":"/2023-02-10/"},"frontmatter":{"date":"2023년 02월 11일 14:02","title":"2023년 02월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 자동차 경주 미션 코드 리뷰가 달렸다! 기대하고 있었는데 굉장히 상세하게 작성해주셨고, 어떤 부분을 고민해야 할 지 꼼꼼히 알려주셔서 많은 도움이 되었다.\n- 연극을 열심히 준비하고 있다. 😎  아무래도 여기서 연극에 진심인 조는 우리 조 밖에 없는 것 같다...ㅋㅋ\n\n## 배운 것\n### 리뷰\n- DTO 내부에서 DTO를 사용해도 되는가? : 도메인과 DTO 사이에 의존이 생기게 되면 DTO 변화에 따라 도메인이 영향을 받게 되어 좋지 않은 설계 같다. 특히 도메인의 변경보다는 View의 변경이 더 빈번한 만큼 DTO의 변경 또한 자주 일어나는데 그럴 때마다 도메인을 신경 써줘야 하므로 생각해보니 확실히 별로인 설계였다.\n- 테스트만을 위한 코드는 필요한가? : 해당 테스트 코드가 내 불안함을 해소하기 위한 것이라면 짤 수도 있다. 다만 jar 파일이 생성될 때 test 패키지 자체가 빠지기도 해서 전혀 사용되지 않는 코드가 덩그러니 남을 수도 있다. 역할과 책임을 분리하고 의존성을 부여하면 좀 더 쉬운 테스트 작성이 가능할 것이다.\n- 코드의 마지막 라인을 비워두는 것이 좋은 이유 : 줄 바꿈이 없으면 파일을 올바르게 처리하지 못하는 프로그램들이 있다. + POSIX에서 줄바꿈이 하나의 행을 정의하는 표준으로 정하고 있다.\n- 인텔리제이에서 메뉴 -> preference -> editor -> general 로 이동 -> Ensure every saved file ends with a line break 옵션 켜면 알아서 파일을 저장할 때마다 개행 문자를 추가해준다.\n- 페어 프로그래밍 : [[pair-programming-rule|좋은 페어 프로그래밍을 위한 규칙들]]\n\n## 궁금한 점\n- 의견을 걸러서 듣는 방법은 무엇일까? 특히 상대방이 나보다 훨씬 많이 알고, 전문가인 경우에 내 의견을 표출하는 방법은 무엇이 있을까?\n\n## 어려웠던 점\n- 별 것 아닌 거에 의미부여하는 것. 좀 더 근본적인 문제가 있는 것 같다.\n\n## 느낀 점\n- 무지성 공감이 별로 좋지 않다는 걸 알게 되었다. 내 주관을 제대로 정립하고 살아가는게 좋겠다는 생각을 했다.\n- 연극 잘할 수 있을까... 남들 앞에서 준비 안 된 채로 서면 말을 금방 까먹는 경향이 있어서 연습을 많이 해야겠다.\n"},{"excerpt":"주관적인 프로그래밍 원칙입니다. 페어와 조율할 예정입니다! 주의 사항 컴퓨터는 정확히 가운데에 두기 (주체, 객체의 형식이면 도움이 안 된다. 서로 수평인 관계, 공동이 주인인 관계를 만든다.) 관계가 비대칭인 경우 (전문가-비전문가), 전문가는 자신의 파워를 낮추고 비전문가에게 질문을 자주해야 한다. 비전문가가 진행할 수 있도록 유도한다. (답답해하기 …","fields":{"slug":"/pair-programming-rule/"},"frontmatter":{"date":"2023년 02월 10일 07:02","title":"페어 프로그래밍 원칙","tags":["개발","우테코"]},"rawMarkdownBody":"*주관적인 프로그래밍 원칙입니다. 페어와 조율할 예정입니다!*\n\n## 주의 사항\n\n1. 컴퓨터는 정확히 가운데에 두기 (주체, 객체의 형식이면 도움이 안 된다. 서로 수평인 관계, 공동이 주인인 관계를 만든다.)\n2. 관계가 비대칭인 경우 (전문가-비전문가), 전문가는 자신의 파워를 낮추고 비전문가에게 질문을 자주해야 한다. 비전문가가 진행할 수 있도록 유도한다. (답답해하기 금지!)\n3. 빈번하게 왔다갔다한다. 알람을 10분 정도로 맞추고, 타자를 다 안 쳤어도 시간이 지나면 바로 페어에게 키보드를 넘긴다.\n4. 키보드를 독점하지 않는다. Driver가 답답하다고 Navigator에게서 키보드를 뺏어가지 않는다.\n5. 페어가 생각할 여지를 남겨두지 않고 지시를 계속하지 않는다. (ex. print문 작성하세요. 새 클래스 만들어야 합니다 등등)\n\n## 역할 정의\n\n- Driver : 키보드를 잡은 사람\n- Navigator : 옆에서 보고 있는 사람\n- Driver는 혼자서 자신의 사고 과정을 중얼거리면서 코딩한다. 의도를 설명하라는게 아니라 중얼거리면서 자신의 생각 과정을 읊는 것이다.\n- Driver는 Navigator가 흥미를 잃지 않도록 항상 자신이 하고 있는 일에 대해 이야기한다.\n- Navigator는 문제 해결 방법을 논리적으로 생각하고, 그 과정을 상대에게 말로 설명하는 역할이다. Navigator가 Driver의 잘못된 부분을 발견한 경우 바로 지적하지 않고 5초 정도 잠깐 기다린다.\n"},{"excerpt":"AssertJ의 공식 문서를 정리한 문서이다. 공식 문서 사이트 @assertThatCode testing that no exception is thrown 어떤 exception도 던지지 않는 코드를 테스트할 수 있다. 비슷하게 사용하기 나는 주로 아래 방법을 사용한다.","fields":{"slug":"/assertj/"},"frontmatter":{"date":"2023년 02월 10일 05:02","title":"AssertJ","tags":["assertj","test","개발"]},"rawMarkdownBody":"* AssertJ의 공식 문서를 정리한 문서이다.\n* [공식 문서 사이트](https://assertj.github.io/doc/#assertj-core)\n\n## @assertThatCode\n- testing that no exception is thrown\n- 어떤 exception도 던지지 않는 코드를 테스트할 수 있다.\n```\n// standard style\nassertThatNoException().isThrownBy(() -> System.out.println(\"OK\"));\n// BDD style\nthenNoException().isThrownBy(() -> System.out.println(\"OK\"));\n```\n\n- 비슷하게 사용하기\n```\n// standard style\nassertThatCode(() -> System.out.println(\"OK\")).doesNotThrowAnyException();\n// BDD style\nthenCode(() -> System.out.println(\"OK\")).doesNotThrowAnyException();\n```\n나는 주로 아래 방법을 사용한다.\n"},{"excerpt":"assertj","fields":{"slug":"/test/"},"frontmatter":{"date":"2023년 02월 10일 05:02","title":"Test 정리","tags":["개발","test","assertj"]},"rawMarkdownBody":"\n* [[assertj]]"},{"excerpt":"LOG 자동차 경주 미션을 빠르게 제출했다. 1시간 정도 빨리 제출했는데 페어 프로그래밍이라 그런가 정신력이 좀 더 빠르게 소모된 것 같다. 리뷰가 어떻게 달릴지 궁금하다. 단축키를 많이 기억했다. 몇몇 단축키는 외운 것 같다! 지하철 타고 가면서 객체지향의 사실과 오해를 읽었다. 20% 읽긴 했는데 중간 중간 집중이 안 되는 부분이 있었다. 요즘 책을 …","fields":{"slug":"/2023-02-09/"},"frontmatter":{"date":"2023년 02월 09일 08:02","title":"2023년 02월 09일","tags":null},"rawMarkdownBody":"## LOG\n- 자동차 경주 미션을 빠르게 제출했다. 1시간 정도 빨리 제출했는데 페어 프로그래밍이라 그런가 정신력이 좀 더 빠르게 소모된 것 같다. 리뷰가 어떻게 달릴지 궁금하다. \n- 단축키를 많이 기억했다. 몇몇 단축키는 외운 것 같다!\n- 지하철 타고 가면서 객체지향의 사실과 오해를 읽었다. 20% 읽긴 했는데 중간 중간 집중이 안 되는 부분이 있었다. 요즘 책을 안 읽다 보니 집중력이 떨어진 것 같다. 의도적으로 책을 읽자.\n- 연극에서 조보아씨 역할을 맡게 되었다. 어쩌면 진짜 찰떡인 배역이었을지도?\n\n## 배운 것\n### Test\n- assertThat(list).hasSize(크기)를 사용해서 리스트의 크기를 확인할 수 있다.\n- @MethodSource를 사용하면 리스트를 입력으로 사용할 수 있다.\n- assertThatCode().doesNotThrowAnyException 을 사용하면 정상 작동을 테스트할 수 있다.\n- View를 인터페이스로 구현하면 MockView를 만들기 쉽다.\n- private 생성자를 사용해서 싱글턴을 유지할 수 있다. 싱글턴은 안티패턴이라던데 이렇게 써도 되는지 의문이긴 하다.\n\n## 궁금한 점\n- 코드의 마지막 라인은 비워두는게 좋다고 하는데 왜일까?\n- getter를 무조건 지양하는 게 맞는 설계일까?\n- DTO 내부에서 DTO를 써도 될까?\n- 한 줄로 축약해서 코드를 작성해도 괜찮을까?\n- 테스트만을 위한 메서드가 존재해도 괜찮을까?\n\n## 어려웠던 점\n- 부정적인 생각 덜 하기. 한 번 부정적인 생각이 들면 꼬리에 꼬리를 무는 것 같다.\n- 눈치 덜 보기. 하고 싶은 대로 살기. 머뭇거리지 않기.\n\n## 느낀 점\n- 굉장히 피곤한 하루였다. 아침에도 조금 피곤했는데 회의하느라 집에 늦게 도착해서 많이 피곤하다. TIL을 대강 쓰고 자려고 한다.\n- 이번 미션이 제일 쉬운 거였을텐데 이렇게 힘들어서는 곤란하지 않을까.\n- 사회성이 좀 떨어지나 싶다. 지금 상태가 그렇게 좋지 않은 것도 한 몫하는 것 같다. 지금이 좀 심하다 싶을 정도인 것 같다... 너무 스트레스 받지 않을 정도만 하자.\n"},{"excerpt":"2/9 assertj assertThatCode assertj assertThatThrown DTO 내부에 DTO 로직을 사용해도 되는가? 도메인 객체의 getter는 무조건 나쁜 것인가? View 클래스를 인터페이스로 작성하는 이유 - MockView를 만들기 위해 모든 컬렉션은 일급 컬렉션이 되어야 하는가? 3/17 스레드 풀 Concurrent Co…","fields":{"slug":"/inbox/"},"frontmatter":{"date":"2023년 02월 09일 06:02","title":"Inbox","tags":["임시"]},"rawMarkdownBody":"## 2/9\n- assertj assertThatCode\n- assertj assertThatThrown\n- DTO 내부에 DTO 로직을 사용해도 되는가?\n- 도메인 객체의 getter는 무조건 나쁜 것인가?\n- View 클래스를 인터페이스로 작성하는 이유 - MockView를 만들기 위해\n- 모든 컬렉션은 일급 컬렉션이 되어야 하는가?\n\n## 3/17\n- 스레드 풀\n- Concurrent Collection\n\n## 3/19\n- 바이너리 호환성, 소스 호환성, 동작 호환성 (모던 자바 416p)"},{"excerpt":"차례대로 보지 않을 예정이라 순서대로 쓰지 않는다. Item 1. 생성자 대신 정적 팩토리 메서드를 고려하라 정적 팩토리 메서드: 클래스의 인스턴스를 반환하는 단순한 정적 메서드 장점 이름을 가질 수 있어 반환될 객체의 특정을 쉽게 묘사할 수 있다. 시그니처가 같은 생성자가 여러 개 필요할 것 같을 때 생성자를 정적 팩토리 메서드로 변경하고 차이를 잘 드…","fields":{"slug":"/effective-java-ed3/"},"frontmatter":{"date":"2023년 02월 09일 00:02","title":"Effective Java 3/E","tags":["책"]},"rawMarkdownBody":"차례대로 보지 않을 예정이라 순서대로 쓰지 않는다.\n\n## Item 1. 생성자 대신 정적 팩토리 메서드를 고려하라\n- 정적 팩토리 메서드: 클래스의 인스턴스를 반환하는 단순한 정적 메서드\n- 장점\n\t1. 이름을 가질 수 있어 반환될 객체의 특정을 쉽게 묘사할 수 있다. 시그니처가 같은 생성자가 여러 개 필요할 것 같을 때 생성자를 정적 팩토리 메서드로 변경하고 차이를 잘 드러내는 이름을 지어주는 것이 좋다.\n\t2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 불변 클래스의 경우 인스턴스를 미리 만들거나 새로 생성한 인스턴스를 캐싱하여 활용하는 식으로 불필요한 객체 생성을 막을 수 있다.\n\t\t- 인스턴스 통제 클래스: 반복되는 요청에 같은 객체를 반환하는 식으로 인스턴스를 통제할 수 있다. 인스턴스를 통제하면 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가한 클래스로 만들 수도 있다. 또한 동치인 인스턴스가 단 하나뿐임을 보장 가능하다.\n\t3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 반환할 객체의 클래스를 자유롭게 선택할 수 있게 한다.\n\t4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관 없다.\n\t5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.\n- 단점\n\t1. \n## Item 71.  필요 없는 검사 예외 사용은 피하라\n- 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게 해준다. (과하게 사용하면 쓰기 불편한 API가 된다. 호출하는 쪽에서 try catch로 처리하거나 바깥으로 던져 전파해야 하므로 부담을 준다.)\n- 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없어서 자바 8부터는 부담이 커졌다.\n- API를 제대로 사용해도 발생할 수 있는 예외이거나 프로그래머가 의미 있는 조치를 취할 수 있는 경우는 받아들일 수 있다. 그러나 둘 중 어디에도 해당되지 않는다면 비검사 예외를 사용하는 것이 좋다.\n- 검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 가장 크다.\n- 검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 Optional을 반환하는 것이다. 대신 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.\n"},{"excerpt":"Java 이펙티브 자바","fields":{"slug":"/programming-book/"},"frontmatter":{"date":"2023년 02월 09일 00:02","title":"개발 책","tags":["개발","책"]},"rawMarkdownBody":"\n## Java\n\n- [[effective-java-ed3|이펙티브 자바]]\n"},{"excerpt":"LOG 연극 주제를 정했다. 주제 정하는게 많이 고민이었는데 순조롭게 잘 되어서 다행이다. 6시 40분에 일어났더니 9시에 도착했다. 언제 일어나는 게 좋을지... 좀 더 고민해봐야겠다. 그래도 지각하면 안 되니 아무리 늦어도 7시 10분에는 일어나야 할 것 같다. 아직 vim이 어렵다. vim 매크로 때문에 옵시디언 대신 vim으로 필기 중인데 여전히 …","fields":{"slug":"/2023-02-08/"},"frontmatter":{"date":"2023년 02월 08일 12:02","title":"2023년 02월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 연극 주제를 정했다. 주제 정하는게 많이 고민이었는데 순조롭게 잘 되어서 다행이다. 6시 40분에 일어났더니 9시에 도착했다. 언제 일어나는 게 좋을지... 좀 더 고민해봐야겠다. 그래도 지각하면 안 되니 아무리 늦어도 7시 10분에는 일어나야 할 것 같다.\n- 아직 vim이 어렵다. vim 매크로 때문에 옵시디언 대신 vim으로 필기 중인데 여전히 단축키가 어렵다. 한 번에 기억을 못하니 아직도 버벅거린다. 아침에 단축키 외우는 것도 좋을지도\n- 오는 길의 지하철이 매우 덥다. 내일은 옷을 따로 챙겨가야 할 것 같다. 사람이 많고 비좁다 보니까 더 그런 것 같다.\n- TDD로 미션 구현해 봤다. 오히려 구현하는 시간은 더 오래 걸릴지도 모르겠다. 그래도 신선한 경험이었다.\n- 우형에 붙게 된다면 한 학기 기다려준다고 한다. 남은 학점을 계산해보니 캡스톤 포함 20학점이다. 쉽지 않다...\n\n## 배운 것\n### 단축키\n- 오늘도 글렌에게 단축키를 배웠다. 근데 배워도 까먹는다... 쓰다 보니 몇 개 기억이 안 나는게 슬프다ㅠ\n- command + alt + m : 메서드 추출\n- iter : 향상된 for 문\n- fori : 일반 for 문\n- command + shift + t : 테스트 클래스 생성 (자동으로 해당 패키지까지 고려해서 만들어준다. 신기)\n### Test\n- @CsvSource : 문자열로 입력값, 정답을 함께 입력하여 사용하였다. 주로 @ParameterizedTest와 함께 쓰이는 듯 하다. delimeter로 구분자를 지정할 수 있다. 테스트 메서드의 매개변수를 int, boolean 같은 형으로 지정하면 해당 문자열을 알아서 변환해준다.\n- @BeforeEach : Test를 시작하기 전에 각 테스트 메서드마다 실행된다.\n\n## 어려웠던 점\n- 마음 편하게 먹기. 쉬워보였는데 쉽지 않다.\n- 긍정적으로 생각하기.\n\n## 궁금한 점\n- 구조를 다 생각하고 나서 개발하는 게 좋을까? 아니면 뼈대만 세워두고 개발하면서 차근차근 세우는게 나을까? 쓰고 나니 waterfall과 agile 같기도 하다.\n\n## 느낀 점\n- 다들 잘하는 것 같다. 특히 글렌은 아는게 정말 많다! 페어 프로그래밍 하면서 많이 배운다.\n- TDD 해보고 싶다고만 했지 해본적은 없었는데 의외로 괜찮은 개발 방식인 것 같다.\n- 페어 프로그래밍 힘들긴 한데 내 의견을 설득시켰을 때 좋은 것 같다.\n\n## 내일 할 일\n- 방금 알았는데 브랜치 이름이 깃허브 아이디여야 하는데 racing_car 브랜치에서 작업했다. 글렌한테 알려줘야 할 것  같다.\n- 내일 TIL 쓰기.\n- 밝은 표정과 긍정적인 마인드, 가벼운 마음가짐 갖고 살아보기\n"},{"excerpt":"2/8 단위 테스트 동작 확인을 위해 테스트 메서드를 테스트할 때 잘못된 로직의 메서드는 어떻게 검증할까? -> 실패하는 테스트 먼저 만들기 테스트를 만들기 전에 검증하고자 하는 메서드가 어떤 기능인지, 어떤 상황에서 문제가 될 수 있을지를 고민해본다. 경계값을 잘 찾아본다. 경계값 찾기 : 내가 검증하고자 하는 값의 끝단을 찾는다. 단위 테스트가 있다고…","fields":{"slug":"/onboarding-week1/"},"frontmatter":{"date":"2023년 02월 08일 01:02","title":"온보딩 1주차","tags":null},"rawMarkdownBody":"## 2/8\n### 단위 테스트\n- 동작 확인을 위해 테스트\n- 메서드를 테스트할 때 잘못된 로직의 메서드는 어떻게 검증할까? -> 실패하는 테스트 먼저 만들기\n- 테스트를 만들기 전에 검증하고자 하는 메서드가 어떤 기능인지, 어떤 상황에서 문제가 될 수 있을지를 고민해본다. 경계값을 잘 찾아본다.\n- 경계값 찾기 : 내가 검증하고자 하는 값의 끝단을 찾는다.\n- 단위 테스트가 있다고 모든 경우를 테스트할 수 있는 것도 아니다. 어느 선까지 테스트를 할 것인지 기준을 정해보자.\n- 나의 테스트 기준 : 내가 처한 상황에서 구문이 제대로 동작한다는 확신이 들 때까지!\n- 내가 단위 테스트를 작성하는 이유 : 여러 가지 케이스를 편리하게 실행시킬 수 있어서\n- 내가 작성한 좋은 단위 테스트는 어떤 부분에서 좋은 단위 테스트였을까? : 여러 가지 테스트 케이스를 생각해볼 수 있고, 빼놓은 케이스가 있는지 확인해볼 수 있었다.\n- 좋은 단위 테스트를 작성하기 위해 어떠한 시도를 해볼 수 있는가? : 단위 테스트의 단위, 로직 검증은 어떻게 할 수 있을지, 읽기 쉬운 코드인지, 경계값이 포함된 케이스가 있는지 확인하기. 로직이 좋은 코드로 되어 있어서 테스트 코드를 작성하기 쉬운가? \n- [private 메서드의 코드는 어떻게 테스트할 수 있을까?](https://yearnlune.github.io/java/java-private-method-test/#)\n\n### 코드 품질\n- 코드는 잘 동작해야 한다. 코드에 매몰되어 놓치지 않아야 한다.\n- 코드는 읽기 쉬워야 한다. 의도를 드러내고 유지보수하기 좋은 것은 매우 중요하다. 미래의 나를 위해 예쁘게 짜자.\n- 코드는 보기 좋아야 한다. 심미성의 부분. 컨벤션이나 들여쓰기, 줄바꿈 등인 듯하다.\n- 코드는 관리하기 쉬워야 한다. 아무리 잘 작성해도 예상과 다르게 동작할 수 있다. 개발 이후가 가장 중요하고, 2,3차 사용자들이 관여하는 점에서 매우 중요한 항목이다. 계속 유지보수 되어야 한다.\n- 코드는 테스트 가능해야 한다. 자동화 테스트가 가능해야 하고, 설계 의도에 맞게 올바르게 동작하는지 확인한다.\n- 코드는 변경하기 쉬워야 한다. 기능의 변경, 확장, 재사용은 매우 빈번하다. 최소한의 노력으로 변경 가능해야 하며, 부작용은 최소화해야 한다.\n- 코드는 효율적으로 동작해야 한다. 코드의 동작이 아닌 산업적인 관점에서 효율적인 것이 중요하다. 최소의 개발 리소스를 투입하여 결과물이 나올 수 있어야 한다. (인적 리소스 포함)\n- 좋은 코드는 한 순간에 만들어지지 않는다.\n\n### 최소한의 안전장치\n1. 하고자 하는 내용을 README에 정리한다.\n2. 함께하는 팀원, 크루에게 먼저 의도를 드러내면서 의사소통한다.\n3. 구조를 잡고 시작한다. 머리 속에 그려지는 내용에 대한 구조를 잡는다.\n4. 매번 최선으로 작성할 수는 없겠지만, 일관성 있게 작성한다.\n5. 여러 상황을 고려하여 최적의 코드를 작성한다.\n\n## 2/9\n[[../private/wooteco-secret|들었던 공지사항]]\n### 요구사항 정리하기\n- 자동차는 전진하거나 / 멈출 수 있다.\n- 자동차는 이름이 있다.\n- 자동차 이름은 5자 이하만 가능하다.\n- 자동차는 n번 이동이 가능하다.\n- 자동차가 전진하는 조건은 0부터 9 사이다. \n- 자동차의 전진 조건은 랜덤으로 정해진다.\n- 자동차는 4 이상일 경우 전진한다.\n- 자동차는 3 이하일 경우 멈춘다.\n- 자동차 경주 게임은 완료 후 우승자를 구할 수 있다.\n- 자동차 경주 게임의 우승자는 한 명 이상일 수 있다.\n\n요구 사항은 따로 정하지는 않았는데, 이런 식으로 객체의 역할을 분리해보는 방식도 좋은 것 같다.\n\n### 테스트만을 위한 코드는 어떤가?\n- 잘 생각해봐야 한다. 정말로 테스트만을 위한 코드인지 생각해본다. 내가 설계한 프로그램에서 어색한 부분을 맡지는 않는가?\n\n\n"},{"excerpt":"LOG 우테코 OT가 있었다. 아침에 일찍 나왔다고 생각했는데 지하철도 늦게 오고 하다보니.. 늦었다 ㅠ 11층에서 내려서 계단으로 가려고 했는데 계단이 안 열려서 더 늦었다. 다음부터는 그냥 14층으로 가는 엘리베이터를 타야겠다. 내일은 9시 45분까지 가야해서 6시 50분에는 일어나야 할 판이다. 글렌, 토리, 체인저, 망고, 포이와 온보딩 팀이 되었…","fields":{"slug":"/2023-02-07/"},"frontmatter":{"date":"2023년 02월 07일 09:02","title":"2023년 02월 07일","tags":null},"rawMarkdownBody":"## LOG\n* 우테코 OT가 있었다. 아침에 일찍 나왔다고 생각했는데 지하철도 늦게 오고 하다보니.. 늦었다 ㅠ 11층에서 내려서 계단으로 가려고 했는데 계단이 안 열려서 더 늦었다. 다음부터는 그냥 14층으로 가는 엘리베이터를 타야겠다. 내일은 9시 45분까지 가야해서 6시 50분에는 일어나야 할 판이다.\n* 글렌, 토리, 체인저, 망고, 포이와 온보딩 팀이 되었다. 연극이 굉장히 두렵다. \n* 오늘은 출석을 안 해서 다행이었다. OT라 설명만 할 줄 알았는데 페어 프로그래밍을 시작했다. 글렌과 자동차 경주 미션 페어가 되었다. 오늘 해야 하는 분량은 난이도가 높지 않아서 마무리할 수 있었다.\n  \n## 배운 것\n* 글렌이 인텔리제이 단축키나 템플릿을 많이 알려줬다. 단축키 잘 못 외우는데 이번에 꽤 신기한 것들을 배웠다.\n * command + alt + v : 변수 추출 (선언 뒷부분만 쓰면 알아서 변수 이름을 만들어준다!)\n * command + e : 이전 문서로 이동\n * control + shift + r : 실행\n * 테스트 코드 템플릿 만들어 둔 거 신기했다.\n * given, when, then : given은 주어진 것 (값 같은거?), when은 어떤 것을 했는지, then은 확인해야 하는 것. 주관적으로 해석했는데 맞는지는 모르겠다.\n\n## 어려웠던 점\n* 새로운 사람들과 만난게 그렇게 오래되지도 않은 것 같은데 쉽지 않았다. 그래도 다들 좋은 사람들이라 슬쩍 끼어서 이야기할 수 있었다.\n* 모르는 사이에서 대화 주제를 생각해내는게 여전히 어려운 것 같다.\n\n## 느낀 점\n* 다양한 사람들이 있는 것 같았다. 팀원분들 나이는 안 물어보는게 불문율인 것 같아서 여쭤보지 않았다.\n* 그래도 인간 관계에 스트레스 받지는 말자. 너무 깊게 생각하지 않는게 중요하다. 조급하게 생각하지 말고 좀 마음을 편하게 먹어야겠다.\n\n## 내일 해야 하는 것\n* 연극 주제 정하기\n"},{"excerpt":"교육 과정 프로그래밍 코스 레벨1 : 간단한 언어 - 이번주부터 8주간 레벨1 레벨2부터 스프링 진행 레벨3 유지보수 경험 레벨5는 4주. 취업 준비 기간 레벨 시작은 화요일부터 레벨 1 방학기간 : 3/31 ~ 4/10 방학 기간 중 캠퍼스는 열지 않음 레벨3 팀프로젝트는 과정을 섞어서 진행 (캠퍼스도 섞을 예정 - 몇 주 간격) 글쓰기 각 레벨별 글쓰…","fields":{"slug":"/wooteco-ot/"},"frontmatter":{"date":"2023년 02월 07일 01:02","title":"우아한테크코스 OT","tags":["우테코"]},"rawMarkdownBody":"\n## 교육 과정\n\n### 프로그래밍 코스\n\n* 레벨1 : 간단한 언어 - 이번주부터 8주간 레벨1\n* 레벨2부터 스프링 진행\n* 레벨3 유지보수 경험\n* 레벨5는 4주. 취업 준비 기간\n* 레벨 시작은 화요일부터\n* 레벨 1 방학기간 : 3/31 ~ 4/10\n* 방학 기간 중 캠퍼스는 열지 않음\n* 레벨3 팀프로젝트는 과정을 섞어서 진행 (캠퍼스도 섞을 예정 - 몇 주 간격)\n\n### 글쓰기\n\n* 각 레벨별 글쓰기 한 편씩\n* 리뷰 요청, 회의록 작성 등 많은 글쓰기 경험\n* 장문의 글쓰기\n\n### 말하기\n\n* 10분 내외로 발표하는 테코톡 - 10개월 전까지 반드시 발표해야 함. 수료 조건\n* 각 레벨별 학습 내용을 점검하는 레벨 인터뷰\n* 데일리 미팅, 짝 프로그래밍, 팀 프로젝트\n* 관심 주제로 이야기하는 것은 어렵지 않을 것\n\n## 생활 가이드\n\n* 지각 3회당 결석 1회로 간주\n* 전체 과정 중 3번 이상 무단결석 시 퇴소\n* 조퇴가 불가피할 경우 최소 3일 전에 공유\n* 캠퍼스 시간 : am 8:00 ~ pm 11:00\n\n## 온보딩 미션\n\n* 프로그래밍과 관련된 주제로 연극\n* 사람들이 보고 싶게, 듣고 싶게 구성\n* 최대 6명이 한 팀 - 4~5분\n* 무대에 모두가 나올 수 있게 역할 부여\n* 사람들의 기억에 남을 유행어를 만들고 사용\n\n## 데일리 미팅\n\n* 하루 시작 전 20분\n* 하루를 시작하는 현재 감정 공유 등\n* 어려움이 있으면 이야기하기\n* Done / to do / problem\n\n## 추천 도서\n\n* 좋은 코드, 나쁜 코드 - 레벨1 끝나고 읽는 것 추천\n* SQL 첫걸음 - 4장까지 읽는 것 추천\n* 본인이 부족하다 생각하는 부분이 있으면 읽기\n\n## KDT\n\n* 개강일은 내일. 내일부터 출결 신경쓰기\n* 훈련 장려금은 월 최대 31만 6천원 지급 (출석률 80% 이상이어야 받을 수 있음)\n  * 2/8 ~ 3/7 같이 단위 기간 형성\n* 출결은 공휴일 / 방학기간 제외. 출결 시간은 우테코에 있는 시간과 동일\n  * 10시 이전에 한 번, 18시 이후에 한 번 각자 체크\n* 불가피하게 출석하기 힘든 경우 리사에게 공지 - 꼭 전날까지 말하기\n* 2/8 9시 45분에 Zoom에 접속\n"},{"excerpt":"온보딩 우테코-OT 온보딩 1주차 레벨1 레벨1 2주차 레벨1 3주차 레벨1 4주차 레벨1 5주차 레벨1 6주차 레벨1 미션들 자동차 경주 사다리 게임 블랙잭 블랙잭 미션에서 고민한 것들 체스 체스 미션 기록 레벨1 학습로그 default-method singleton-vs-static functional-interface 레벨1에서 한 것들 why-re…","fields":{"slug":"/wooteco/"},"frontmatter":{"date":"2023년 02월 07일 01:02","title":"우아한테크코스","tags":["우테코"]},"rawMarkdownBody":"## 온보딩\n\n* [[wooteco-ot|우테코-OT]]\n* [[onboarding-week1|온보딩 1주차]]\n\n## 레벨1\n\n* [[level1-week2|레벨1 2주차]]\n* [[level1-week3|레벨1 3주차]]\n* [[level1-week4|레벨1 4주차]]\n* [[level1-week5|레벨1 5주차]]\n* [[level1-week6|레벨1 6주차]]\n\n### 레벨1 미션들\n\n* [자동차 경주](https://github.com/Cyma-s/java-racingcar)\n* [사다리 게임](https://github.com/Cyma-s/java-ladder)\n* [블랙잭](https://github.com/Cyma-s/java-blackjack)\n  * [[level1-blackjack|블랙잭 미션에서 고민한 것들]]\n* [체스](https://github.com/Cyma-s/java-chess)\n  * [[level1-chess|체스 미션 기록]]\n\n### 레벨1 학습로그\n\n* [[default-method]]\n* [[singleton-vs-static]]\n* [[functional-interface]]\n\n### 레벨1에서 한 것들\n\n- [[why-return-type-of-add-function-is-boolean]]\n- [[level1-level-log|레벨1 레벨인터뷰]]\n- [[vepohuhyemal-study|베포후헤 스터디]]\n\n## 레벨2\n\n## 레벨3\n\n## 레벨4\n\n## 레벨5\n"},{"excerpt":"2023-02-06 2023-02-07 2023-02-08 2023-02-09 2023-02-10 2023-02-12 2023-02-15 2023-02-16 2023-02-17 2023-02-20 2023-02-21 2023-02-22 2023-02-23 2023-02-24 2023-02-26 2023-02-27 2023-02-28","fields":{"slug":"/2023-02/"},"frontmatter":{"date":"2023년 02월 06일 14:02","title":"2023년 02월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-02-06]]\n- [[2023-02-07]]\n- [[2023-02-08]]\n- [[2023-02-09]]\n- [[2023-02-10]]\n- [[2023-02-12]]\n- [[2023-02-15]]\n- [[2023-02-16]]\n- [[2023-02-17]]\n- [[2023-02-20]]\n- [[2023-02-21]]\n- [[2023-02-22]]\n- [[2023-02-23]]\n- [[2023-02-24]]\n- [[2023-02-26]]\n- [[2023-02-27]]\n- [[2023-02-28]]\n"},{"excerpt":"2023년 1분기 2023-02 2023-03 2023년 2분기 2023-04 2023-05 2023-06 2023년 3분기 2023-07 2023-08 2023-09 2023년 4분기","fields":{"slug":"/2023/"},"frontmatter":{"date":"2023년 02월 06일 14:02","title":"2023년","tags":null},"rawMarkdownBody":"# 2023년 1분기\n* [[2023-02]]\n* [[2023-03]]\n\n# 2023년 2분기\n* [[2023-04]]\n* [[2023-05]]\n* [[2023-06]]\n\n# 2023년 3분기\n- [[2023-07]]\n- [[2023-08]]\n- [[2023-09]]\n\n# 2023년 4분기\n"},{"excerpt":"TIL TIL을 하기로 했다. 블로그 시작을 하게 된 이유가 TIL이었으니 얼른 개시해야지.\n시작하게 된 이유는 우테코 때문이다. 10개월의 긴 시간 동안 기록 없이는 너무 허망하게 시간이 흘러갈 것 같아서. 실제로 그런 적도 많기도 했고 말이다.\n또 다른 목적은 나를 사랑해보기 위해서이다. 계속되는 실패(진짜 실패일지, 내 머릿속으로만 그렇게 생각하는 …","fields":{"slug":"/2023-02-06/"},"frontmatter":{"date":"2023년 02월 06일 13:02","title":"2023년 02월 06일","tags":null},"rawMarkdownBody":"\n## TIL\nTIL을 하기로 했다. 블로그 시작을 하게 된 이유가 TIL이었으니 얼른 개시해야지.\n시작하게 된 이유는 우테코 때문이다. 10개월의 긴 시간 동안 기록 없이는 너무 허망하게 시간이 흘러갈 것 같아서. 실제로 그런 적도 많기도 했고 말이다.\n또 다른 목적은 나를 사랑해보기 위해서이다. 계속되는 실패(진짜 실패일지, 내 머릿속으로만 그렇게 생각하는 건지도 모르겠다) 때문에 나를 온전히 보기 쉽지 않다. 차라리 진짜 객관적인 문서로 남겨서 내가 지금 어떻게 살고 있는지 내가 봤으면 좋겠다는 생각이다. 최대한 꾸준히 쓰고 싶다.\n말이 TIL이지 배운것이 추가된 일일 회고 느낌으로 쓸 것 같다. 템플릿을 만들려다 포기했다. 글을 쓸 때 채우지 못하는 부분이 있으면 자괴감을 느낄 것 같아서 자유 형식으로 쓰려 한다. 익숙해지면 템플릿을 만들어야겠다.\n\n## 우아한테크코스\n사실 조금 걱정이 된다. 지금 마음가짐이 어떤지 모르겠다. 의욕도, 목적도, 목표도 모호한 상태라 그냥 잘 모르겠다. 우테코에서 찾을 수 있지 않을까라는 안일한 마음가짐으로 내일 등교(?)할 예정이다.\n내 마음대로 안 되는 상황에 스트레스를 받는 편인데, 과연 우아한테크코스가 나에게 어떤 영향을 끼칠지 궁금하다. 기왕이면 좋은 영향이었으면 좋겠다.\n\n## 고민\n최근 상담에서도 이야기했었지만 하나가 어느정도 해결되니 다른 하나가 드러나서 쉽지 않다. 생각할수록 생각이 많아진다. 그래서인지 나태해진 것 같다. 우테코에서 자극을 받을 수 있을지...\n이런 이야기는 많이 쓸수록 어두워지니까 그만해야겠다.\n"},{"excerpt":"개발 gatsby 개발 책 짧은 개발 지식 TIL 2023 우테코","fields":{"slug":"/wiki-index/"},"frontmatter":{"date":"2023년 01월 30일 16:01","title":"Wiki Index","tags":null},"rawMarkdownBody":"\n## 개발\n\n  * [[gatsby]]\n  * [[programming-book|개발 책]]\n  * [[short-programming-knowledge|짧은 개발 지식]]\n  \n## TIL\n\n  * [[2023]]\n  * [[wooteco|우테코]]\n"},{"excerpt":"왜 gatsby인가? 큰 이유는 없고, 멋진 블로그 테마를 찾았는데 gatsby 테마라서 gatsby로 블로그를 배포하게 되었다.\n이 테마는 obsidian처럼 그래프로 글 사이의 관계를 볼 수 있는 점이 좋았다.\n사용한 테마는 gatsby-theme-primer-wiki 이다.","fields":{"slug":"/gatsby/"},"frontmatter":{"date":"2023년 01월 30일 10:01","title":"gatsby로 블로그 배포하기","tags":["gatsby","blog"]},"rawMarkdownBody":"\n## 왜 gatsby인가?\n\n큰 이유는 없고, 멋진 블로그 테마를 찾았는데 gatsby 테마라서 gatsby로 블로그를 배포하게 되었다.\n이 테마는 obsidian처럼 그래프로 글 사이의 관계를 볼 수 있는 점이 좋았다.\n사용한 테마는 [gatsby-theme-primer-wiki](https://github.com/theowenyoung/gatsby-theme-primer-wiki) 이다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}